;NEXT:
;3. CAN POSSIBLE REMOVE WORLDCOL AND USE TESTCOL.

.COMMAND -w142
;		NES KUNG FU GAME STATE MACHINE
;
;COPYRIGHT 1990 BY DANIEL LAWTON, ALL RIGHTS RESERVED.
;LAST UPDATE STARTED ON 9/15/90

;			HOW THIS STATE MACHINE WORKS:
;
;TO ASSEMBLE, YOU JUST RUN A65 KUNGFU.  THE KUNGFU.ASM FILE "INCLUDES"
;ALL NECESSARY FILES.  THESE FILES ARE KUNGSUBS.ASM, KUNGTAB.ASM,
;YOURBACK.ASM, YOURCODE.ASM, YOURSND.ASM, AND DRAWDATA.ASM.  
;YOURBACK AND DRAWDATA ARE MADE AUTOMATICALLY
;BY THE ND.EXE DRAWING PROGRAM.  YOURBACK HAS BACKGROUND DATA FOR THE
;SECOND ROM PAGE AND DRAWDATA HAS PALETTE/SPRITE DEFFINITIONS.  KUNGSUBS
;HAS SUBROUTINES THAT GO DIRECTLY TO THE HARDWARE.  KUNGFU IS THE STATE
;MACHINE EXECUTION MAINLINE.  KUNGTAB IS WHERE YOU PUT YOUR GAME PLAY
;DATA.  YOURCODE AND YOURSND ARE EXPLAINED AT THE TOP OF KUNGTAB.ASM.
;THE RESULT OF THE ASSEMBLY IS CODE.PRG WHICH IS LOADED WITH
;THE COLOR DREAMS DEBUGGER BOARD FOR THE NES.  IT WILL HAVE 2 32K SEGMENTS
;EACH WITH A 6 BYTE HEADER.  THE FIRST LOADS INTO PAGE 0 AND THE SECOND
;INTO PAGE 1.  YOU MUST ALSO HAVE YOUR .VID FILE WHICH IS ALSO CREATED
;AUTOMATICALLY BY THE DRAWING PROGRAM.
;
;THE STATE MACHINE USES THE DATA YOU PLACE IN KUNGTAB TO EXECUTE THE 
;GAME.  THERE ARE 3 MAIN THINGS YOU DO IN KUNGTAB.  YOU DEFINE WORLDS
;WHICH ARE BACKGROUNDS AND PALETTES.  YOU DEFINE "ENTITIES" WHICH ARE
;MOVING SPRITES.   FINALLY, YOU DEFINE THINGS IN THE BACKGROUND WHICH
;INTERACT WITH THE SPRITES.  YOU NEED TO CHECK OUT KUNGTAB.ASM AND SIMPLY
;GO THROUGH IT LINE BY LINE SETTING THE DEFINED PARAMETERS IF YOU WANT
;LEARN TO USE THE STATE MACHINE.  THIS MODULE SHOULD OPERATE TRANSPARENTLY
;TO YOU, YOU SHOULD NOT MAKE MODIFICATIONS HERE.  

;AT BOOT THIS PROGRAM SIMPLY ACTIVATES WORLD #0 AND ITS UP TO YOU TO
;DETECT RESET, INITIALIZE FLAGS, AND LOOK FOR THE START KEY. 
;CHECKOUT KUNGTAB AND BE METHODICAL ABOUT SETTING AND UNDERSTANDING 
;EACH ENTRY.

;			PROGRAMMER'S WARNING
;
;ALL PROCESSING OF ENTITY MOVEMENTS AND WORLD SCROLL TAKES PLACE OUTSIDE
;NMI.  DURING NMI WE ONLY SUPPORT JOYSTICKS (WHICH ONLY SET VARIABLES
;AND FLAGS).  ALSO, NMI KEEPS THE TIME FOR THE MAINLINE BY SETTING 
;TIMETICK AND PHASE4.  YOU CAN'T MIX
;LEVELS ON CALLS TO THE KUNGSUBS IN SOME CASES.  THINK ABOUT IT BEFORE
;YOU ADD CUSTOM CODE.
;

.EQU	REPRATE,4		;KEY REPEAT RATE IN 1/60 SECONDS.  DON'T 
				;MONKEY WITH THIS!

.EQU	J1REPENA,B'00001111	;REPEAT ENABLE FLAG BITS FOR EACH J1 BUTTON
.EQU	J2REPENA,B'00001111	;REPEAT ENABLE FLAG BITS FOR EACH J2 BUTTON
				;THE ARROWS KEYS MUST REPEAT. OTHERS MUST NOT.

;WARNING!!! THE ORG FOR ENEMY0 ASSUMES THIS MANY.  YOU COULD ADD 1 MORE
;SOUND SLOT BUT NOTHING ELSE.
.EQU	SPSLOTS,16		;MAX ALLOWED ACTIVE SPRITE BLOCKS
.EQU	SNDSLOTS,5		;MAX ALLOWED ACTIVE SOUND STRUCTURES
				;TOTAL=211 BYTES

INCLUDE( KUNGSUBS.ASM)

;HERE ARE THE SOUND SLOTS.  EACH PARTICULAR FUNCTION HAS A DEDICATED
;SLOT.

;0-3 ARE THE MUSIC SLOTS 0-3

.EQU	DINGSLOT,4		;FOR THE PAUSE DING OR NOISE COMMAND

INCLUDE( KUNGTAB.ASM)		;THIS IS THE WORLD FLAGS AND CONTROL DATA
INCLUDE( DRAWDATA.ASM)		;THIS IS THE SPRITE AND PALETTE DEFFINITIONS
				;AND OTHER DRAWING PROGRAM OUTPUT.  
				;BACKGROUNDS ARE USUALLY IN YOURBACK.ASM BUT
				;IF THERE'S ROOM SOME CAN BE PUT HERE TOO.

;			WORLD FLAGS DESCRIPTION
;
;THE WORLD FLAGS ARE PUT INTO KUNGTAB.ASM AT THE BOTTOM IN THE TABLES
;THAT CONTROL EACH WORLD.  EACH COMMAND OCCUPIES 6 BYTES EVEN IF THEY
;ARE NOT NEEDED IN ORDER TO SPEED UP INDEXING DURING GAME PLAY.  IN
;THE COMMAND TABLES, EACH 6 BYTE SEQUENCE MUST BE PRECEEDED BY A 1
;WORD COLUMN NUMBER ON SCREEN.  THUS EACH COMMAND THERE TAKES 8 BYTES.

;HERE IS A SAMPLE COMMAND TO LAUNCH A HERO ENTITY:
;
;	.DRW	2
;       .DB	H'F0,HEROID,9+54,H'00,-1,-1	;LAUNCH HERO

;SOMETIMES THE COMMANDS ARE FOR THINGS PASSED TO AN ENTITY SUCH AS CLIMB
;COMMANDS.  YOU CAN SET BIT H'8000 IN THE SCREEN COLUMN WORD TO DOUBLE
;THE COMMAND.  WHEN SET THIS IS THE SAME AS IF YOU PUT 2 OF THE COMMANDS
;WITH THE SECOND HAVING A COLUMN 1 MORE THAN THE FIRST:

;	.DRW	3
;	.DB     77,157,CLIMB,0,0,0
;	.DRW	4
;	.DB     77,157,CLIMB,0,0,0
;
;	IS THE SAME AS:

;	.DRW	H'8003
;	.DB     77,157,CLIMB,0,0,0
;
;DONT USE THIS WITH COMMANDS H'F0 AND ABOVE, ITS ONLY VALID FOR
;COMMANDS PASSED TO THE ENTITY AS DESCRIBED BELOW.
;
;SOME COMMANDS ARE ACTIVATED WHEN THE SCREEN SCROLLS ONTO THEM (LAUNCH ENEMY,
;SCREEN SCROLL LIMIT, ETC.) AND SOME ARE ACTIVATED WHEN AN ENTITY STEPS
;ONTO THEM.  THE SCREEN SCROLL COMMANDS ARE SCANNED FOR WHEN A SCREEN
;FIRST COMES UP.  THERE AFTER, SCROLLING THE SCREEN CAUSES ANY NEW COMMANDS
;THAT SCROLL IN TO BE USED.  THEY ARE ONLY CONSIDERED SCROLLED ONTO WHEN
;PIXEL 0 OF THAT COLUMN IS COMPLETELY VISIBLE (THIS IS TO MAKE SURE THAT
;LAUNCHED ENTITIES CAN BE PLACED DOWN ACCURATELY TO THE PIXEL LEVEL).
;
;ENTITY ACTIVATED COMMANDS ARE IGNORED UNTIL
;AN ENTITY STEPS INTO THEIR COLUMN AND ROW RANGE.  THERE IS ONLY 1
;ENTITY ACTIVATED COMMAND, IT REPORTS TO A GENERIC ANIMATION/MOVEMENT 
;FUNCTION IN THE ENTITIES TABLE AND THAT MOVEMENT ROUTINE DECIDES WHAT
;TO DO ABOUT IT (A DOOR, CLIMB, ETC).  THE ENTITY HAS A "HOT SPOT"
;THAT IS USED TO DECIDED WHEN HE FALLS INTO THE ROW AND COLUMN RANGE 
;OF THE COMMAND.  AS STATED ABOVE, YOU CAN DOUBLE THESE COMMANDS BY
;SETTING BIT H'8000 IN THE COLUMN WORD SPECIFICATION.

;HERE IS A "PICTURE" SHOWING THE "HOT SPOT" OF THE ENTITY 
;(Xs REPRESENT ENTITY):
;
;
;           XXX	
;	    XXX	    
;	    XxX	
;	     ^
;	     ONLY THE CENTER BOTTOM POINT IS ACTIVE 

;THE FIRST BYTE OF EACH COMMAND DETERMINES WHAT THE COMMAND DOES.
;THE REMAINING BYTES (5 MORE) ARE SPECIFIC TO THE COMMAND.  HERE
;ARE THE COMMANDS:

;00 = NO ACTION OR TARGET.  MUST REMAIN 0.  USED INTERNALLY.
;
;01 TO H'EF = WORLD EVENT COMMAND.  
;		COMMANDS IN THIS RANGE ARE ACTUALLY TOP OF SCREEN ROW
;		SPECIFICATIONS FOR A SCREEN RANGE IN WHICH YOUR ENTITY
;		WILL BE NOTIFIED IF IT STEPS INTO THAT RANGE.  IN ORDER
;		TO SAVE PROCESSOR POWER, EACH ENTITY HAS A BIT TO DETERMINE
;		IF IT WILL CHECK FOR COMMANDS OR NOT CHECK.  WHEN THE BIT
;		IS SET (IN ENTITYTAB) THEN THE ENTITY WILL BE TOLD WHEN
;		HE WALKS ONTO THIS COMMAND.   HE IS CONSIDERED HAVING 
;		WALKED ONTO THE COMMAND IF HIS HOTSPOT (HIS BOTTOMMOST PIXEL
;		IN THE CENTER OF HIS BODY) FALLS BETWEEN THE TOP ROW SPECIFIED
;		IN THE FIRST BYTE AND THE BOTTOM ROW SPECIFIED IN THE 
;		SECOND BYTE.  SOME OF THE REMAINING BYTES ARE PASSED TO
;		YOUR MOVEMENT CODE IN KUNGTAB.ASM TO DECIDE WHAT THIS
;		COMMAND IS SUPPOSED TO DO.  SOME EQUATES HAVE BEEN
;		DEFINED FOR THE FIRST OF THE PASSED BYTES IN ORDER TO
;		ESTABLISH A STANDARD FOR DOORS OR CLIMBING BUT ACTUALLY
;		YOU CAN USE ANY VALUE FROM 0-255 FOR EITHER OF THE COMMAND
;		BYTES AND YOUR CODE CAN DECIDE BASED ON THE VALUE OR
;		ON THE EQUATES PROVIDED.  
;
;		YOU CAN TEST IN YOUR CODE TO SEE IF THE UP OR DOWN ARROW
;		KEY HAS BEEN PRESSED.  THE STATE MACHINE WILL RE-REPORT
;		THE COLUMN TO YOU IF THE UP OR DOWN KEY IS PRESSED WHILE YOU
;		ARE ON THE COLUMN EVEN IF THE COLUMN HAS ALREADY BEEN
;		REPORTED.  THIS IS DONE SO YOU CAN HAVE PIPES LIKE IN
;		SUPER MARIO OR CAN HAVE DOORS THAT YOU HAVE TO PRESS UP
;		TO GO INTO.  BUT FOR THIS TYPE OF USAGE ITS BEST TO USE
;		THE QUALIFYING BYTE FIELDS TO KEEP THE COMMAND FROM BEING
;		REPORTED IF THE CORRECT KEYS ARE NOT PRESSED.  OTHERWISE
;		YOU HERO WILL "STAGGER" AS HE RUNS OVER THE COMMANDS  AND USES
;		UP PROCESSOR POWER ONLY TO DECIDE THE UP KEY WAS NOT PRESSED.
;		IF YOU USE THE QUALIFYING BYTES HERE'S HOW THEY WORK:  THE
;		"AND" MASK IS ANDED TO THE JOYSTICK BITS AS USED IN THE
;		<BUTTON> COMMAND DESCRIBED IN KUNGTAB.  THEN THE RESULTING
;		VALUE IS COMPARED TO THE MATCH VALUE.  THE COMMAND IS ONLY
;		REPORTED IF THERE IS A MATCH.  SET BOTH TO 0 TO DISABLE THIS
;		FUNCTION.

;
;		HERE IS THE FULL COMMAND FORMAT:
;		 1 BYTE TOP TILE (PIXELS\8) ROW (1 ORIGIN!)
;		 1 BYTE BOTTOM ROW (1 ORIGIN!)
;		 1 BYTE TO PASS TO THE MOVEMENT CODE AS PARAM1 (WORLDCMD).
;		 1 BYTE TO PASS TO THE MOVEMENT CODE AS PARAM2.
;		 1 BYTE JOYSTICK BITS TO MATCH (IF ENTITY IS ATTACHED TO
;			A JOYSTICK).   USE 0 TO DISABLE THIS FUNCTION.
;		 1 BYTE AND MASK TO APPLY TO JOYSTICK BITS BEFORE COMPARING
;			TO THE MATCH VALUE.  USE 0 TO DISABLE THIS FUNCTION.
;
;		HERE ARE SOME EQUATES RECOMMENDED TO BE PLACED IN PARAM1
;		AS A SIGNAL OF WHAT YOU WANT.  YOU WOULD PUT THE QUALIFIER
;		IN PARAM2 (WORLD TO GO TO, ETC.):
			.EQU	DOOR,0		;USE FOR AN OPENING
			.EQU	CLIMB,1		;USE FOR CLIMBING (LADDERS)
			.EQU	BARRIER,2	;USE FOR BARRIERS,FORCE FIELDS
			.EQU	SINK,3		;USE FOR SWAMPS, QUICKSAND
			.EQU	TUNNEL,4	;USE FOR TUNNEL (HORIZONTAL)
			.EQU	PIPE,5		;USE FOR PIPE (VERTICAL)
			.EQU	BEAM,6		;TRANSPORTER (BEAM ME UP!)
			.EQU	NEWWORLD,7	;GO TO NEW WORLD.  PUT NEW
			.EQU	ELAUNCH,8	;PLACE THAT LAUNCHES ENEMY
			.EQU	TRAP,9		;BOOBY TRAP THAT DOES ???
			.EQU	TRANSFORM,10	;TO TRANSFORM THE ENTITY.
			.EQU	ENDSCENE,11	;FOR END SCENE REQUEST
			.EQU	WARPZONE,12	;WARP ZONE ENTRANCE
			.EQU	PORTAL,13	;DOOR TO ANOTHER WORLD

;F0 = LAUNCH ENTITY.  
;		          THIS COMMAND WILL LAUNCH THE ENEMY TYPE YOU SPECIFY
;			  FROM THE LOCATION YOU SPECIFY.  IT IS ILLEGAL
;			  TO LAUNCH AN ENEMY FROM COLUMN 65535.
;
;	             	BYTE 1 = ENEMY NUMBER FROM ENTITYTAB
;			BYTE 2 = TEXT ROW TO LAUNCH FROM (USES TEXT COL
;			  	 OF COMMAND LOCATION).
;			BYTE 3 = PLACED INTO PARAM2 OF THE ENTITY. NOTE:
;				 ENTITIES LAUNCHED FROM OTHER ENTITIES HAVE
;				 -1 PLACED HERE SINCE THERE IS NO BYTE 3.
;			BYTE 4 = -1 TO LAUNCH ENTITY IMMEDIATLY WHEN HIS
;				 LAUNCH COLUMN COMES FULLY ONTO SCREEN.
;				 ANY OTHER VALUE IS THE COLUMN ON SCREEN
;			         TO LAUNCH HIM FROM WHEN HIS ORIGIN COLUMN
;				 REACHES THAT POINT.  FOR EXAMPLE, SET THIS
;				 TO 16.  THEN AS THE WORLD SCROLLS HE WILL
;				 POP UP IN THE CENTER OF THE SCREEN.  WHILE
;				 WAITING TO COME TO THE CORRECT POINT HE WILL
;				 BE IN "SLEEP" MODE.  THIS MODE TAKES UP
;				 AN ENTITY SLOT BUT THE ENTITY ITSELF DOES
;				 NOT EXECUTE CODE AND IS NOT VISIBLE.
;			BYTE 5 = PERMANENT MEMORY INDEX TO USE FOR THIS ENTITY.
;				 USED IN CONJUNCTION WITH THE ENMEMORY
;				 COMMAND.  SET THIS TO -1 TO LAUNCH THE 
;				 ENTITY EVERYTIME THE COMMAND SCROLLS INTO
;				 THE LAUNCH POINT.  SET TO ANY OTHER VALUE
;				 TO LAUNCH THIS ENTITY ONLY IF IT HAS NOT
;				 PREVIOUSLY BEEN KILLED.  THIS ALLOWS UP TO
;				 255 PERMANENT MEMORY ENEMIES WHO ONCE DEAD
;				 WILL NOT COME BACK.  SEE COMMAND <ENMEMORY>. 
;
;			UP TO 16 ENEMIES CAN BE LAUNCHED AT THE SAME TIME.
;			IF ALL ENEMIES ARE ALREADY ACTIVE, 
;			THIS COMMAND IS IGNORED.  
;
;F1 = LEFT WORLD LIMIT.	
;
;	WHEN THIS COMMAND IS SCROLLED INTO THE LEFTMOST SCREEN POSITION,
;	NO FURTHER LEFTWARDS SCROLLING WILL BE POSSIBLE IF THIS COMMAND
;	IS ENCOUNTERED SCROLLING LEFT.

;	THIS COMMAND IS PLACED ON THE ACTUAL BACKGROUND COLUMN AT WHICH
;	YOU WANT LEFTWARDS SCROLLING TO STOP.  IT "STICKS" TO THE LEFT
;	OF THE SCREEN WHEN HIT AND WILL NOT MOVE INTO A RIGHTWARDS 
;	VIEWABLE SCREEN POSITION (BUT THE SCROLLING TO THE RIGHT WILL NOT
;	BE AFFECTED). THE REMAINING 3 BYTES OF THIS COMMAND ARE UNUSED.
;
;F2 = RIGHT WORLD LIMIT
;
;	THIS COMMAND FUNCTIONS LIKE THE LEFT WORLD LIMIT COMMAND EXCEPT
;	THAT IT PREVENTS RIGHTWARDS MOVEMENT. THE REMAINING 3 BYTES OF 
;	THIS COMMAND ARE UNUSED.

;F3 = CONDITIONAL LEFT WORLD LIMIT
;
;	THIS COMMAND FUNCTIONS THE SAME AS F1 EXCEPT THAT THE SCREEN SCROLL
;	IS STOPPED LEFTWARDS ONLY IF ENTITIES MARKED AS MUST DEFEAT 
;	(BIT 04 IN ENTITYTAB FLAG BITS) ARE STILL ALIVE (ON SCREEN).

;F4 = CONDITIONAL RIGHT WORLD LIMIT
;
;	THIS COMMAND FUNCTIONS THE SAME AS F2 EXCEPT THAT THE SCREEN SCROLL
;	IS STOPPED LEFTWARDS ONLY IF ENTITIES MARKED AS MUST DEFEAT 
;	(BIT 04 IN ENTITYTAB FLAG BITS) ARE STILL ALIVE (ON SCREEN).
;
;
;********************* STATE MACHINE RAM EQUATES *********************
;
;REMEMBER!!! THESE MUST NOT OVERLAP WITH THE VALUES USED BY KUNGSUBS.ASM.

.EQU	WORLD_REQUEST,H'00	;SET TRUE TO REQUEST A NEW WORLD.
.EQU	CURWORLD,H'01		;CURRENT WORLD (VALID IF WORLD_REQUEST=0)
.EQU	WORLD_INDX,H'02		;CURRENT WORLD AS AN INDEX (0,2,4,6,ETC).

.EQU	SAFEX,H'03		;FOR SAVING X VALUES.
.EQU	SAFEY,H'04		;FOR Y VALUES.
.EQU	SAFEX2,H'05		;A SECOND PLACE TO SAVE X 
.EQU	SAFEY2,H'06		;SAME FOR Y.

.EQU	RESETFLG,H'07		;SET TRUE AT RESET FOR THE RESET COMMAND

.EQU	SILENCEIT,H'08		;USED BY SELECT MODE TO SILENCE NEW WORLDS.

.EQU	TIMETICK,H'09		;LOADED WITH CLOCKPHASE.  WHEN IT DECS TO
				;ZERO PHASE4 IS SET.
				;AND USED BY MANY ROUTINES FOR PACING.

.EQU	SPECGOTO,H'0A		;TRUE IF SPECIAL WORLDGOTO CONDITION

.EQU	LEFTCOL,H'0B		;LEFTMOST COLUMN TO HAVE IN THE GOTO WORLD
;		H'0C		;OR WHEN SAVING A WORLD'S STATE.

.EQU	CLOCKP,H'0D 		;CLOCKPHASE THATS USER MODIFIABLE.

.EQU	STARTCOL,H'0E		;LEFTMOST COLUMN OF SCREEN WITHIN
;		   0F		;CURRENT BACKGROUND.

.EQU	SAFEBYTE,H'10		;TEMPORARY BYTE FOR USE FROM BOTH INSIDE
				;AND OUTSIDE NMI

.EQU	SAFEWORD,H'11		;TEMPORARY WORD FOR USE FROM OUTSIDE NMI.
;		 H'12		;EVEN THOUGH ITS IN LOW RAM, DON'T USE IT
				;FOR INDIRECT SO THAT WE CAN TRANSLATE
				;THIS CODE TO OTHER MACHINES MORE EASILY.

.EQU	SCROLLFLG,H'13		;SCROLL FLAG.  BIT ORIENTED:
				;08 = UP SCROLL DISABLED
				;04 = DOWN SCROLL DISABLED
				;02 = LEFT SCROLL DISABLED
				;01 = RIGHT SCROLL DISABLED

.EQU	PHASE4,H'14		;SET BY USER_NMI TO SIGNAL ITS TIME TO MOVE
				;ENEMIES.  BIT ORIENTED:
				;01 = TIME FOR NEW CLOCK PHASE (MOVE ENEMIES)
				;80 = LAST MOVEMENT CYCLE GOT BEHIND.

.EQU	SELKEY,H'15		;WHAT THE SELECT BUTTON SHOULD DO
;	     H'16		;-1 IS NO INTERRUPT

.EQU	NEWCOL,H'17		;USED BY JOYSTICK ROUTINE TO FLAG
				;THAT A JOYSTICK ENTITY NEEDS TO TEST
				;A COLUMN AGAIN.

.EQU	PAUSEFLG,H'18		;USER CAN DISABLE PAUSE HERE.  
				;DEFAULT=DISABLED

.EQU	RNDNUM1,H'19
.EQU	RNDNUM2,H'1A
.EQU	XRANDOM,H'1B		;FOR RANDOM NUMBER GENERATOR

.EQU	WORLDCOL,H'1C		;COLUMN WITHIN BACKGROUND PASSED TO SCREENFLGS
;		   1D

.EQU	RNDPTR,H'1E		;FOR THE RANDOM NUMBER GENERATOR
;		 1F

.EQU	ALTPHASE,H'20		;INCREMENTED EACH PHASE FOR HALF SPEED
				;ENTITIES

.EQU	NUMBUF,H'20 		;BUFFER TO HOLD VIDEO WRITE DATA FOR CONVNUM
;	       H'24 

.EQU	NMICOL,H'25		;HOLDS TESTCOL FOR USE WHEN NEEDCOL IS SET.
;	       H'26

.EQU	SAVEDWORLD,H'27 	;FOR STATREQUEST COMMAND.

.EQU	BPAUSE,H'28		;SET TRUE WHEN START IS PRESSED TO FORCE PAUSE.

.EQU	FLAGBYTE,H'29		;THE FIRST OF 6 BYTES USED WITH THE HERO 
.EQU	BYTE1,H'2A		;WORLD COMMAND THAT IS CURRENTLY BEING RUN
.EQU	BYTE2,H'2B
.EQU	BYTE3,H'2C
.EQU	BYTE4,H'2D
.EQU	BYTE5,H'2E

.EQU	QUARTERYLOST,H'2F	;AMOUNT OF GLOBAL_YSCR LOST BY THE 1/4ers
.EQU	HALFYLOST,H'30		;AMOUNT LOST BY THE 1/2 SCROLLERS.  WE ADD
				;IT UP AND USE IT EACH TIME.
.EQU	GLOBAL_YSCR,H'31	;SET TO DIRECTION TO SCROLL ENTITY AS A RESULT
				;OF JOYSTICK CONTROLLED SCREEN SCROLL.
.EQU	HALF_YSCR,H'32		;CALCULATED FOR THOSE THAT USE 1/2
.EQU	QUAR_YSCR,H'33		;FOR THOSE THAT USE 1/4

.EQU	QUARTERXLOST,H'34	;AMOUNT OF GLOBAL_XSCR LOST BY THE 1/4ers
.EQU	HALFXLOST,H'35		;AMOUNT LOST BY THE 1/2 SCROLLERS.  WE ADD
				;IT UP AND USE IT EACH TIME.
.EQU	GLOBAL_XSCR,H'36	;SET TO DIRECTION TO SCROLL ENTITY AS A RESULT
				;OF JOYSTICK CONTROLLED SCREEN SCROLL.
.EQU	HALF_XSCR,H'37		;CALCULATED FOR THOSE THAT USE 1/2
.EQU	QUAR_XSCR,H'38		;FOR THOSE THAT USE 1/4

.EQU	MOMINDX,H'39		;JOYSTICK MOMENTUM INDEX
.EQU	JOYINDX,H'3A		;JOYSTICK INDEX. 0 OR 1

.EQU	ENABLE_SELECT,H'3B	;USED TO ENABLE WORLD SELECT MODE

;FOR EACH OF THE 2 JOYSTICKS THERE ARE VARIABLES USED WITH AN INDEX
;OF 0 OR 1 TO STORE MOMENTUM OR DECIDE WHICH ENEMY TO APPLY IT TO.

.EQU	JOYENEMY,H'3C		;ENEMY INDEX ATTACHED TO THIS JOYSTICK.
;		 H'3D		;-1 = NONE.

.EQU	JOYX,H'3E		;ACCUMULATED X MOMENTUM FOR THIS JOYSTICK
;	     H'3F

.EQU	JOYY,H'40		;ACCUMULATED Y MOMENTUM FOR THIS JOYSTICK
;	     H'41

.EQU	SCOREL,H'42		;LOW BYTE OF SCORE FOR JOYSTICK 0 AND 1
;	       H'43		;SCOREH MUST FOLLOW THIS!
.EQU	SCOREH,H'44		;HIGH BYTE OF SCORE FOR JOYSTICK 0 AND 1
;	       H'45		

.EQU	HEROCOUNT,H'46		;COUNT OF HEROS LEFT FOR EACH JOYSTICK
;		  H'47

.EQU	PASSCNT,H'48		;USED BY MOVEENEMY TO ALLOW 3 COMMANDS PER
				;TICK.  RESET BY ANY COMMAND THAT CHANGES
				;MOMENTUM.

.EQU	SAVED1,H'49		;USED TO SAVE STUFF FOR INITSTAT SO THAT
.EQU	SAVED2,H'4A		;ENDREQUEST CAN RESTORE IT.
.EQU	SAVED3,H'4B
.EQU	SAVED4,H'4C

.EQU	SAVESEL,H'4D		;TO SAVE WHAT SELECT DOES IF STATREQUEST WORLD
;		H'4E

.EQU	STARTROW,H'4F		;TOPMOST ROW ON SCREEN (USED IN BLOCK MODE)

.EQU	TOPROW,H'50		;TOPMOST ROW TO HAVE IN THE GOTO WORLD
				;OR WHEN SAVING A WORLD'S STATE.

.EQU	TABLEPTR,H'51		;POINTER TO THE SCREEN COLUMN FLAGS FOR
;		 H'52		;THE CURRENT WORLD.  BOTH NMI AND NON-NMI
				;USE THIS BUT NMI SAVES IT OUT.

.EQU	ENEMYPTR,H'53		;ENEMY POINTER FOR USE BY MOVEENEMY
;		   54

.EQU	EXTRA_PTR,H'55		;INDIRECT POINTER FOR NON NMI USE (ALL USERS)
;		  H'56

.EQU	SETUPFLG,H'57		;USED BY SETUPANIM.

.EQU	CHEATMODE,H'58		;USED TO INFORM CODE THAT CHEAT MODE ENTERED
				;THE CURRENT WORLD.

.EQU	TEST_JMP,H'59		;INDIRECT JUMP FOR HERO FLAGS TESTING.  ALSO
;		 H'5A		;USED AS AN INDIRECT POINTER BY SAME.  CAN
				;BE USED FROM OUTSIDE NMI LEVEL BY ANYONE.

.EQU	SAVEJOY,H'5B		;TO SAVE JOYENEMY FOR STATREQUEST
;		H'5C
		    
.EQU	NEEDCOL,H'5D		;SET TRUE WHEN WE SCROLL THE BACKGROUND IF
				;WE NEED TO TEST A NEW SCREEN COLUMN.  ITS
				;SET BY NMI FOR NON-NMI TO USE.

.EQU	TESTCOL,H'5E		;THE COLUMN WE NEED TO TEST WHEN CALLING
;		  5F		;SCREENFLAGS ROUTINES.  MUST ONLY BE SET 
				;OUTSIDE NMI.

.EQU	CMDBUF,H'60		;BUFFER TO HOLD DATA FOR COMMANDS UP TO 16 BYTES.
.EQU	DATA1,H'61
.EQU	DATA2,H'62
.EQU	DATA3,H'63
.EQU	DATA4,H'64		;THESE ARE HERE TO MAKE DIRECT ACCESS TO
.EQU	DATA5,H'65		;PARAMETERS EASIER
.EQU	DATA6,H'66
;	       H'6F		

.EQU	ENEMYLREG,H'70			;REGISTER LOW.  ALSO USED 
					;TO HOLD THE COLUMN OF LAUNCH WHILE
					;AN ENEMY IS SLEEPING.
.EQU	ENEMYHREG,H'80			;REGISTER HIGH.  ALSO USED TO
					;HOLD THE ROW ON SCREEN AT WHICH TO
					;PUT AN ENEMY WHEN IT NEEDS TO BE
					;LAUNCHED CAUSE ITS SLEEPING.

;90-DF USED BY ENEMYLCOL TO ENEMYLINK

;E0 TO FF ARE RESERVED FOR KUNGSUBS.ASM

;******************* LOW STACK MEMORY *****************

;THERE'S SOME MEMORY IN THE LOW STACK WE CAN USE SO WE USE IT TO REMEMBER
;WHICH ENEMIES HAVE BEEN KILLED. WE ALLOW 256 ENEMIES, 1 BIT IS NEEDED EACH 
;SO THE MEMORY HERE IS 32 BYTES.  ABOVE THAT IS THE STACK AREA.  THE BIT
;IS SET HERE IF THAT ENTITY WAS KILLED, RESET IF ITS STILL ALIVE.

;100-11F FOR USER SUBS TO USE.


.EQU	REMEMBER,H'120		;PLACE TO REMEMBER UP TO 1024 ENEMIES DEATH.
;		 H'13F

.EQU	STATERAM,H'140
;		   15F		;32 BYTES TO HOLD 1 WORD FOR EACH ENTITY

.EQU	COMMONDATA,H'160	;20H BYTES OF COMMON DATA FOR DATAAREA
;		   H'17F	;COMMANDS.  USUALLY ITS FOR PRIZES.

;*************** ENTITY VARIABLES PLACED AT AVAILABLE SPOTS.  ************

.EQU	ENEMYLCOL,H'90		;WORLD COLUMN FLAG THAT LAUNCHED THE ENEMY.
.EQU	ENEMYHCOL,H'A0		;WORLD COLUMN FLAG THAT LAUNCHED THE ENEMY.
.EQU	ENEMYFEET,H'B0		;ENEMIES FEET

.EQU	ENEMYCTRL,H'C0		;CONTROL FLAG FROM ENEMY LAUNCH
;		    CF

.EQU	ENEMYLINK,H'D0 		;ENEMY TO WHOM THIS ENEMY IS LINKED.  
				;-1 = NONE

.EQU	ENEMYCNT,H'360		;ENEMY COUNTER #1
.EQU	ENEMYALT,H'370		;ENEMY COUNTER #2

;********* ENEMY VARIABLES PLACED CONTIGUOUSLY. **************
;
.EQU	EBASE,H'4D0
.EQU	ECNT,16			;NUMBER OF ENEMIES ALLOWED. ACTUALLY YOU CAN'T
				;JUST CHANGE THIS, IT REQUIRES THOUGHT SINCE
				;WE HAVE TO KEEP TRACK OF HOW LOW THIS TABLE
				;GOES.  ALSO, YOU MUST ALLOCATE THAT
				;MANY SPRITE SLOTS (SPSLOTS) AND SET THE
				;LIFE FORCE SLOT TO A VALUE ABOVE THEM.

.EQU	ENEMY0,EBASE		;-1 IF INACTIVE, NOT -1 IF ENEMY IS ACTIVE.  
				;HAS THE ENEMY NUMBER TO USE WITH ENTITYTAB.
				;BE SURE TO SET THIS LAST WHEN INITIALIZING
				;AN ENTITY BECAUSE USER_NMI LOOKS AT IT TO
				;MAKE DECISIONS ABOUT ENTITIES.

.EQU	ENEMYREQ,EBASE+ECNT*1  	;ENEMY REQUESTS.  SET EXTERNALLY TO REQUEST
				;AN ENEMY TO ENTER A MODE.  USE THE 
				;SAME VALUE AS COMMAND 0 IN KUNGTAB
				;USES ("EJUMP", "EFALL", "EDUCK", ETC).
				;THIS DOESN'T ALLOW ACTIVATING WAKEUP
				;MODE SINCE THIS EQUATES TO ZERO WHICH
				;IS THE FLAG FOR NO REQUEST.

.EQU	ENEMYXMOM,EBASE+ECNT*2	;ENEMY'S X MOMENTUM FOR ENEMIES 0-5.
				;ITS THE MOMENTUM/8 AS FOR THE HERO

.EQU	ENEMYYMOM,EBASE+ECNT*3	;ENEMY'S Y MOMENTUM FOR ENEMIES 0-5.
				;ITS MOMENTUM/8 AS FOR THE HERO.

.EQU	ENEMYHEALTH,EBASE+ECNT*4 ;AMOUNT OF HEALTH LEFT IN THE ENEMY.

.EQU	ENEMYDELAY,EBASE+ECNT*5	;SET TO DELAY ENEMY WITH THE DELAY COMMAND.
				;WILL STILL MOVE ACCORDING TO MOMENTUM
				;AND GRAVITY.

.EQU	ENEMYATK,EBASE+ECNT*6	;LAST ENEMY THAT ATTACKED THIS ENEMY. ITS
				;THE SLOT NUMBER, NOT THE ENTITYTAB
				;ENTRY.  -1 = NONE.

.EQU	ENEMYDAMG,EBASE+ECNT*7	;DAMAGE AND ATTACK NUMBER OF LAST ATTACKER
				;07H = DAMAGE REQUESTED
				;08H = REPORT ATTACK NUMBERS 16-31
				;F0H = ATTACK NUMBER REQUESTED.

.EQU	ENEMYHIGH,EBASE+ECNT*8	;ENEMY HEIGHT FROM THE ANIMATION OR SPRITE.
				;ITS HIS PIXEL HEIGHT.

.EQU	ENEMYWIDE,EBASE+ECNT*9	;ENEMY WIDTH FROM THE ANIMATION OR SPRITE.
				;ITS HIS PIXEL WIDTH.

.EQU	ENEMYX,EBASE+ECNT*10	;CURRENT ENEMY X LOCATION

.EQU	ENEMYY,EBASE+ECNT*11	;CURRENT ENEMY Y LOCATION
		
.EQU	ENEMYLROW,EBASE+ECNT*12	;ENEMIES LAST ROW THAT FLAGS TESTED ON

.EQU	ENEMYINL,EBASE+ECNT*13	;LOW BYTE OF WORD INDEX INTO MEMORY WHERE 
				;CURRENT MOVEMENT TABLE IS BEING RUN.

.EQU	ENEMYINH,EBASE+ECNT*14	;HIGH BYTE OF SAME INDEX.

.EQU	ENEMYFLGS,EBASE+ECNT*15	;ENEMY FLAGS FROM ENEMY TABLE AT LAUNCH TIME

.EQU	ENEMYGRAV,EBASE+ECNT*16	;ENEMY Y AXIS GRAVITY

.EQU	ENEMYXLIM,EBASE+ECNT*17	;ENEMY X MOMENTUM LIMIT

.EQU	ENEMYYLIM,EBASE+ECNT*18	;ENEMY Y MOMENTUM LIMIT

.EQU	ENEMYSOLID,EBASE+ECNT*19	;ENEMY SOLID VALUE

.EQU	ENEMYCENTR,EBASE+ECNT*20 ;CURRENT ENEMY CENTER OF BODY X LOCATION

.EQU	ENEMYJSTAT,EBASE+ECNT*21	;SOME MORE ENEMY STATUS BITS.	
				;80H SET = NO JOYSTICK ATTACHED
				;40H SET = ENEMY IS EXECUTING HALF SPEED
				;20H SET = ENEMY IS HIDDEN FOR STATREQUEST.
				;H'10 = LAST JOYSTICK PRESS WAS LEFT
				;H'08 = UNUSED.  RESERVED FOR LAST PRESS UP.
				;H'04 = LINKED ENEMY USES FACE BITS ANYWAY.
				;BITS 03 = JOYSTICK USED:
				;           	0=JOYSTICK 1
				;           	1=JOYSTICK 2

.EQU	ENEMYTLLOW,EBASE+ECNT*22 ;ENTITY'S TARGET LEVEL, LOW BYTE
.EQU	ENEMYTLHI,EBASE+ECNT*23  ;ENTITY'S TARGET LEVEL, HIGH BYTE

.EQU	ENEMYTRACK,EBASE+ECNT*24 ;TARGET TRACKING DIRECTION AND ENTITY
				 ;CURRENT DIRECTION:
				 ;BIT 80H = SET IF THIS ENTITY FACING LEFT
				 ;BIT 40H = SET IF THIS ENTITY UPSIDE DOWN
				 ;BITS 03 = 0-2 X TRACKING FROM COMMAND 9D
				 ;BITS 30 = 0-2 Y TRACKING FROM COMMAND 9E

.EQU	ENEMYTRLOW,EBASE+ECNT*25 ;ENTITY'S TARGET, LOW BYTE
.EQU	ENEMYTRHI,EBASE+ECNT*26  ;ENTITY'S TARGET, HIGH BYTE

.EQU	ENEMYD1,EBASE+ECNT*27	;DAMAGE FLAG #1
.EQU	ENEMYD2,EBASE+ECNT*28	;DAMAGE FLAG #2
.EQU	ENEMYD3,EBASE+ECNT*29	;DAMAGE FLAG #3
.EQU	ENEMYD4,EBASE+ECNT*30	;DAMAGE FLAG #4
.EQU	ENEMYD5,EBASE+ECNT*31	;DAMAGE FLAG #5


.EQU	ENEMYRSL,EBASE+ECNT*32	;RESUME COMMAND PTR LOW
.EQU	ENEMYRSH,EBASE+ECNT*33	;RESUME COMMAND PTR HIGH. -1 = NO RESUME POINT

.EQU	ENEMYSTAT,EBASE+ECNT*34	;ENEMY CONTROL FLAGS FOR SPECIFIC STATUSES:
				;80H = SET IF ENEMY IS IN SLEEP MODE.  THEN
				;      ENEMYLREG HAS SCREEN COLUMN IT MUST
				;      BE ON IN ORDER TO BE LAUNCHED OR
				;	-2 IF JUST WHEN VISIBLE.
				;40H = REQUEST TO TURN ON SOLID CHECKING
				;20H = ATTACK IS ARMED.
				;10H = ENEMY IS STANDING ON SOLID
				;08H = ENEMY HAS ATTACKED SOMEONE
				;04H = SOLID STATE IS ON.
				;02H = ENEMY MOVED ON X AXIS
				;01H = ENEMY MOVED ON Y AXIS.  WE ONLY BOUNCE
				;      IF WE MOVED, HIT SOLID, AND HAVE 
				;      MOMENTUM.  NO BOUNCE IF WE JUST
				;	PUSHED SOLID (LIKE WITH STANDING).


.EQU	ENEMYXFRICT,EBASE+ECNT*35	;ENEMY X FRICTION OR OFFSET TO USE
					;ON X AXIS WHEN LINKED.
.EQU	ENEMYYFRICT,EBASE+ECNT*36	;ENEMY Y FRICTION OR OFFSET TO USE
					;ON X AXIS WHEN LINKED.

.EQU	ENEMYBOUNCE,EBASE+ECNT*37	;ENEMY BOUNCE FACTOR.

.EQU	ENEMYSD,EBASE+ECNT*38		;SAVED ENEMYDELAY BEFORE EXTERNAL 
					;EVENT THAT CAN BE RESUMED.  

.EQU	ENEMYFCTR,EBASE+ECNT*39		;FRICTION COUNT DOWN.
					;F0 = COUNT SINCE LAST Y MOM APPLIED
					;0F = COUNT SINCE LAST X MOM APPLIED

.EQU	ENEMYID,EBASE+ECNT*40		;ID OF LAST ATTACKER (ENTITYTAB
					;ENTRY NUMBER).  VALID ONLY IF
					;ENEMYATK IS NOT -1.  LOADED WITH
					;-1 FOR USE BY HURTING DISABLED
					;ENTITIES.

.EQU	ENEMYP1,EBASE+ECNT*41		;FIRST BYTE PASSED BY WORLD EVENT.
.EQU	ENEMYP2,EBASE+ECNT*42		;SECOND BYTE PASSED BY WORLD EVENT.


.EQU	ENEMYINTS,EBASE+ECNT*43		;ENEMY INTERRUPTS DISABLE FLAG BIT
					;THE INTERRUPT BITS ARE DOCUMENTED
					;IN THE DISABLE COMMAND IN KUNGTAB
.EQU	ENEMYSINT,EBASE+ECNT*44		;SAVED ENEMY INTERRUPTS FOR RESUME

.EQU	ENEMYNUM,EBASE+ECNT*45		;ENEMY'S NUMBER IN THE PERMANENT MEMORY.

.EQU	ENEMYVCTM,EBASE+ECNT*46		;ENEMY'S LAST VICTIM

.EQU	ENEMYLTST,EBASE+ECNT*47		;LAST COLUMN THAT THE ENEMY TESTED.
.EQU	ENEMYHTST,EBASE+ECNT*48		;AND ALSO A HIGH BYTE FOR 1 WORD.

.EQU	ENEMYFACE,EBASE+ECNT*49		;ENEMY DIRECTION FLAG.  SEE KUNGTAB.


.EQU	ENEMYBEHAVE,EBASE+ECNT*50	;ENEMIES PERSONALITY BITS

;TOP LEGAL USAGE = ECNT*50.  AFTER THAT YOU MUST MOVE THE EBASE EQUATE DOWN.

;***************** USER WRITTEN BOOT CODE ********************
;
USER_BOOT:
	LDA	#0
	STA	BPAUSE		
	STA	ENABLE_SELECT	;DISALLOW THE DEBUG WORLD SELECT FEATURE
	STA	PAUSEFLG	;DISABLE PAUSE
	STA	SCROLLFLG
	STA	SILENCEIT
	STA	SPECGOTO
	STA	CHEATMODE
	STA	STATLEN
	STA	NEEDCOL

	LDA	#CLOCKPHASE
	STA	CLOCKP		;SET USER MODIFIABLE CLOCK PHASE
	STA	TIMETICK	;INITIALIZE THE COUNTER FOR NMI.

	LDA	#-1
	STA	WORLD_REQUEST	;REQUEST WORLD 0
	STA	SAVEDWORLD	;RESET STATREQUEST
	STA	RESETFLG	;SET RESET TRUE
	STA	RNDPTR		;SET RANDOM NUMBER POINTER
	JSR	SEEDRANDOM

	LDA	DEFTOPSTAT
	STA	DATA1
	LDA	DEFTOPSTAT+1
	STA	DATA2
	LDA	DEFTOPSTAT+2
	STA	DATA3
	LDA	DEFTOPSTAT+3
	STA	DATA4	
	JMP	INITSTAT

;***************** USER WRITTEN NON-NMI CODE *****************
;
;WE CHANGE WORLDS, SCROLL, AND MOVE ENTITIES HERE.  THIS ACCOUNTS FOR 
;VIRTUALLY ALL OF THE STATE MACHINE LOGIC.  

USER_MAINLINE:

	LDA	WORLD_REQUEST		;WORLD CHANGE REQUEST?
	BNE	UM10
	JMP	REAL_WORLD		;IF NOT, DO THE WORLD PROCESSING CODE

;WORLD CHANGE REQUEST.  THERE ARE 2 TYPES.  -1 = BOOT SCREEN.
;1-FE MEANS NEW WORLD.  

;FIRST KILL ANY OLD STUFF LYING AROUND.

UM10: 	JSR	CLEAR_BOTH	;CLEAR BOTH SCREEN BUFFERS AND DISABLE NMI

	JSR	INSTAT		;IF STATREQUEST IN PROGRESS, DON'T KILL
	BNE	UM15		;HIDDEN SPRITES

	LDA	SPECGOTO	;SEE IF SPECIAL WORLDGOTO
	BEQ	UM20
	JSR	NONJOYGONE	;ITS WORLDGOTO. REMOVE ALL BUT JOYSTICK ONES
	JMP	UM25

UM15: 	LDA	#-1
	STA	JOYENEMY
	STA	JOYENEMY+1	;FREE UP THE JOYSTICKS IN CASE NOT RETURN
	LDA	SPECGOTO
	BEQ	UM15A		;UNLESS WE ARE RETURNING, DON'T RESTORE STICKS
	LDA	SAVEJOY		;ITS A RETURN FROM A STATUS SCREEN WORLD
	STA	JOYENEMY
	LDA	SAVEJOY+1
	STA	JOYENEMY+1	;RESTORE WHO HAS THE JOYSTICKS

	LDA	SAVESEL
	STA	SELKEY
	LDA	SAVESEL+1	
	STA	SELKEY+1	;RESTORE WHAT SELECT DOES

UM15A:	LDA	#ECNT-1
	STA	SAFEBYTE
UM16: 	LDX	SAFEBYTE
	JSR	HIDDEN		;SEE IF A HIDDEN ENTITY
	BNE	UM17		;IF SO, JUST RESTORE IT
	JSR	ENEMYGONE	;IF NOT, KILL IT
	JMP	UM18

UM17: 	LDA	SPECGOTO
	BEQ	UM18		;DON'T UNHIDE UNLESS RETURN
	LDA	ENEMYJSTAT,X
	EOR	#H'20
	STA	ENEMYJSTAT,X	;IF HIDDEN, JUST LET NMI SHOW IT
UM18:	DEC	SAFEBYTE
	BPL	UM16
	JMP	UM25

UM20: 	JSR	KILLALL		;KILL ALL SPRITES IMMEDIATLY UNLESS STAT WORLD
	JSR	HIDEONLY	;FOR ERROR RECOVERY, ALSO USE FULL ERASE

	LDA	#-1
	STA	JOYENEMY
	STA	JOYENEMY+1	;FREE UP THE JOYSTICKS
	LDX	#0
UM22:	STA	ENEMY0,X	;MARK ALL ENEMIES AS UNUSED
	INX
	CPX	#ECNT
	BNE	UM22

UM25:	LDA	SILENCEIT
	BEQ	UM11
	JSR	ALLSILENCE
	LDA	#0
	STA	SILENCEIT

UM11:	LDA	WORLD_REQUEST				      
	STA	CURWORLD	;SET THIS TO THE CURRENT WORLD
	CMP	#-1		;BUT BOOT SCREEN IS SPECIAL CASE
	BNE	UM100
	LDA	#0
	STA	CURWORLD	;IF BOOT SCREEN, SET TO WORLD 0.

;********************************************************************	
;ITS A WORLD INIT.  THIS ALWAYS WORKS THE SAME EXCEPT IN ONE CASE.  IF
;THE WORLDGOTO COMMAND WAS USED WE NEED TO NOT TAKE OUT JOYSTICK SPRITES AND
;WE NEED TO IGNORE THE NORMAL LEFTMOST SCREEN POSITION INFO.

UM100:	ASL	A
	STA	WORLD_INDX	;SAVE AS USEABLE INDEX

;INITIALIZE THE PALETTES AND CHARACTER SETS

	JSR	INIT_SETS

;PUT UP THE APPROPRIATE BACKGROUND.

	LDA	LEFTCOL+1
	STA	XBACK+1
	LDA	LEFTCOL		;IF SPECIAL GOTO WORLD, THIS IS THE LEFT
	STA	XBACK
	LDA	SPECGOTO
	BNE	UM110

IFDEF( `NOLEFT', `	 	;SEE IF WE HAVE A STARTING X POSITION
	STA	XBACK		;USE ZERO WE MADE ABOVE AND JUST START THERE
	STA	XBACK+1
	', `
	LDX	WORLD_INDX
	LDA	START_BACK,X	;GET THE STARTING OFFSET IN THIS WORLD
	STA	XBACK
	LDA	START_BACK+1,X
	STA	XBACK+1
	' )

UM110:	ASL	XBACK
	ROL	XBACK+1
	ASL	XBACK
	ROL	XBACK+1
	ASL	XBACK
	ROL	XBACK+1		;MAKE STARTING COLUMN INTO PIXEL COLUMN

IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDA	TOPROW
	STA	YBACK
	LDA	SPECGOTO
	BNE	UM112

	LDX	CURWORLD
	LDA	START_TOP,X	;GET THE STARTING OFFSET IN THIS WORLD
	STA	YBACK
UM112:	LDA	#0
	STA	YBACK+1

	ASL	YBACK
	ROL	YBACK+1
	ASL	YBACK
	ROL	YBACK+1
	ASL	YBACK
	ROL	YBACK+1		;MAKE STARTING COLUMN INTO PIXEL COLUMN

	', `
	LDA	#0
	STA	YBACK		;IF NOT BLOCK MODE, JUST ZERO Y SCROLL
	STA	YBACK+1
	')

	LDX	WORLD_INDX
	LDY	USE_BACK+1,X	;GET HIGH BYTE OF WORLD TO USE
	LDA	USE_BACK,X	;GET LOW
	TAX			;PUT WHERE NEEDED
	JSR	INITBACK
	JSR	MAKE_STCOL	;MAKE THE RESULTING BACKGROUND COLUMN

	LDA	SPECGOTO
	BEQ	UM119		;IF NOT SPECIAL GOTO WORLD, NO NEED FOR CHECK
	LDA	LEFTCOL
	SEC
	SBC	STARTCOL
	STA	SUBSVAR1
	LDA	LEFTCOL+1
	SBC	STARTCOL+1	;SEE IF THE LEFTMOST COLUMN WORKED OUT
	BNE	UM111
	LDA	SUBSVAR1
	BNE	UM111

IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDA	TOPROW
	SEC
	SBC	STARTROW
	STA	SUBSVAR2	;MAKE DIFFERENCE ON Y FROM WHAT WE WANTED
	BNE	UM111
	', )

	JMP	UM119	

;THE REQUESTED LEFTMOST COLUMN OR TOPMOST ROW DIDN'T WORK.  IT WAS TOO FAR 
;RIGHT OR TOO FAR DOWN FOR THIS BACKGROUND.  SUBTRACT THE DIFFERENCE 
;FROM THE ENTITIES X AND Y LOCATIONS.

UM111:	LDA	SUBSVAR1
	JSR	TIMES8		;MAKE DISTANCE WE WERE TOO FAR RIGHT
	STA	SUBSVAR1	;SAVE IT HERE

IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET
	LDA	SUBSVAR2
	JSR	TIMES8
	STA	SUBSVAR2 
	', )

	LDX	JOYENEMY
	JSR	ADJUSTX
	LDX	JOYENEMY+1
	JSR	ADJUSTX	
	JSR	MAKE_STCOL	;MAKE THE RESULTING BACKGROUND COLUMN

UM119: 	LDX	WORLD_INDX
	LDA	USE_TABLE,X
	STA	TABLEPTR
	LDA	USE_TABLE+1,X
	STA	TABLEPTR+1	;SET POINTER FOR WORLD TO USE.  POINT TO 0.

;RESET THE STATE MACHINE AND SPECIAL FUNCTION FLAGS.

	LDA	#0
	STA	BPAUSE		;UNPAUSE THE GAME
	STA	GLOBAL_XSCR	
	STA	HALFXLOST
	STA	QUARTERXLOST

IFDEF( `BLOCKMODE', `		
	STA	GLOBAL_YSCR	
	STA	HALFYLOST
	STA	QUARTERYLOST
	', )

	STA	STATLEN
	STA	NEEDCOL
	STA	PHASE4

;DONE.

	LDA	SPECGOTO	;SEE IF POTENTIAL ENDREQUEST WORLD
	BEQ	UM509		

	LDA	#0
	STA	SPECGOTO	;RESET THIS FLAG IF SET

	JSR	INSTAT		;IF ENDREQUEST, THIS IS SET
	BEQ	UM509
	LDA	#-1
	STA	SAVEDWORLD	;RESET IT
	JMP	UM510		;AND DON'T SCAN FLAGS AT THE NEW WORLD

UM509: 	JSR	SCANFLAGS	;SCAN FOR ENEMIES TO LAUNCH

UM510:	LDA	#0
	STA	WORLD_REQUEST	;FREE UP THE WORLD TO START RUNNING

	JSR	RESUME_NMI	;ENABLE NMI SINCE WE STOPPED IT
	RTS

ADJUSTX:			;A DEDICATED SUB FOR SPECGOTO LOGIC.
	CPX	#-1
	BEQ	AX10
	JSR	XINVALID
	BEQ	AX10
	LDA	ENEMYX,X
	SEC
	SBC	SUBSVAR1
	STA	ENEMYX,X

IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET
	LDA	ENEMYY,X
	SEC
	SBC	SUBSVAR2
	STA	ENEMYY,X 
	', )

AX10:	RTS

;THIS SUB WILL TAKE AN X PIXEL LOCATION FOR A SPRITE AND MAKE A COLUMN
;POSITION WITHIN THE BACKGROUND.  IT USES SAFEWORD.  
;X POSITION IN A ON ENTRY, THE RESULT IS IN Y:X ON EXIT.  

FIND_COL:
	CLC
	ADC	XBACK		;ADD LOW PIXELS OF SCROLL
	STA	SAFEWORD
	LDA	XBACK+1
	ADC	#0		;MAKE 2 BYTE LOCATION IN BUFFER
	LSR	A
	ROR	SAFEWORD
	LSR	A
	ROR	SAFEWORD
	LSR	A
	ROR	SAFEWORD	;MAKE COLUMN ON SCREEN

	LDX	SAFEWORD
	TAY
	RTS

;THIS SUB WILL TURN A INTO A PIXEL VALUE FROM A TEXT VALUE (*8)

TIMES8:	ASL	A
	ASL	A
	ASL	A
	RTS

;THESE SUBS WILL DIVIDE A BY 8 AND 16.

DIV16:	LSR	A
DIV8:	LSR	A
	LSR	A
	LSR	A
	RTS

;THIS ROUTINE WILL SELECT THE CHARACTER SETS AND PALETTES FOR THE WORLD
;SPECIFIED IN CURWORLD AND WORLD_INDX

INIT_SETS:
	LDX	CURWORLD
	LDA	USE_BCHRS,X
	PHA
	AND	#1
	ASL	A
	ASL	A
	ASL	A
	ASL	A		;GET UPPER/LOWER SET BIT INTO REG2000 POSITION
	ORA	#8		;AND WE ALWAYS USE UPPER FOR SPRITES
	STA	BACKBITS
	PLA	
	ROL	A
	ROL	A
	ROL	A		;MOVE SET # UP INTO VIDEO SET NIBBLE
	AND	#H'F0		;KEEP ONLY VIDEO BITS
	PHA
	JSR	MAKEBANK	;MAKE THE BANK AND INDEX TO USE
	STA	BACKBANK	;SET THE BANK TO USE
	STX	BACKINDX
	PLA			;GET BACK THE BANK
	ORA	#1		;MAKE ROM PAGE #1 SELECT
	JSR	MAKEBANK
	STA	ALTBANK
	STX	ALTINDX

	JSR	WORLD_BPAL

;THIS SUB WILL ACTIVATE THE WORLD'S SPRITE PALETTE

WORLD_SPAL:
	LDX	WORLD_INDX
	LDY	USE_SPAL+1,X
	LDA	USE_SPAL,X
	TAX			;POINT TO THE SPRITE PALETTE TO USE
	JSR	SPRITEPAL
	RTS

;THIS SUB WILL ACTIVATE THE WORLD'S BACKGROUND PALETTE

WORLD_BPAL:
	LDX	WORLD_INDX
	LDY	USE_BPAL+1,X
	LDA	USE_BPAL,X
	TAX			;POINT TO THE BACKGROUND PALETTE TO USE
	JSR	BACKPAL
	RTS

;THIS ROUTINE WILL DISABLE NMI AND VIDEO AND CLEAR BOTH SCREEN PAGES'S
;BY FILLING WITH ERASECHAR.  IT DOESNT CHANGE THE PALETTE BYTES IN THE SCREEN
;BUFFER.

;ON RETURN, VIDEO AND NMI ARE STILL DISABLED.

CLEAR_BOTH:
	JSR	ALLOW_WRITES	;DISABLE NMI AS SPECIFIED BY BACKPAL

	LDY	#H'20		;ADDRESS Y

	JSR	FSTR10		;SHARE THE CODE

	LDY	#H'24

FSTR10:
	LDX	#0

	LDA	H'2002
	STY	H'2006
	STX	H'2006		;ADDRESS AS REQUESTED.

	LDX	#240		
	LDA	#ERASECHAR

FOURSTORE:
	STA	H'2007
	STA	H'2007
	STA	H'2007
	STA	H'2007
	DEX
	BNE	FOURSTORE
	RTS

;********* IN A REAL WORLD.  KEEP ALL ENTITIES MOVING. *******
;WE WAIT FOR THE FLAG "PHASE4" TO BECOME TRUE INDICATING WE NEED
;TO MOVE THE ENTITIES.  THIS GIVES US A STEADY FREQUENCY OF MOVEMENT.

REAL_WORLD:

 	LDA	BPAUSE
	BNE	RWL0
	LDA	PHASE4
	AND	#1
	BNE	RWL10
RWL0:	RTS

;ITS ANOTHER CLOCK PHASE.  WE HAVE TO ROTATE THE SPRITES NOW IF WE WANT
;TO DO THAT BECAUSE BOTH THE LOW LEVEL AND THE HIGH ARE NOT DISTURBING
;THEM RIGHT NOW AND WE HAVE OUR CHANCE.

RWL10:	JSR	ROTATE

	DEC	PHASE4		;ALLOW LOW LEVEL BACK IN

;MAKE THE BACKGROUND SCROLL ADJUSTMENT

	JSR	CHECKSCROLL	;MAKE GLOBAL_XSCR FOR ENTITIES

IFDEF( `BLOCKMODE', `
	JSR	CHECKYSCROLL	;MAKE GLOBAL_YSCR FOR ENTITIES
	', )

;APPLY IT TO THE BACKGROUND.  

	JSR	APPLYSCROLL

;APPLY IT TO THE ENEMIES

	JSR	APPLYENEMIES

	LDA	GLOBAL_XSCR
	BEQ	ASX10
	JSR	SCRLX
ASX10:

IFDEF( `BLOCKMODE', `		
	LDA	GLOBAL_YSCR
	BEQ	ASX20
	JSR	SCRLY
ASX20:
	', )

;MOVE THE ENTITIES TO THEIR CURRENT LOCATION

	JSR	PUTENEMIES

;SEE IF WE NEED TO TEST A NEW WORLD COLUMN ON THE RIGHT OR LEFT

	LDA	NEEDCOL		;SEE IF WE NOW NEED A SCREEN FLAGS TEST
	BEQ	RWL150
	LDA	NMICOL
	STA	TESTCOL
	LDA	NMICOL+1
	STA	TESTCOL+1
	JSR	SCREENFLAGS	;NOW WE CAN CHECK THE COLUMN WE NEEDED
	LDA	#0
	STA	NEEDCOL

;MOVE ENTITIES.

RWL150:	LDA	#0
	STA	SAFEBYTE	;SET ENEMY TO MOVE TO 0
RWL200:	JSR	MOVEENEMY	;MOVE THIS ONE
	LDA	WORLD_REQUEST	;SEE IF THIS ENTITY WANTED A NEW WORLD
	BNE	RWL300		;IF SO, END THE LOOP
	LDA	PHASE4		;SEE IF WE GOT BEHIND
	BEQ	RWL201
	ORA	#H'80
	STA	PHASE4		;IF SO, SET FLAG TO NOT EXECUTE LOW PRIORITYS
RWL201:	INC	SAFEBYTE	;GO TO NEXT
	LDA	SAFEBYTE
	CMP	#ECNT
	BCC	RWL200		;MOVE ALL OF THEM

	LDA	PHASE4		;SEE IF WE GOT BEHIND
	AND	#H'7F
	BNE	RWL300
	STA	PHASE4		;RESET GOT BEHIND BIT

RWL300:	RTS

;MOVE ALL ENTITIES TO THEIR CURRENT LOCATION.   

PUTENEMIES:
	LDX	#0
PUE120:	LDA	ENEMY0,X	
	CMP	#-1		;INVALID?
	BEQ	PUE121
	LDA	ENEMYSTAT,X
	BMI	PUE121		;IF SLEEPING, DON'T TRY TO DO A PUT.
	LDA	ENEMYJSTAT,X	;SEE IF HIDDEN FROM SOME WORLD
	AND	#H'20
	BNE	PUE121
	STX	SAFEBYTE	;SAVE IT FOR RESTORE
	LDA	ENEMYY,X	;GET ENEMIES Y LOCATION
	TAY
	LDA	ENEMYX,X
	TAX
	LDA	SAFEBYTE	;GET SLOT NUMBER IN A
	JSR	PUTSPRT		;PUT IT DOWN.
	LDX	SAFEBYTE
PUE121:	INX			;GO TO NEXT
	CPX	#ECNT
	BNE	PUE120		;MOVE ALL OF THEM
	RTS

;THIS ROUTINE WILL APPLY GLOBAL_XSCR AND _YSCR TO THE ENEMIES.

APPLYENEMIES:
	LDX	#0
	LDA	GLOBAL_XSCR

IFDEF( `BLOCKMODE', `
	ORA	GLOBAL_YSCR
	', )

	BEQ	RWL110
RWL100:	TXA
	PHA
	JSR	SCROLLENEMY	;MOVE THIS ONE SCROLL WISE
	PLA
	TAX
	INX			;GO TO NEXT
	CPX	#ECNT
	BNE	RWL100		;MOVE ALL OF THEM
	
RWL110:	RTS

;THIS ROUTINE WILL APPLY GLOBAL_XSCR AND _YSCR TO THE BACKGROUND.
;IT DOES NOT CALL SCRLX OR SCRLY, THESE ARE CALLED FROM THE INTERRUPT
;ROUTINE AT THE BEST POSSIBLE TIME FOR VISUAL PURPOSES.

APPLYSCROLL:
	LDA	GLOBAL_XSCR	;GET RESULT
IFDEF( `BLOCKMODE', `
	ORA	GLOBAL_YSCR
	', )
	BNE	RX14
	JMP	RX50
RX14:	LDA	#0
	STA	SUBSVAR2	;ZERO HIGH BYTE FOR + SCROLL

	LDA	GLOBAL_XSCR	

IFDEF( `BLOCKMODE', `
	BEQ	YX10		;IF WE HAVE Y SCROLL, WAS X CHANGED?
	', )

	JSR	NEGATE		;SCREEN SCROLL IS OPPOSITE OF ENTITY!
	STA	SUBSVAR1
	BPL	RX15
	LDA	#-1
	STA	SUBSVAR2	;MAKE FULL NEGATIVE RESULT
	
RX15:	CLC
	LDA	XBACK
	ADC	SUBSVAR1
	STA	XBACK
	LDA	XBACK+1
	ADC	SUBSVAR2
	STA	XBACK+1		;UPDATE SCREEN SCROLL

RX16:	LDA	STARTCOL	;SAVE CURRENT STARTING COLUMN
	STA	SUBSVAR1
	LDA	STARTCOL+1
	STA	SUBSVAR2
 	JSR	MAKE_STCOL	;MAKE THE RESULTING BACKGROUND COLUMN
	LDA	STARTCOL
	SEC
	SBC	SUBSVAR1
	STA	SUBSVAR1	;SAVE LOW BYTE OF RESULT
	LDA	STARTCOL+1
	SBC	SUBSVAR2	;DO A WORD COMPARE TO SEE IF NEW COLUMN
	BCC	RX30		;SKIP IF SMALLER (SCROLLED LEFT)
	BNE	RX20
	LDA	SUBSVAR1	;IF EQUAL, SEE IF WHOLE WORD EQUAL
	BEQ	RX45

RX20:	LDA	STARTCOL
	CLC
	ADC	#31		;TEST THE LAST COLUMN IF WE SCROLLED RIGHT
	STA	NMICOL
	LDA	STARTCOL+1
	ADC	#0
	STA	NMICOL+1
	JMP	RX40

RX30:	LDA	STARTCOL
	STA	NMICOL
	LDA	STARTCOL+1
	STA	NMICOL+1
RX40: 	LDA	#-1
	STA	NEEDCOL		;SO JUST SET A FLAG TO DO IT AFTERWARDS.
RX45:

IFDEF( `BLOCKMODE', `
     	
YX10:	LDA	#0
	STA	SUBSVAR2	;ZERO HIGH BYTE FOR + SCROLL
	LDA	GLOBAL_YSCR	;IF WE HAVE Y SCROLL, WAS Y CHANGED?
	BEQ	RX50
	JSR	NEGATE		;SCREEN SCROLL IS OPPOSITE OF ENTITY!
	STA	SUBSVAR1
	BPL	YX15
	LDA	#-1
	STA	SUBSVAR2	;MAKE FULL NEGATIVE RESULT
	LDA	YBACK+1		;IF GOING NEGATIVE, IS TOP BYTE 0?
	BNE	YX15
	LDA	YBACK		;IF SO, MAKE SURE NOT GOING BELOW 0
	CMP	GLOBAL_YSCR
	BCS	YX15		;IF YBACK IS BIGGER, ITS OK
	LDA	YBACK
	STA	GLOBAL_YSCR	;SET TO MAX ALLOWED.
	LDA	#0
	STA	YBACK		;OTHERWISE, WE ONLY GO TO ZERO
	JMP	YX16
	
YX15: 	CLC
	LDA	YBACK
	ADC	SUBSVAR1
	STA	YBACK
	LDA	YBACK+1
	ADC	SUBSVAR2
	STA	YBACK+1		;UPDATE SCREEN SCROLL

YX16:  	JSR	MAKE_STCOL	;MAKE THE RESULTING BACKGROUND COLUMN AND ROW
	', )

RX50:	RTS

;***************** WORLD COLUMN COMMAND TESTING LOGIC ****************
;
;THE WORLD COLUMN COMMANDS ARE TESTED WHEN A NEW SCREEN COLUMN COMES
;ONTO THE SCREEN OR WHEN AN ENTITY DESIGNATED TO TEST SCREEN
;COMMANDS MOVES ONTO A NEW COLUMN OR ROW.  ALSO, WHEN AN ENTITY
;PUSHES THE UP OR DOWN KEY ON A COLUMN IT WILL BE TESTED AGAIN.
;********************************************************************

;THIS ROUTINE WILL SCAN ALL COMMANDS PRESENTLY ON SCREEN AND LOOK FOR
;LAUNCH ENEMY COMMANDS.  IT CHANGES SAFEBYTE!

SCANFLAGS:
	LDA	#0
SCF10: 	PHA			;SAVE THE ONE WE ARE TESTING
	CLC
	ADC	STARTCOL
	STA	TESTCOL
	LDA	STARTCOL+1
	ADC	#0
	STA	TESTCOL+1
	JSR	SCREENFLAGS	;DO THIS FLAG
	PLA
	TAX			;GET BACK INDEX
	INX			;GO TO NEXT SCREEN COLUMN
	TXA
	CMP	#32		;DONE WITH 32 OF THEM?
	BNE	SCF10
	RTS	

;THIS ROUTINE TESTS FOR ENTITY LAUNCH COMMANDS WHEN A COLUMN ON
;SCREEN IS SCROLLED ONTO.  TESTCOL SHOULD HAVE THE SCREEN COLUMN YOU WANT TO
;TEST.    IT CHANGES SAFEBYTE!

SCREENFLAGS:
	LDA	TESTCOL
	STA	WORLDCOL
	LDA	TESTCOL+1
	STA	WORLDCOL+1	;SAVE COLUMN
	JSR	SEEKCMD
	CMP	#H'F0		;LAUNCH ENTITY?
	BNE	SFG20
	JSR	BF20
SFG20:	RTS

BF20: 	JSR	NOTLAUNCHED	;LAUNCH ENTITY MAKE SURE NOT ALREADY GOING
	JSR	FINDFREE 	;TRY TO FIND ONE
	BNE	SFG20		;DONE IF NONE.
	
;AN ENEMY SLOT IS AVAILABLE.  INITIALIZE ALL OF ITS FLAGS.

BF2010: STX	SAFEBYTE	;SAVE ENEMY INDEX HERE FOR LATER USE
	LDA	WORLDCOL
	STA	ENEMYLCOL,X	;SET THE ORIGIN OF THIS LAUNCH 
	LDA	WORLDCOL+1
	STA	ENEMYHCOL,X

;MAKE THE BACKGROUND LOCATION TO LAUNCH FROM

	LDA	WORLDCOL
	STA	SAFEWORD
	LDA	WORLDCOL+1
	STA	SAFEWORD+1
	LDY	BYTE2
 
	JSR	VISUAL_POINT	;MAKE LOCATION TO LAUNCH FROM
	BCC	BF2012		;SKIP IF LOCATION FULLY ON SCREEN
       	LDA	BYTE4		;IF NOT FULLY ON, IS IT A SLEEPER?
	CMP	#-1
	BNE	BF2012		;IF IT IS, THAT WILL MAKE IT WAIT
	LDA	#-2		;SET IT TO SLEEP TILL ITS VISIBLE
	STA	BYTE4

BF2012:	TXA
	LDX	SAFEBYTE	;GET BACK INDEX
	STA	ENEMYX,X	;SET COLUMN OF LAUNCH
	TYA			;GET ROW TO USE
	STA	ENEMYY,X
	LDA	BYTE3
	STA	ENEMYP2,X	;SET PARAMETER 2 FOR TESTING

	LDY	#0		;ASSUME NOT SLEEPING
	LDA	BYTE2
	STA	ENEMYHREG,X	;SAVE Y TOO IN CASE WE HAVE TO SLEEP
	LDA	BYTE4
	STA	ENEMYLREG,X	;AND PUT HERE FOR SLEEPERS

	CMP	#-1		;SEE IF ITS NOT A SLEEPER
	BEQ	BF2011
	LDY	#H'80
BF2011:	TYA
	STA	ENEMYSTAT,X	;SET SLEEPING FLAG

	LDA	BYTE5
	STA	ENEMYNUM,X	;SET THE PERMANENT MEMORY VALUE

;SET DEFAULTS AND INITIALIZE THE STRUCTURE.  ENEMY0 IS NOT SET UNTIL THE
;LAST MOMENT WHEN EVERYTHING ELSE IS VALID SO THAT WE DON'T GET INTO
;TROUBLE AT THE NMI LEVEL.  PUT THE DESIRED ENEMY0 VALUE INTO BYTE1
;VARIABLE.

FINISH_ENEMY:			;THIS ENTRY SHARED BY THE ENTITY COMMAND 1F.
	LDX	SAFEBYTE	;OTHER USERS MUST SET UP SAME STUFF AS BF20

	LDA	ENEMYNUM,X	;SEE IF PERMANENT MEMORY REQUEST
	CMP	#-1
	BEQ	BF2013
	JSR	MAKELIFE	;MAKE THE INDEX TO PERMENENT MEMORY
	LDX	SAFEBYTE
	AND	REMEMBER,Y	;SEE IF ITS STILL ALIVE
	BEQ	BF2013
	JMP	BF2016		;IF NOT, DON'T LAUNCH IT
BF2013:	LDA	#0		
	STA	ENEMYREQ,X	
	STA	ENEMYFCTR,X
	STA	ENEMYXMOM,X
	STA	ENEMYYMOM,X
	STA	ENEMYDELAY,X	
	STA	ENEMYCENTR,X	;ZERO THIS TO STOP CENTER CORRECTION
	STA	ENEMYHIGH,X	;MUST ZERO HEIGHT TO STOP Y ADJUSTMENT
	STA	ENEMYTLLOW,X
	STA	ENEMYTLHI,X	
	STA	ENEMYTRACK,X	
	STA	ENEMYTLLOW,X
	STA	ENEMYTLHI,X
	STA	ENEMYTRLOW,X
	STA	ENEMYTRHI,X
	STA	ENEMYCNT,X
	STA	ENEMYALT,X
	STA	ENEMYBEHAVE,X

	LDA	#-1
	STA	ENEMYINTS,X	;START WITH ALL INTERRUPTS DISABLED
	STA	ENEMYATK,X	;SET NO LAST ATTACKER
	STA	ENEMYRSH,X	;SET NO RESUME POINT
	STA	ENEMYLROW,X	;SET ROW TO FORCE COMMAND TEST
	STA	ENEMYLINK,X
	STA	ENEMYID,X	;PRESET THIS FOR HURTING DISABLED ENTITIES

	LDA	#H'80
	STA	ENEMYJSTAT,X	;INITIALIZE SECONDARY STATUS BITS

 	LDA	#TRAVELING|DOWN
	STA	ENEMYFACE,X	;SET DIRECTION IT FACES

	LDA	#DEF_GRAV
	STA	ENEMYGRAV,X	;SET INITIAL GRAVITY

	LDA	#DEF_XLIM
	STA	ENEMYXLIM,X
	LDA	#DEF_YLIM
	STA	ENEMYYLIM,X	;SET MOMENTUM LIMITS

	LDA	#DEF_XFRICT
	STA	ENEMYXFRICT,X
	LDA	#DEF_YFRICT	;SET FRICTIONS
	STA	ENEMYYFRICT,X

	LDA	#DEF_BOUNCE
	STA	ENEMYBOUNCE,X	;SET BOUNCE

	LDA	BYTE1		;GET ENEMY NUMBER
	JSR	POINTE2		;CALL POINTENEMY

	LDY	#2
	LDA	(SUBSVAR1),Y
	STA	ENEMYFLGS,X 	;GET FLAGS VALUES
	INY
	LDA	#4
	ORA	ENEMYSTAT,X
	STA	ENEMYSTAT,X	;ASSUME SOLID IS GOING TO BE ON
	LDA	(SUBSVAR1),Y
	STA	ENEMYSOLID,X	;GET SOLID VALUE
	BNE	BF2015
	LDA	ENEMYSTAT,X
	EOR	#4		;IF NO SOLID, RESET BIT
	STA	ENEMYSTAT,X       	

BF2015:	INY
	LDA	(SUBSVAR1),Y	;GET CONTROL BITS
	STA	ENEMYCTRL,X

	INY
	LDA	(SUBSVAR1),Y
	STA	ENEMYHEALTH,X	;AND HEALTH.  PRIZE WE'LL LEAVE FOR DEATH.

;ALL SET UP TO LAUNCH THIS ONE.  MAKE SURE ITS NOT ASLEEP.

	LDA	ENEMYSTAT,X
	BMI	BF2017

INIT_ENEMY:			;NEEDS BYTE1=ENEMY0 VALUE!
	JSR	PICKMOD4	;CALL OUR OWN ROUTINE TO INIT EWAKE MODE
	BEQ	BF2017
BF2016:	LDX	SAFEBYTE
	LDA	#-1
	STA	ENEMY0,X	;IF CAN'T INIT IT, GET RID OF IT.
	RTS
BF2017:	LDA	BYTE1		;GET ENEMY TYPE
	STA	ENEMY0,X	;SET THAT
	RTS			

;THIS SUB WILL MAKE SURE THE ENEMY THAT WOULD BE LAUNCHED BY WORLDCOL
;IS NOT ALREADY ACTIVE.  IT CHECKS ENEMY COLUMN TO SEE IF THERE IS A MATCH.
;IF THERE IS, IT POPS THE RETURN ADDRESS ON THE STACK AND RETURNS.

NOTLAUNCHED:
	JSR	FINDWCOL
	BNE	NLH20
	LDA	ENEMYJSTAT,Y
	AND	#H'20		;MAKE SURE NOT HIDDEN FOR STATREQUEST
	BNE	NLH20
	PLA
	PLA
NLH20:	RTS

;THIS SUBROUTINE WILL RETURN THE INDEX OF AN ENTITY SPECIFIED BY LAUNCHING
;WORLD COLUMN IN WORLDCOL.  IN RETURN, IF Z THEN Y=INDEX.  IF NZ THEN
;THAT ENTITY IS NOT LAUNCHED.

FINDWCOL:
	LDY	#ECNT-1
FNDWC0:	JSR	VALID		;MAKE SURE ITS VALID
	BEQ	FNDWC5
	LDA	ENEMYLCOL,Y
	CMP	WORLDCOL	;THIS ONE MATCHES?
	BNE	FNDWC5
	LDA	ENEMYHCOL,Y
	CMP	WORLDCOL+1
	BEQ	FNDWC9
FNDWC5:	DEY
	BPL	FNDWC0
	LDA	#-1		;IF WE CAN'T FIND IT, RETURN NZ.
FNDWC9:	RTS

;THIS SUB WILL FIND AN AVAILABLE ENEMY AND RETURN THE INDEX IN X.  IF NONE
;IS AVAILABLE IT RETURNS NZ, ELSE Z.  SAFEBYTE IS NOT USED.  IF IT
;NEEDS TO REMOVE A LOW PRIORITY ENTITY TO FIND A SLOT, IT WILL.

FINDFREE:
	LDY	#-1		;FLAG NO LOW PRIORITY SLOT TO USE
	LDX	#0
FEN10:	LDA	ENEMY0,X
	CMP	#-1
	BEQ	FEN20
	LDA	ENEMYCTRL,X
	AND	#H'10			;IF USED, LOW PRIORITY?
	BEQ	FEN15
      	TXA
	TAY			;SIGNAL WE FOUND A LOW PRIORITY ONE
FEN15:	INX
	CPX	#ECNT
	BNE	FEN10
	TYA
	BMI	FEN16
	PHA
	TAX		;IF WE HAVEN'T ANY, USE THIS LOW PRIORITY ONE.
	JSR	ENEMYG2	
	PLA
	TAX
	JMP	FEN20

FEN16:	RTS		;NONE AVAILABLE (Y-->A=-1)

FEN20:	LDA	#0	;X HAS THE FREE ENEMY.
	RTS

;JUMP HERE TO CHECK FOR A WORLD COMMAND THAT AN ENTITY WOULD CARE ABOUT.
;X AND SAFEBYTE SHOULD HAVE THE ENTITIES INDEX AND ENEMYLTST AND
;ENEMYHTST HIS COLUMN IN THE BACKGROUND.

TESTFLGS:
	LDA	ENEMYLTST,X	;GET COLUMN OF TEST
	STA	TESTCOL
	LDA	ENEMYHTST,X	;GET COLUMN OF TEST
	STA	TESTCOL+1
	JSR	SEEKCMD		;SEEK THE COMMAND.
	BEQ	TF10
 	CMP	#H'F0		;MAKE SURE ITS IN THE RANGE FOR ENTITIES
	BCS	TF10		;ONLY 1-EF ALLOWED.

	LDX	SAFEBYTE	;GET ENTITY THAT CAME ONTO IT
	LDA	ENEMYFEET,X	;GET HIS Y
	CLC
	ADC	YBACK		;ADD BACKGROUND Y
	STA	SAFEWORD
	LDA	YBACK+1
	ADC	#0
	ROR	A
	ROR	SAFEWORD
	ROR	A
	ROR	SAFEWORD
	ROR	A
	ROR	SAFEWORD	;MAKE LAUNCH COLUMN
	LDA	SAFEWORD
	CMP	FLAGBYTE	;IS IT ABOVE THE RANGE?
	BCC	TF10
	SBC	#1		;DECREMENT IT TO CATCH EQUAL CONDITION
	CMP	BYTE1		;OR BELOW IT?
	BCS	TF10		;SKIP IF ITS OUTSIDE THE ROW RANGE

;THE ENTITY HAS STEPPED ONTO A FLAG.  REPORT IT TO HIM UNLESS THERE ARE
;QUALIFYING CONDITIONS FOR A JOYSTICK.

	LDA	#TESTING
	AND	ENEMYINTS,X
	BNE	TF10		;SKIP IF ITS NOT ENABLED
	LDA	ENEMYJSTAT,X	;SEE IF JOYSTICK ATTACHED
	BMI	TF5
	AND	#1		;GET JOYSTICK TO CHECK
	TAY
	LDA	J1FLAGS,Y	;GET CURRENT JOYSTICK STATE
	AND	BYTE5
	EOR	BYTE4		;SEE IF MATCH
	BNE	TF10

TF5:	LDA	BYTE2
	STA	ENEMYP1,X
	LDA	BYTE3
	STA	ENEMYP2,X
	LDA	#ECMD
	STA	ENEMYREQ,X	;REQUEST THE ENEMIES COMMAND SEQUENCE
TF10:	RTS			;AND ITS UP TO HIM

;THIS ROUTINE WILL SEEK IN THE COLUMN COMMAND TABLE FOR THE CURRENT
;WORLD (TABLEPTR) FOR THE COLUMN SPECIFIED IN TESTCOL (WORD). ON RETURN, IF
;Z THEN NO COMMAND WAS FOUND FOR THIS TABLE AND FLAGBYTE HAS BEEN
;SET TO 0.  IF NZ, THEN FLAGBYTE, BYTE1, BYTE2, BYTE3, BYTE4, AND
;BYTE5 HAVE BEEN  LOADED WITH THE 6 BYTES THAT MAKE THIS COMMAND.  
;REGISTER A HAS FLAGBYTE IN IT ON RETURN.

;THIS ROUTINE IS CALLED FROM BOTH NMI AND OUTSIDE NMI (PRIMARILY) INTERRUPTS.
;THIS IS OK BECAUSE THE VARIABLES WHICH ARE CHANGED ARE SAVED BY NMI.

SEEKCMD:
	JSR	SEEKCMD2	;GET THE FLAG BYTE
	BEQ	SEEK10
	LDY	#3
	LDA	(TABLEPTR),Y	;IF WE FOUND ONE, GET THE BYTES
	STA	BYTE1
	INY
	LDA	(TABLEPTR),Y
	STA	BYTE2
	INY
	LDA	(TABLEPTR),Y
	STA	BYTE3
	INY
	LDA	(TABLEPTR),Y
	STA	BYTE4
	INY
	LDA	(TABLEPTR),Y
	STA	BYTE5
	LDA	FLAGBYTE	;RESTORE NZ CONDITION
SEEK10:	RTS


;THIS VERSION OF SEEKCMD DOES NOT CHANGE BYTE1-BYTE5.  IT
;JUST RETURNS THE FLAG BYTE IN A AND IN FLAGBYTE.

SEEKCMD2:
	JSR	TESTSEEK
	BEQ	SEEK100

;NO MATCH.  SEE IF WE SHOULD GO LEFT OR RIGHT.

SEEK20:	BCS	SEEK50

;WE NEED TO MOVE TO A PREVIOUS ENTRY.

SEEK40:	JSR	PREVENTRY
	JSR	TESTSEEK
	BEQ	SEEK100
	BCC	SEEK40	
	JMP	SEEK107		;WHEN THE LESS THAN BECOMES GREATER THAN, END

;WE NEED TO MOVE TO THE NEXT ENTRY.

SEEK50:	JSR	NEXTENTRY
	JSR	TESTSEEK
	BEQ	SEEK100
	BCS	SEEK50 		;WHEN > BECOMES < THEN DONE.
	JMP	SEEK107

;FOUND A MATCH.  MAKE SURE ITS NOT THE SPECIAL CASE OF TABLE ENDS

SEEK100:
	LDY	#2		;POINT TO THE COMMAND BYTE
	LDA	(TABLEPTR),Y
	STA	FLAGBYTE
	BNE	SEEK110

;WE FOUND A MATCH BUT ITS AN END OF TABLE MARKER.

	LDA	TESTCOL			;THERE ARE 2 CASES, 0 AND 255.
	ORA	TESTCOL+1
	BNE	SEEK105
	JSR	NEXTENTRY
	JSR	TESTSEEK	;CHECK NEXT ENTRY IF START OF TABLE.
	BEQ	SEEK100		;IF NEXT IS 0 TOO, WE FOUND IT.
	JMP	SEEK107

SEEK105:	
	JSR	PREVENTRY	;BACK UP 1 IF END OF TABLE

;DONE WITH FAILURE.

SEEK107:
	LDA	#0
	STA	FLAGBYTE
	RTS

;DONE WITH SUCCESS

SEEK110:	
	LDA	FLAGBYTE
	RTS	

PREVENTRY:		;CALL HERE TO BACK TABLEPTR UP 1 ENTRY (8 BYTES)
	LDA	TABLEPTR
	SEC
	SBC	#8
	STA	TABLEPTR
	LDA	TABLEPTR+1
	SBC	#0
	STA	TABLEPTR+1
	RTS

NEXTENTRY:		;CALL HERE TO MOVE TABLEPTR FORWARD 1 ENTRY (8 BYTES)
	LDA	TABLEPTR
	CLC
	ADC	#8
	STA	TABLEPTR
	LDA	TABLEPTR+1
	ADC	#0
	STA	TABLEPTR+1
	RTS

;THIS ROUTINE WILL COMPARE TESTCOL (WORD) TO (TABLEPTR) AND SET
;FLAGS:  Z MEANS SAME
;	 CY OR NC FOR DIFFERENT.  CY IF TESTCOL>(TABLEPTR).
;
;IT HONORS SETTING BIT H'8000 IN THE WORD THERE TO SIGNAL A DOUBLED
;COMMAND.   IT CHANGES FLAGBYTE AND TTT1, TTT2.

TESTSEEK:
     	JSR	TESTSK1		;CHECK FOR THE MATCH
	BEQ	TS5		;IF FOUND, USE IT
	BCC	TS5		;OR IF TESTCOL< THEN NO POSSIBLITY OF DOUBLE 
	PHP			;SAVE CONDITION FLAGS
	LDA	TTT1    	;SEE IF DOUBLE BIT
	BPL	TS4		;IF NOT, JUST RETURN THE FLAG WE HAD
	PLA
	JSR	TESTSK2
	RTS
TS4:  	PLP
TS5:	RTS


TESTSK1:
	LDY	#1		;MAKE AN INDIRECT INDEX
	LDA	(TABLEPTR),Y
	STA	TTT1    	;SET IT FOR DOUBLE BIT CHECK
	AND	#H'7F
	STA	TTT2    	;SET HIGH BYTE WITHOUT BIT H'80
	DEY
	LDA	TESTCOL		;GET COLUMN WE ARE LOOKING FOR
	SEC
	SBC	(TABLEPTR),Y	;SEE IF THIS IS A MATCH
	STA	FLAGBYTE	;SAVE HERE CAUSE WE CHANGE IT LATER.
	LDA	TESTCOL+1
	SBC	TTT2    	;GET THE TOP BYTE WITHOUT BIT H'80
	BNE	TS20
	LDA	FLAGBYTE	;GET BACK LOW AND SET Z FLAG
TS20:	RTS

;THIS IS A COPY OF TESTSEEK THAT INCREMENTS THE WORD FOR CASES WHERE
;THE DOUBLE BIT IS SET.  IT ASSUMES THE FIXED HIGH BYTE IS ALREADY IN
;TTT2    .

TESTSK2:
	LDY	#0		;MAKE AN INDIRECT INDEX
	LDA	(TABLEPTR),Y
	CLC
	ADC	#1
	STA	TTT1    	;MAKE COPY OF THE WORD WITH +1
	LDA	TTT2    
	ADC	#0
	STA	TTT2    	;SET HIGH BYTE WITHOUT BIT H'80

	LDA	TESTCOL		;GET COLUMN WE ARE LOOKING FOR
	SEC
	SBC	TTT1    	;SEE IF THIS IS A MATCH
	STA	FLAGBYTE	;SAVE HERE CAUSE WE CHANGE IT LATER.
	LDA	TESTCOL+1
	SBC	TTT2    	;GET THE TOP BYTE WITHOUT BIT H'80
	BNE	TS30
	LDA	FLAGBYTE	;GET BACK LOW AND SET Z FLAG
TS30:	RTS

;THIS ROUTINE WILL TAKE AN X TEXT POSITION WITHIN THE BACKGROUND IN
;SAFEWORD AND A Y ROW POSITION IN Y AND WILL CONVERT INTO SPRITE 
;COORDINATES WITHIN THE VISUAL SCREEN.  

;ON RETURN, IF THE CARRY IS CLEAR THEN Y=PIXEL ROW AND X=PIXEL COLUMN.
;IF CARRY, THEN THE POSITION WAS OFF SCREEN AND Y AND X ARE UNDEFINED. 

VISUAL_POINT:

	ASL	SAFEWORD
	ROL	SAFEWORD+1
	ASL	SAFEWORD
	ROL	SAFEWORD+1
	ASL	SAFEWORD
	ROL	SAFEWORD+1	;MAKE *8 LOCATION

	SEC
	LDA	SAFEWORD
	SBC	XBACK
	STA	SAFEWORD
	TAX			;KEEP IN CASE X IS VALID.
	LDA	SAFEWORD+1
	SBC	XBACK+1		;MAKE POSITION RELATIVE TO CURRENT SCROLL
	STA	SAFEWORD+1
	BNE	VP20		;IF TOP BYTE NOT 0, ITS NOT GOOD.
	BCS	VP25
	
;THE POINT IS OFF SCREEN.

VP20:	SEC
	RTS

;X IS OK.  NOW MAKE Y.

VP25: 	STY	SAFEWORD

	ASL	SAFEWORD
	ROL	SAFEWORD+1
	ASL	SAFEWORD
	ROL	SAFEWORD+1
	ASL	SAFEWORD
	ROL	SAFEWORD+1	;MAKE *8 LOCATION

	SEC
	LDA	SAFEWORD
	SBC	YBACK
	STA	SAFEWORD
	TAY			;KEEP IN CASE Y IS GOOD
	LDA	SAFEWORD+1
	SBC	YBACK+1		;MAKE POSITION RELATIVE TO CURRENT SCROLL
	STA	SAFEWORD+1
	BNE	VP20		;IF TOP BYTE 0, NO GOOD.
	BCC	VP20		;AND IF ABOVE TOP, NO GOOD
	CPY	#H'F0		;AND IF TOO LOW, NO GOOD
	RTS			;WILL SET CARRY IF TOO LOW

;THIS ROUTINE WILL CALCULATE THE FIRST BACKGROUND COLUMN FULLY DISPLAYED
;ON SCREEN.  IT USES ONLY XBACK AND YBACK AND IS OK TO CALL EVEN IF SCRLX
;OR SCRLY HAVE NOT BEEN CALLED FOR THE NEW VALUE.  THE VALUE IS RETURNED 
;IN STARTCOL AND STARTROW.  IT ONLY
;REPORTS A COLUMN AS THE LEFTMOST COLUMN IF PIXEL 0 OF IT IS ON THE SCREEN.

;THIS ROUTINE SHOULD ONLY BE CALLED FROM USER_NMI EXCEPT WHEN A NEW WORLD
;IS BEING INITIALIZED.

MAKE_STCOL:
	LDA	XBACK
	CLC
	ADC	#7		;MAKE SURE WE ARE ON PIXEL 0 OR LESS
	STA	STARTCOL
	LDA	XBACK+1						    
	ADC	#0
	STA	STARTCOL+1
	LSR	STARTCOL+1
	ROR	STARTCOL
	LSR	STARTCOL+1
	ROR	STARTCOL
	LSR	STARTCOL+1
	ROR	STARTCOL

IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDA	YBACK
	CLC
	ADC	#7		;MAKE SURE WE ARE ON PIXEL 0 OR LESS
	STA	STARTROW
	LDA	YBACK+1						    
	ADC	#0
	LSR	A
	ROR	STARTROW
	LSR	A
	ROR	STARTROW
	LSR	A
	ROR	STARTROW

	', )

	RTS

;********************* ENEMY FUNCTIONS ******************************

;ENEMIES ARE REFFERRED TO BY INDEXES OF 0 TO (ECNT-1)

;THIS SUB WILL GET RID OF THE ENEMY SAFEBYTE (INDEX) AND FREE UP ITS SLOT.

ENEMYGONE:
	LDX	SAFEBYTE
ENEMYG2:   			;CALL HERE WITH X IF SAFEBYTE INVALID
	LDA	#-1
	STA	ENEMY0,X
	TXA
	JMP	KILLSPRT	;GET RID OF IT IF SO

;THIS ROUTINE WILL MAKE ALL NON-JOYSTICK ENTITIES GO AWAY.  IT USES SAFEBYTE!

NONJOYGONE:
	LDY	#0		;START WITH ENEMY 0
NJG11:
	JSR	VALID		;SKIP IF US OR INVALID
	BEQ	NJG20
	LDA	ENEMYJSTAT,Y	;SEE IF THIS ONE HAS A JOYSTICK ATTACHED
	BPL	NJG20		;IF SO, DON'T REMOVE IT
	STY	SAFEBYTE
	JSR	ENEMYGONE
	LDY	SAFEBYTE
NJG20:	
	INY
	CPY	#ECNT
	BNE	NJG11
	RTS	

;THIS ROUTINE WILL SEARCH ACTIVE ENTITIES TO SEE IF ANY ARE MARKED AS
;MUST KILL.  IF SO, IT WILL RETURN NZ.  IF NONE, Z.  

MUSTKILL:
	LDY	#0

MKL10:	JSR	VALID
	BEQ	MLK20
	LDA	ENEMYFLGS,Y
	AND	#4
	BNE	MLK30
MLK20:	INY
	CPY	#ECNT
	BNE	MKL10
	RTS

MLK30: 	LDA	ENEMYSTAT,Y	;MAKE SURE ITS NOT ASLEEP
	BMI	MLK20
	LDA	#-1		;RETURN NZ
	RTS

;THIS ROUTINE WILL MOVE AN ENEMY.  THE ENEMY INDEX SHOULD BE IN SAFEBYTE ON
;ENTRY.  IT WILL BE RETURNED THERE.

MOVEENEMY:
	LDX	SAFEBYTE
	LDA	ENEMY0,X
	CMP	#-1		;INVALID?
	BNE	CE3
CE2:   	RTS

CE3:	JSR	HIDDEN		;HIDDEN?
	BNE	CE2

;SEE IF THE ENEMY IS EXECUTING HALF SPEED

CE5:  	LDA	ENEMYJSTAT,X
	AND	#H'40		;IF HALF SPEED, THIS BIT SET
	BEQ	CE7
	TXA			;STAGGER BY ENEMY NUMBER 
	EOR	ALTPHASE
	AND	#1
	BEQ	CE7		;CATCH EVERY OTHER PHASE

;THIS ENTITY WILL NOT EXECUTE THIS CYCLE HOWEVER WE NEED TO MOVE IT
;IF ITS A LINKED ENTITY.

CE6:	LDA	ENEMYLINK,X	;LINKED ENEMY?
	BMI	CE2
	JSR	PUTLINK		;KEEP IT UP TO DATE IF SO.
	JMP	CE2

;SEE IF WE GOT BEHIND AND WE NEED TO NOT EXECUTE LOW PRIORITY ENTITIES
;EVERY OTHER CYCLE.

CE7:	LDA	PHASE4		;BIT H'80 OR 01 SET MEANS WE GOT BEHIND
	BEQ	CE10
		
	LDA	ENEMYCTRL,X
	AND	#H'20		;LOW EXECUTION PRIORITY?
	BEQ	CE10
 
 	LDA	ENEMYJSTAT,X
	AND	#H'40		;IF HALF SPEED, THIS BIT SET
	BEQ	CE8
	TXA			;STAGGER BY ENEMY NUMBER IF NOT HALF SPEED
	EOR	ALTPHASE
	AND	#2
	BNE	CE6		;CATCH EVERY OTHER 4TH PHASE IF HALF SPEED
	JMP	CE10

CE8:	TXA			;STAGGER BY ENEMY NUMBER IF NOT HALF SPEED
	EOR	ALTPHASE
	AND	#1
	BNE	CE6		;CATCH EVERY OTHER PHASE

;CHECK IF THE ENEMY IS SLEEPING AND WAITING TO MOVE ONTO THE CORRECT
;SCREEN LOCATION.  THIS IS ALSO USED IF THE LOGIC NEEDS TO LAUNCH IT
;BUT ITS POSITION IS STILL OFF THE RIGHT OR LEFT OF THE SCREEN.  WE
;MUST NOT LAUNCH IT UNTIL ITS COLUMN PIXEL 0 IS VISIBLE ON SCREEN.

CE10:	LDA	ENEMYSTAT,X
	BPL	CE15		;BIT H'80 MEANS ASLEEP

	LDA	ENEMYLCOL,X	;GET ORIGIN COLUMN
	STA	SAFEWORD
	LDA	ENEMYHCOL,X
	STA	SAFEWORD+1
	LDA	ENEMYHREG,X
	TAY			;GET Y TO BE USED

	JSR	VISUAL_POINT	;MAKE LOCATION TO LAUNCH FROM
	TXA
	LDX	SAFEBYTE	;GET BACK INDEX
	BCS	CE12		;IF NOT ON SCREEN, DON'T LAUNCH IT
	STA	ENEMYX,X	;SET LAUNCH POINT
	TYA
	STA	ENEMYY,X	;SET Y TOO
	LDA	ENEMYLREG,X	;IF SLEEPING TILL ON SCREEN, SEE IF IT DOESN'T
	CMP	#-2		;CARE WHERE (-2)
	BEQ	CE11
	LDA	ENEMYX,X	;GET BACK CURRENT LOCATION
	JSR	DIV8		;MAKE COLUMN THIS ENTITY IS ON
	CMP	ENEMYLREG,X	;SEE IF TIME TO LAUNCH IT
	BNE	CE12		;IF NOT, WAIT TILL IT IS.
CE11:	LDA	ENEMY0,X
	STA	BYTE1		;SET UP THE NEEDED BYTE 1 
	JSR	INIT_ENEMY	;DO THE INIT WE WAITED FOR
	LDX	SAFEBYTE
	LDA	ENEMYSTAT,X
	AND	#H'7F
	STA	ENEMYSTAT,X
CE12:	RTS

;CHECK IF THE ENEMY HAS AN ATTACK ACTIVE THIS CYCLE.

CE15:	LDA	ENEMYD1,X	;GET FRAME # OF ATTACK
	CMP	#-1		;DISABLED?
	BEQ	CE20
	CMP	#-2		;PERMANENTLY ARMED?
	BEQ	CE35
	LDA	ENEMYSTAT,X	;SEE IF ARMED BEFORE WE GET FRAME TO SAVE PWR
	AND	#H'20
	BEQ	CE20		;IF NOT, NO ATTACK
	LDA	SAFEBYTE
	JSR	GETFRAME	;GET FRAME # OF CURRENT ENEMY ANIMATION
	TXA			;SAVE FRAME # HERE
	LDX	SAFEBYTE
	CMP	ENEMYD1,X	;SEE IF CURRENT IS SAME OR BIGGER 
	BCS	CE30		;IF SO, WE NEED TO CHECK FOR ATTACK ARMED
CE20:	JMP	ME10

CE30:	LDA	ENEMYSTAT,X	
	EOR	#H'20
	STA	ENEMYSTAT,X	;RESET ARMED BIT NOW

CE35:	LDA	ENEMYD2,X	;GET HOTSPOT FLAG
	AND	#H'0F
	ASL	A		;MAKE *2
	STA	SAFEWORD
	LDY	ENEMYTRACK,X	;SEE WHAT DIRECTION ON X AXIS
	BPL	CE40
	LDA	ENEMYCENTR,X
	SEC
	SBC	SAFEWORD	;BACK UP TO LEFT IF FACING LEFT
	BCS	CE50
	LDA	#0		;DON'T ALLOW SCREEN WRAP
	JMP	CE50
CE40:	CLC
	ADC	ENEMYCENTR,X	;MAKE POINT IN SPACE RELATIVE TO CENTER
	BCC	CE50
	LDA	#-1		;DON'T ALLOW SCREEN WRAP
CE50:	STA	SAFEX		;SAVE CENTER OF ATTACK ON X HERE

	LDA	ENEMYD2,X	
	AND	#H'F0	
	LSR	A
	LSR	A		;MAKE *16 INTO *4 Y LOCATION
	CLC
	ADC	ENEMYY,X	;MAKE Y LOCATION OF ATTACK
	STA	SAFEY

	LDA	ENEMYD4,X	;GET ATTACK ZONE FOR X
	AND	#H'0F
	ASL	A
	ASL	A
	STA	SAFEWORD	;SET RADIUS OF ATTACK HERE
	LDA	SAFEX
	CLC
	ADC	SAFEWORD
	BCC	CE55
	LDA	#-1
CE55:	STA	SAFEX2		;SET RIGHTMOST AREA OF ATTACK
	LDA	SAFEX
	SEC
	SBC	SAFEWORD
	BCS	CE60
	LDA	#0
CE60:	STA	SAFEX		;SET LEFTMOST AREA OF ATTACK

	LDA	ENEMYD4,X	;GET ATTACK ZONE FOR Y
	AND	#H'F0
	LSR	A
	LSR	A
	STA	SAFEWORD
	LDA	SAFEY
	CLC
	ADC	SAFEWORD
	STA	SAFEY2		;SET BOTTOMMOST AREA OF ATTACK
	LDA	SAFEY
	SEC
	SBC	SAFEWORD
	BCS	CE65
	LDA	#0
CE65:	STA	SAFEY		;SET TOPMOST AREA OF ATTACK

	LDY	#0		;START ENTITY CHECK WITH #0
CE100:	JSR	VALID2		;MAKE SURE VALID AND NOT US
	BEQ	CE150		

	LDA	ENEMYFLGS,X
	AND	#H'40		;DID WE SPECIFY SPECIFIC TARGETING?
	BEQ	CE105

	LDA	ENEMYTLLOW,Y	;GET THE ENTITIES TARGET LEVEL
	AND	ENEMYTRLOW,X	;SEE IF WE TARGETED HIM
	BNE	CE105

	LDA	ENEMYTLHI,Y
	AND	ENEMYTRHI,X
	BEQ	CE150

CE105:	LDA	ENEMYY,Y 	;GET ENTITY TO CHECK'S TOP EDGE
	CMP	SAFEY		;SEE IF TOP IS ABOVE ATTACK AREA TOP
	BCS	CE110
	LDA	ENEMYFEET,Y	;IF SO, BOTTOM MUST BE BELOW ATTACK TOP
	CMP	SAFEY
	BCS	CE130
	JMP	CE150		;IF Y OUT OF RANGE, END	

CE110:	CMP	SAFEY2		;TOP IS BELOW ATTACK TOP.  
	BCC	CE130  		;SO IT MUST BE ABOVE ATTACK BOTTOM
	BNE	CE150		;OR EQUAL TO IT

CE130:	LDA	ENEMYX,Y	;Y IS IN RANGE.   REPEAT LOGIC FOR SIDES
	CMP	SAFEX		
	BCS	CE135
	CLC
	ADC	ENEMYWIDE,Y	
	BCC	CE132
      	LDA	#-1
CE132:	CMP	SAFEX
	BCS	CE140
	JMP	CE150		

CE135:	CMP	SAFEX2		
	BCC	CE140  		
	BNE	CE150		

;WE DID GET AN ENEMY WITH THE HOTSPOT BUT WAS THE DIRECTION CORRECT?
;WE HAVEN'T IMPLEMENTED THIS YET...

CE140:	
	JSR	REPORT		;REPORT THE HIT
	LDA	ENEMYSTAT,X
	ORA	#8
	STA	ENEMYSTAT,X	;SET FLAG OF WE HAVE ATTACKED SOMEONE
	LDA	ENEMY0,Y	;GET THE ENTITY NUMBER OF THE VICTIM
	STA	ENEMYVCTM,X	;SET WHO WE ATTACKED.
CE150:	INY
	CPY	#ECNT		;DONE WITH CHECK?
	BNE	CE100
	JMP	ME10		;DONE WITH ATTACK REPORTING

;THIS LITTLE SUB WILL REPORT AN ATTACK TO ENTITY Y FROM ENTITY X. 

REPORT:				;SHARED BY CMD36!!!
	LDA	SAFEBYTE
	STA	ENEMYATK,Y	;SET LAST ATTACKER FOR THIS ENEMY
	LDA	ENEMY0,X
	STA	ENEMYID,Y	;SET OUR ENEMY NUMBER FROM ENTITYTAB

	LDA	ENEMYD3,X	;GET OUR DAMAGE SPECS
	STA	ENEMYDAMG,Y	;SAVE IT HERE

;WARNING!!! YOU MUST SET THE ABOVE FLAGS EVEN IF HURTING IS DISABLED
;BECAUSE ENEMYID IS PROMISED TO BE VALID EVEN IF HURTING IS OFF.  ITS
;SET TO -1 AT LAUNCH FOR ENTITIES THAT HAVE ONLY A WAKEUP ENTRY.

	LDA	#HURTING
	AND	ENEMYINTS,Y
	BNE	REP10

	LDA	#EHURT
	STA	ENEMYREQ,Y	;REQUEST THE ENEMIES HURT SEQUENCE
REP10:	RTS

;SET UP THE POINTER USED TO GET THE ENEMY MOVEMENT INFO.

ME10:	JSR	EBACKUP		;GET THIS ENEMIES POINTER
	LDA	CLOCKP		;SET PASS COUNT TO ALLOW COMMANDS BASED ON 
	STA	PASSCNT		;THE CLOCKPHASE
	DEC	PASSCNT

;KEEP THE ENEMIES COUNTER RUNNING

	LDA	ENEMYCNT,X
	BEQ	ME12
	DEC	ENEMYCNT,X

ME12:	LDA	ENEMYALT,X
	BEQ	ME15
	DEC	ENEMYALT,X

;SEE IF AN EXTERNAL EVENT EFFECTED THE ENEMY. ENEMYREQ WILL BE TRUE.
;THE EXTERNAL EVENTS THEMSELVES CHECK IF THEY ARE ENABLED BECAUSE THEY
;KNOW WHAT THEY ARE. SO WE CAN TRUST IT HERE.

ME15:	LDA	ENEMYREQ,X
	BEQ	ME20
	LDA	ENEMYPTR
	STA	ENEMYRSL,X
	LDA	ENEMYPTR+1
	STA	ENEMYRSH,X	;SET RESUME POINTER
	LDA	ENEMYDELAY,X	;GET CURRENT DELAY IN PROGRESS
	STA	ENEMYSD,X	;WE MUST SAVE IT FOR RESUME
	LDA	ENEMYINTS,X
	STA	ENEMYSINT,X	;SAVE INTERRUPT CONDITION
	LDA	#-1
	STA	ENEMYINT,X	;LOCK OUT ANY OTHER INTERRUPTS
	LDA	ENEMYREQ,X
	STA	DATA1		;SET MODE TO REQUEST
	LDA	#0
	STA	ENEMYREQ,X	;RESET COMMAND
	JSR	PICKMOD2	;PICK THAT MODE
	LDA	#0
	STA	ENEMYDELAY,X	;ZERO THE DELAY IF WE HAD ONE

;SEE IF WE ARE PAUSING

ME20:	LDA	ENEMYDELAY,X
	BEQ	ME40
	DEC	ENEMYDELAY,X
	JMP	ME250

;NOT PAUSING.  DO THE TABLE.  THE ACTUAL COMMAND BYTES MIGHT BE IN
;ANOTHER ROM PAGE SO WE FETCH THE BYTES NOW AND INCREMENT THE POINTER
;HERE AND THE ROUTINES THEMSELVES DECIDE WHAT TO DO NEXT.  ITS LEGAL
;FOR THEM TO PUT BACK THE OLD POINTER STILL IN THEIR DATA STRUCTURES
;IF THEY WANT OR THEY CAN CHANGE THE POINTER IN LOW MEMORY WHICH IS
;PICKED UP AND PUT INTO THEIR DATA STRUCTURE ON RETURN.

ME40:  	LDX	#0
	JSR	FILLCBUF	;GET THE DATA FOR THE NEXT COMMAND
	LDX	SAFEBYTE	;RESTORE ENEMY INDEX
	LDA	SUBSVAR1	;GET LENGTH WE LOADED
	CLC
	ADC	ENEMYPTR
	STA	ENEMYPTR	;UPDATE THE POINTER
	BCC	ME42
	INC	ENEMYPTR+1
ME42:	JSR	ME110		;MAKE IT INTO A SUB
	LDX	SAFEBYTE
 	JSR	SETPTR		;GET RESULTING POINTER FOR COMMAND
	LDA	PASSCNT
	BPL	ME105
	DEC	PASSCNT		;IF MINUS BEFORE, COUNT LOOKING FOR IT GOING
	BMI	ME20		;TO PLUS WHICH MEANS WE WERE DONE.
	JMP	ME250

ME105:	DEC	PASSCNT		;TRY TO RUN ANOTHER
	BPL	ME20		;STILL PLUS MEANS OK
	JMP	ME250		;IF NOT, STOP NOW

ME110:	LDY	CMDBUF
	LDA	CMDBASEH,Y
	PHA
	LDA	CMDBASEL,Y
	PHA
	RTS			;JUMP TO THE ROUTINE WITH A RTS

CMDBASEL:
	.DB	(CMD00-1) & H'FF	;FOR FAKING AN RTS.  BUT THE 6502
	.DB	(CMD01-1) & H'FF	;NEEDS IT DECed FOR SOME ODD REASON.
	.DB	(CMD02-1) & H'FF
	.DB	(CMD03-1) & H'FF
	.DB	(CMD04-1) & H'FF
	.DB	(CMD05-1) & H'FF
	.DB	(CMD06-1) & H'FF
	.DB	(CMD07-1) & H'FF
	.DB	(CMD08-1) & H'FF
	.DB	(CMD09-1) & H'FF
	.DB	(CMD0A-1) & H'FF
	.DB	(CMD0B-1) & H'FF
	.DB	(CMD0C-1) & H'FF
	.DB	(CMD0D-1) & H'FF
	.DB	(CMD0E-1) & H'FF
	.DB	(CMD0F-1) & H'FF
	.DB	(CMD10-1) & H'FF
	.DB	(CMD11-1) & H'FF
	.DB	(CMD12-1) & H'FF
	.DB	(CMD13-1) & H'FF
	.DB	(CMD14-1) & H'FF
	.DB	(CMD15-1) & H'FF
	.DB	(CMD16-1) & H'FF
	.DB	(CMD17-1) & H'FF
	.DB	(MAKEDING-1) & H'FF
	.DB	(CMD19-1) & H'FF
	.DB	(CMD1A-1) & H'FF
	.DB	(CMD1B-1) & H'FF
	.DB	(CMD1C-1) & H'FF
	.DB	(CMD1D-1) & H'FF
	.DB	(CMD1E-1) & H'FF
	.DB	(CMD1F-1) & H'FF
	.DB	(CMD20-1) & H'FF
	.DB	(CMD21-1) & H'FF
	.DB	(CMD22-1) & H'FF
	.DB	(CMD23-1) & H'FF
	.DB	(CMD24-1) & H'FF
	.DB	(CMD25-1) & H'FF
	.DB	(CMD26-1) & H'FF
	.DB	(CMD27-1) & H'FF
	.DB	(CMD28-1) & H'FF
	.DB	(CMD29-1) & H'FF
	.DB	(CMD2A-1) & H'FF
	.DB	(CMD2B-1) & H'FF
	.DB	(CMD2C-1) & H'FF
	.DB	(CMD2D-1) & H'FF
	.DB	(CMD2E-1) & H'FF
	.DB	(CMD2F-1) & H'FF
	.DB	(CMD30-1) & H'FF
	.DB	(CMD31-1) & H'FF
	.DB	(CMD32-1) & H'FF
	.DB	(CMD33-1) & H'FF
	.DB	(CMD34-1) & H'FF
	.DB	(CMD35-1) & H'FF
	.DB	(CMD36-1) & H'FF
	.DB	(CMD37-1) & H'FF
	.DB	(CMD38-1) & H'FF
	.DB	(CMD39-1) & H'FF
	.DB	(CMD3A-1) & H'FF
	.DB	(CMD3B-1) & H'FF
	.DB	(CMD3C-1) & H'FF
	.DB	(CMD3D-1) & H'FF
	.DB	(CMD3E-1) & H'FF
	.DB	(CMD3F-1) & H'FF
	.DB	(CMD40-1) & H'FF
	.DB	(CMD41-1) & H'FF
	.DB	(CMD42-1) & H'FF
	.DB	(CMD43-1) & H'FF
	.DB	(CMD44-1) & H'FF
	.DB	(CMD45-1) & H'FF
	.DB	(CMD46-1) & H'FF
	.DB	(CMD47-1) & H'FF
	.DB	(CMD48-1) & H'FF
	.DB	(CMD49-1) & H'FF
	.DB	(CMD4A-1) & H'FF
	.DB	(CMD4B-1) & H'FF
	.DB	(CMD4C-1) & H'FF
	.DB	(CMD4D-1) & H'FF
	.DB	(CMD4E-1) & H'FF
	.DB	(CMD4F-1) & H'FF
	.DB	(CMD50-1) & H'FF
	.DB	(CMD51-1) & H'FF
	.DB	(CMD52-1) & H'FF
	.DB	(CMD53-1) & H'FF
	.DB	(CMD54-1) & H'FF
	.DB	(CMD55-1) & H'FF
	.DB	(CMD56-1) & H'FF
	.DB	(CMD57-1) & H'FF
	.DB	(CMD58-1) & H'FF
	.DB	(CMD59-1) & H'FF
	.DB	(CMD5A-1) & H'FF
	.DB	(CMD5B-1) & H'FF
	.DB	(CMD5C-1) & H'FF
	.DB	(CMD5D-1) & H'FF
	.DB	(CMD5E-1) & H'FF
	.DB	(CMD5F-1) & H'FF
	.DB	(CMD60-1) & H'FF
	.DB	(CMD61-1) & H'FF
	.DB	(CMD62-1) & H'FF
	.DB	(CMD63-1) & H'FF
	.DB	(CMD64-1) & H'FF
	.DB	(CMD65-1) & H'FF
	.DB	(CMD66-1) & H'FF
	.DB	(CMD67-1) & H'FF
	.DB	(CMD68-1) & H'FF
	.DB	(CMD69-1) & H'FF
	.DB	(CMD6A-1) & H'FF
	.DB	(CMD6B-1) & H'FF
	.DB	(CMD6C-1) & H'FF
	.DB	(CMD6D-1) & H'FF
	.DB	(CMD6E-1) & H'FF
	.DB	(CMD6F-1) & H'FF
	.DB	(CMD70-1) & H'FF
	.DB	(CMD71-1) & H'FF
	.DB	(CMD72-1) & H'FF
	.DB	(CMD73-1) & H'FF
	.DB	(CMD74-1) & H'FF
	.DB	(CMD75-1) & H'FF
	.DB	(CMD76-1) & H'FF
	.DB	(CMD77-1) & H'FF
	.DB	(CMD78-1) & H'FF
	.DB	(CMD79-1) & H'FF
	.DB	(CMD7A-1) & H'FF
	.DB	(CMD7B-1) & H'FF
	.DB	(CMD7C-1) & H'FF
	.DB	(CMD7D-1) & H'FF
	.DB	(CMD7E-1) & H'FF
	.DB	(CMD7F-1) & H'FF
	.DB	(CMD80-1) & H'FF
	.DB	(CMD81-1) & H'FF
	.DB	(CMD82-1) & H'FF
	.DB	(CMD83-1) & H'FF
	.DB	(CMD84-1) & H'FF
	.DB	(CMD85-1) & H'FF
	.DB	(CMD86-1) & H'FF
	.DB	(CMD87-1) & H'FF
	.DB	(CMD88-1) & H'FF
	.DB	(CMD89-1) & H'FF
	.DB	(CMD8A-1) & H'FF
	.DB	(CMD8B-1) & H'FF
	.DB	(CMD8C-1) & H'FF
	.DB	(CMD8D-1) & H'FF
	.DB	(CMD8E-1) & H'FF
	.DB	(CMD8F-1) & H'FF
	.DB	(CMD90-1) & H'FF
	.DB	(CMD91-1) & H'FF
	.DB	(CMD92-1) & H'FF
	.DB	(CMD93-1) & H'FF
	.DB	(CMD94-1) & H'FF
	.DB	(CMD95-1) & H'FF
	.DB	(CMD96-1) & H'FF
	.DB	(CMD97-1) & H'FF
	.DB	(CMD98-1) & H'FF
	.DB	(CMD99-1) & H'FF
	.DB	(CMD9A-1) & H'FF
	.DB	(CMD9B-1) & H'FF
	.DB	(CMD9C-1) & H'FF
	.DB	(CMD9D-1) & H'FF
	.DB	(CMD9E-1) & H'FF
	.DB	(CMD9F-1) & H'FF
	.DB	(CMDA0-1) & H'FF
	.DB	(CMDA1-1) & H'FF
	.DB	(CMDA2-1) & H'FF
	.DB	(CMDA3-1) & H'FF
	.DB	(CMDA4-1) & H'FF
	.DB	(CMDA5-1) & H'FF
	.DB	(CMDA6-1) & H'FF
	.DB	(CMDA7-1) & H'FF
	.DB	(CMDA8-1) & H'FF
	.DB	(CMDA9-1) & H'FF

CMDBASEH:
	.DB	(CMD00-1) >> 8
	.DB	(CMD01-1) >> 8
	.DB	(CMD02-1) >> 8
	.DB	(CMD03-1) >> 8
	.DB	(CMD04-1) >> 8
	.DB	(CMD05-1) >> 8
	.DB	(CMD06-1) >> 8
	.DB	(CMD07-1) >> 8
	.DB	(CMD08-1) >> 8
	.DB	(CMD09-1) >> 8
	.DB	(CMD0A-1) >> 8
	.DB	(CMD0B-1) >> 8
	.DB	(CMD0C-1) >> 8
	.DB	(CMD0D-1) >> 8
	.DB	(CMD0E-1) >> 8
	.DB	(CMD0F-1) >> 8
	.DB	(CMD10-1) >> 8
	.DB	(CMD11-1) >> 8
	.DB	(CMD12-1) >> 8
	.DB	(CMD13-1) >> 8
	.DB	(CMD14-1) >> 8
	.DB	(CMD15-1) >> 8
	.DB	(CMD16-1) >> 8
	.DB	(CMD17-1) >> 8
	.DB	(MAKEDING-1) >> 8
	.DB	(CMD19-1) >> 8
	.DB	(CMD1A-1) >> 8
	.DB	(CMD1B-1) >> 8
	.DB	(CMD1C-1) >> 8
	.DB	(CMD1D-1) >> 8
	.DB	(CMD1E-1) >> 8
	.DB	(CMD1F-1) >> 8
	.DB	(CMD20-1) >> 8
	.DB	(CMD21-1) >> 8
	.DB	(CMD22-1) >> 8
	.DB	(CMD23-1) >> 8
	.DB	(CMD24-1) >> 8
	.DB	(CMD25-1) >> 8
	.DB	(CMD26-1) >> 8
	.DB	(CMD27-1) >> 8
	.DB	(CMD28-1) >> 8
	.DB	(CMD29-1) >> 8
	.DB	(CMD2A-1) >> 8
	.DB	(CMD2B-1) >> 8
	.DB	(CMD2C-1) >> 8
	.DB	(CMD2D-1) >> 8
	.DB	(CMD2E-1) >> 8
	.DB	(CMD2F-1) >> 8
	.DB	(CMD30-1) >> 8
	.DB	(CMD31-1) >> 8
	.DB	(CMD32-1) >> 8
	.DB	(CMD33-1) >> 8
	.DB	(CMD34-1) >> 8
	.DB	(CMD35-1) >> 8
	.DB	(CMD36-1) >> 8
	.DB	(CMD37-1) >> 8
	.DB	(CMD38-1) >> 8
	.DB	(CMD39-1) >> 8
	.DB	(CMD3A-1) >> 8
	.DB	(CMD3B-1) >> 8
	.DB	(CMD3C-1) >> 8
	.DB	(CMD3D-1) >> 8
	.DB	(CMD3E-1) >> 8
	.DB	(CMD3F-1) >> 8
	.DB	(CMD40-1) >> 8
	.DB	(CMD41-1) >> 8
	.DB	(CMD42-1) >> 8
	.DB	(CMD43-1) >> 8
	.DB	(CMD44-1) >> 8
	.DB	(CMD45-1) >> 8
	.DB	(CMD46-1) >> 8
	.DB	(CMD47-1) >> 8
	.DB	(CMD48-1) >> 8
	.DB	(CMD49-1) >> 8
	.DB	(CMD4A-1) >> 8
	.DB	(CMD4B-1) >> 8
	.DB	(CMD4C-1) >> 8
	.DB	(CMD4D-1) >> 8
	.DB	(CMD4E-1) >> 8
	.DB	(CMD4F-1) >> 8
	.DB	(CMD50-1) >> 8
	.DB	(CMD51-1) >> 8
	.DB	(CMD52-1) >> 8
	.DB	(CMD53-1) >> 8
	.DB	(CMD54-1) >> 8
	.DB	(CMD55-1) >> 8
	.DB	(CMD56-1) >> 8
	.DB	(CMD57-1) >> 8
	.DB	(CMD58-1) >> 8
	.DB	(CMD59-1) >> 8
	.DB	(CMD5A-1) >> 8
	.DB	(CMD5B-1) >> 8
	.DB	(CMD5C-1) >> 8
	.DB	(CMD5D-1) >> 8
	.DB	(CMD5E-1) >> 8
	.DB	(CMD5F-1) >> 8
	.DB	(CMD60-1) >> 8
	.DB	(CMD61-1) >> 8
	.DB	(CMD62-1) >> 8
	.DB	(CMD63-1) >> 8
	.DB	(CMD64-1) >> 8
	.DB	(CMD65-1) >> 8
	.DB	(CMD66-1) >> 8
	.DB	(CMD67-1) >> 8
	.DB	(CMD68-1) >> 8
	.DB	(CMD69-1) >> 8
	.DB	(CMD6A-1) >> 8
	.DB	(CMD6B-1) >> 8
	.DB	(CMD6C-1) >> 8
	.DB	(CMD6D-1) >> 8
	.DB	(CMD6E-1) >> 8
	.DB	(CMD6F-1) >> 8
	.DB	(CMD70-1) >> 8
	.DB	(CMD71-1) >> 8
	.DB	(CMD72-1) >> 8
	.DB	(CMD73-1) >> 8
	.DB	(CMD74-1) >> 8
	.DB	(CMD75-1) >> 8
	.DB	(CMD76-1) >> 8
	.DB	(CMD77-1) >> 8
	.DB	(CMD78-1) >> 8
	.DB	(CMD79-1) >> 8
	.DB	(CMD7A-1) >> 8
	.DB	(CMD7B-1) >> 8
	.DB	(CMD7C-1) >> 8
	.DB	(CMD7D-1) >> 8
	.DB	(CMD7E-1) >> 8
	.DB	(CMD7F-1) >> 8
	.DB	(CMD80-1) >> 8
	.DB	(CMD81-1) >> 8
	.DB	(CMD82-1) >> 8
	.DB	(CMD83-1) >> 8
	.DB	(CMD84-1) >> 8
	.DB	(CMD85-1) >> 8
	.DB	(CMD86-1) >> 8
	.DB	(CMD87-1) >> 8
	.DB	(CMD88-1) >> 8
	.DB	(CMD89-1) >> 8
	.DB	(CMD8A-1) >> 8
	.DB	(CMD8B-1) >> 8
	.DB	(CMD8C-1) >> 8
	.DB	(CMD8D-1) >> 8
	.DB	(CMD8E-1) >> 8
	.DB	(CMD8F-1) >> 8
	.DB	(CMD90-1) >> 8
	.DB	(CMD91-1) >> 8
	.DB	(CMD92-1) >> 8
	.DB	(CMD93-1) >> 8
	.DB	(CMD94-1) >> 8
	.DB	(CMD95-1) >> 8
	.DB	(CMD96-1) >> 8
	.DB	(CMD97-1) >> 8
	.DB	(CMD98-1) >> 8
	.DB	(CMD99-1) >> 8
	.DB	(CMD9A-1) >> 8
	.DB	(CMD9B-1) >> 8
	.DB	(CMD9C-1) >> 8
	.DB	(CMD9D-1) >> 8
	.DB	(CMD9E-1) >> 8
	.DB	(CMD9F-1) >> 8
	.DB	(CMDA0-1) >> 8
	.DB	(CMDA1-1) >> 8
	.DB	(CMDA2-1) >> 8
	.DB	(CMDA3-1) >> 8
	.DB	(CMDA4-1) >> 8
	.DB	(CMDA5-1) >> 8
	.DB	(CMDA6-1) >> 8
	.DB	(CMDA7-1) >> 8
	.DB	(CMDA8-1) >> 8
	.DB	(CMDA9-1) >> 8

;***************
;HERE ARE THE VARIOUS COMMANDS.  EACH IS ENTERED WITH THE BYTES IT NEEDS
;IN CMDBUF AT DATA1, DATA2, ETC.  X HAS THE ENEMY INDEX.
;***************

;THIS ENTRY POINT IS USED TO ACTIVATE EACH OF THE MODES.  THEY
;ARE NORMALLY ENTERED FROM A COMMAND IN THE COMMAND STREAM WHICH IS
;INDEXED INTO CMDBASE TABLE.  BUT EXTERNAL ROUTINES MAY CALL.  PUT
;THE DESIRED MODE INDEX FROM COMMAND 0 IN KUNGTAB INTO DATA1
;AND CALL. (THE ONLY CURRENT "OUTSIDE" ROUTINES THAT DO THIS 
;AS OF TODAY ARE THE LAUNCH ENEMY COMMAND, BF20 AND COMMAND 63). THIS ROUTINE 
;CORRECTLY RETURNS THE NZ OR Z FLAG AS DESCRIBED BY SETUPANIM.

CMD00:
	LDA	#-1
	STA	ENEMYRSH,X	;RESET RESUME COMMAND WITH MODE CHANGE

PICKMOD2:
	LDA	#0
	STA	SETUPFLG	;ZERO THE SPECIAL SETUP MODE FLAG

PICKMOD3:			;CALL HERE AFTER SETTING SETUPFLG YOURSELF

	LDA	DATA1		;GET DESIRED MODE INDEX
	JSR	SETUPANIM	;SET UP THE ANIMATION AND PARAMS
	RTS

PICKMOD4:			;FOR FINISH_ENEMY SINCE ENEMY0,X INVALID
	LDA	#0
	STA	SETUPFLG	;ZERO THE SPECIAL SETUP MODE FLAG
	LDA	BYTE1
	JSR	POINTE2		;MAKE INITIAL INDEX FOR POINTENEMY
	LDA	#EWAKE		;GET DESIRED MODE INDEX
	PHA			;FAKE IT FOR SETUPA2
	JMP	SETUPA2		;SHARE ENDING FOR SETUPANIM

CMDA3:				;DISTANCE SHARES WITH THIS COMMAND.
CMD01:	JSR	MAKETRACKS	;MOVE EXECUTE POINTER IF TARGET IS IN RANGE 
	LDA	DATA3
	STA	SUBSVAR3
	LDA	DATA4
	STA	SUBSVAR4	;GET Y VALUES TOO AND PASS THESE BYTES
	LDA	SUBSVAR2	;SEE IF SPECIAL CASE OF NONE TO TRACK
	CMP	#-1
	BEQ	CMD019
	
	LDA	SUBSVAR3	;DON'T CARE ABOUT X?
	CMP	#-1
	BEQ	CMD017		;SKIP DIRECTION CHECK AND ALL IF SO

	LDA	SUBSVAR1	;GET X OF TARGET
	CMP	ENEMYCENTR,X	;SEE WHAT DIRECTION HE IS
	BCC	CMD010		;SKIP IF HE'S BEHIND US
	LDY	#0		;SET FLAG OF HE'S IN PLUS DIRECTION 
 	JMP	CMD011

CMD010:	LDY	#H'80		;SET FLAG OF HE'S IN MINUS DIRECTION

CMD011:	TYA			;GET DIRECTION FLAG
	EOR	ENEMYXMOM,X	;MAKE SURE WE ARE FACING THE TARGET
	BPL	CMD016
	LDA	CMDBUF		;SEE IF COMMAND A3
	CMP	#H'A3

	BNE	CMD019		;IT DOESN'T CARE IF WE ARE FACING IT.
;	BEQ	CMD016
;	LDA	ENEMYXMOM,X	;IF ZERO X MOMENTUM, HE'S FACING IT.
;	BNE	CMD019		;IF NOT, TEST FAILS

CMD016:	LDA	SUBSVAR1	;NOW GET BACK TARGET LOCATION
	SEC
	SBC	ENEMYCENTR,X	;MAKE DISTANCE TO TARGET
	CPY	#0		;SEE IF WE NEED TO INVERT SIGN
	BEQ	CMD012
	JSR	NEGATE
CMD012:	CMP	SUBSVAR3	;SEE IF X IN RANGE
	BCS	CMD019		;IF NOT, NO MOVEMENT OF EXECUTION POINTER

CMD017:	LDA	SUBSVAR4	;DON'T CARE ABOUT Y?
	CMP	#-1
	BEQ	CMD018		;IF NOT, WE PASSED THE TEST

	LDA	SUBSVAR2	;GET Y OF TARGET
	CMP	ENEMYFEET,X	;SEE WHAT DIRECTION HE IS
	BCC	CMD013		;SKIP IF HE'S ABOVE US
	LDY	#0		;SET FLAG OF HE'S IN PLUS DIRECTION 
 	JMP	CMD014

CMD013:	LDY	#H'80		;SET FLAG OF HE'S IN MINUS DIRECTION

CMD014:	LDA	SUBSVAR2	;NOW GET BACK TARGET Y LOCATION
	SEC
	SBC	ENEMYFEET,X	;MAKE DISTANCE TO TARGET
	CPY	#0		;SEE IF WE NEED TO INVERT SIGN
	BEQ	CMD015
	JSR	NEGATE
CMD015:	CMP	SUBSVAR4	;SEE IF Y IN RANGE
	BCS	CMD019		;IF NOT, NO MOVEMENT OF EXECUTION POINTER
CMD018:	JMP	MOVEPTR		;YEP, WE NEED TO MOVE IT.
CMD019:	RTS

CMD02:				;MOVE EXECUTE POINTER IF LEDGE
CMD021:	LDA	DATA3
	ASL	A
	ASL	A
	ASL	A		;MAKE INTO PIXELS
	JSR	NEGATE		;ABOVE US
	TAY
	LDX	#0
	JSR	TESTMOVE	;SEE IF WE COULD MOVE THERE
	BNE	MOVEPTR		;IF NOT, WE FOUND A LEDGE
	DEC	DATA3
	BNE	CMD021
	RTS

CMD03:	LDA	DATA3		;MOVE EXECUTE POINTER IF PRECIPICE 
	CLC
	ADC	ENEMYWIDE,X	;ADD 1 BYTE OFFSET TO ENEMIES WIDTH IN PIXELS
	LDY	ENEMYTRACK,X	;SEE IF PLUS OR MINUS DIRECTION
	BPL	CMD035
	JSR	NEGATE		;NEED LEFT MOVEMENT IF MINUS MOMENTUM
CMD035:	TAX			;MOVE OVER 1 WIDTH
	LDY	#2		;MOVE DOWN 2
	JSR	TESTMOVE	;SEE IF WE COULD FALL THERE	
	BEQ	MOVEPTR
	RTS

CMD04:				;MOVE EXECUTE POINTER

;JUMP HERE TO SET ENEMYPTR TO DATA2:DATA1

MOVEPTR:
	LDA	DATA1
	STA	ENEMYPTR
	LDA	DATA2
	STA	ENEMYPTR+1
	RTS

CMD05:	JSR	GETRANDOM	;MOVE EXECUTE POINTER RANDOM NUMBER IS BELOW A VALUE
	LDA	DATA3		;GET A RANDOM NUMBER AND GET NUMBER TO BE <
	CMP	XRANDOM
	BCC	CMD055
	JMP	MOVEPTR
CMD055:	RTS

CMD06:	LDA	DATA1		;MOMENTUM LIMIT OVERRIDE
	CMP	#-1
	BEQ	CMD065
	CMP	#0
	BNE	CMD062
	LDA	ENEMYLREG,X
CMD062:	STA	ENEMYXLIM,X	;SET X LIMIT IF NOT NO CHANGE VALUE
CMD065:	LDA	DATA2
	CMP	#-1
	BEQ	CMD067
	CMP	#0
	BNE	CMD066
	LDA	ENEMYLREG,X
CMD066:	STA	ENEMYYLIM,X	;SET Y LIMIT IF NOT NO CHANGE VALUE
CMD067:	RTS

CMD07:	LDA	DATA1 		;DELAY
	JSR	REGVAL
	STA	ENEMYDELAY,X	
NOCMDS:	LDA	#0		;HERE FOR NO MORE COMMANDS
	STA	PASSCNT
	RTS

REGVAL:	CMP	#0		;CALL HERE TO USE A AS <REGISTER> OR VALUE
	BNE	REGV10		;FIXED VALUE OR <REGISTER> AND INC THE PTR.
	LDA	ENEMYLREG,X	;ONLY GETS LOW BYTE OF <REGISTER>
REGV10:	RTS

SEECMDS:			;THIS WILL ZERO UNLESS FORCED NUMBER
	LDA	PASSCNT
	BPL	NOCMDS
	RTS

CMD08:	JSR	USEMOM 		;ADD TO MOMENTUMS
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD09:	LDA	DATA1		;SPECIFY GRAVITY
	CMP	#-1
	BNE	CMD092
	LDA	#DEF_GRAV
CMD092:	STA	ENEMYGRAV,X
	RTS

CMD0A:	LDA	DATA1		;SET SOLID CONDITION
	JSR	REGVAL		

CMD0A2:	CMP	#OFF
	BEQ	SOLIDOFF	;OFF=TURN IT OFF

	CMP	#ON		;UNCONDITIONAL ON?
	BEQ	SOLIDON		;ON IF SO.

	CMP	#SAFE		;CONDITIONAL ON?
	BNE	CMD0A7		;SKIP IF NOT

TRYON:				;TRIES TO DO CONDITIONAL ON, SETS STATUS
	LDA	ENEMYSTAT,X	;IF CONDITIONAL, ASSUME WE CAN
	AND	#H'BF
	STA	ENEMYSTAT,X	;WE'LL NEED THE FLAG RESET
	JSR	SOLIDON		;IF CONDITIONAL, TRY IT OUT
	LDY	ENEMYY,X
	LDA	ENEMYX,X
	TAX
	LDA	SAFEBYTE
	JSR	TESTPUT		;AND THEN TRY MOVING TO THIS LOCATION
	LDX	SAFEBYTE
	CMP	#0
	BEQ	CMD0A5		;IF SUCCESS, WE'VE SET UP OK
	JSR	SOLIDOFF
	LDA	ENEMYSTAT,X
	ORA	#H'40
	STA	ENEMYSTAT,X	;SET CONDITIONAL BIT ON
CMD0A5:	RTS


CMD0A7:	STA	ENEMYSOLID,X	;IF ANY OTHER VALUE, ITS A CHANGE IN VALUE
	LDA	ENEMYSTAT,X	;GET CURRENT STATE
	AND	#H'40
	BNE	TRYON		;IF CONDITIONAL ON, TRY IT OUT NOW
	LDA	ENEMYSTAT,X
	AND	#4		;SEE IF WAS ON
	BNE	SOLIDON		;IF SO, TURN IT ON AGAIN	

SOLIDOFF:			;TURNS OFF SOLID, RESETS BIT THAT ITS ON
    	LDA	ENEMYSTAT,X
	AND	#H'FB
	STA	ENEMYSTAT,X
	LDX	#0
	JSR	SDN
	RTS

SOLIDON:			;TURN ON SOLID, SET BIT THAT ITS ON.
	LDA	ENEMYSTAT,X
	ORA	#4
	STA	ENEMYSTAT,X
	LDA	ENEMYSOLID,X
	TAX
SDN:	LDA	SAFEBYTE	
	JSR	SOLID		;TURN IT ON.
	LDX	SAFEBYTE	;RESTORE ENEMY INDEX
SDN10:	RTS

CMD0B:	LDA	DATA1		;SPECIFY TARGET LEVEL
	STA	ENEMYTLLOW,X
	LDA	DATA2
	STA	ENEMYTLHI,X	;SET TARGET LEVEL
	RTS

CMD0C:	LDA	DATA1		;SPECIFY TARGET 
	STA	ENEMYTRLOW,X
	LDA	DATA2
	STA	ENEMYTRHI,X	;SET TARGET TO TRACK
	RTS

CMD0D:	LDA	#H'FC		;SPECIFY X TARGET TRACKING
	JMP	CMD0E5

CMD0E:	LDA	#H'CF		;SPECIFY Y TARGET TRACKING
	ASL	DATA1
	ASL	DATA1
	ASL	DATA1
	ASL	DATA1
CMD0E5:	AND	ENEMYTRACK,X
	ORA	DATA1		;SET NEW TARGET BITS INTO LOW NIBBLE
	STA	ENEMYTRACK,X
	RTS

CMD0F:	LDA	DATA1		;REQUEST WORLD
	JSR	REGVAL
CMD0F2:	STA	WORLD_REQUEST
	LDA	#0
	STA	CHEATMODE	;FLAG ITS NOT A CHEAT MODE ENTERED WORLD
CMD0F5:	JMP	NOCMDS

CMD10:	LDA	ENEMYJSTAT,X	;GRAB JOYSTICK
	AND	#H'83
	CMP	DATA1		;SEE IF WE ALREADY HAVE IT
	BEQ	CMD109
	LDA	DATA1
	AND	#H'07
	STA	DATA1
	LDA	ENEMYJSTAT,X
	AND	#H'6C
	ORA	DATA1
	STA	ENEMYJSTAT,X	;SET JOYSTICK WE ARE TO USE
	TAY			;GET IT AS AN INDEX
	LDA	#-1
	STA	SELKEY,Y

	LDA	JOYENEMY,Y	;GET ENEMY IT HAD BEFORE
	PHA
	TXA
	STA	JOYENEMY,Y	;SET US IN CHARGE
	PLA			;GET WHO IT HAD
	TAY
	LDA	#H'80
	ORA	ENEMYJSTAT,Y
	STA	ENEMYJSTAT,Y	;SET THAT OLD ENEMY AS NOT HAVING IT
CMD109:	RTS

CMD11:	JSR	GETJOY		;ADD JOYSTICK X
	LDA	JOYX,Y
	STA	DATA1
	LDA	#0
	STA	DATA2
	STA	JOYX,Y		;AND THEN ZERO IT
CMD115:	JSR	USEMOM4
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD12:	JSR	GETJOY		;ADD JOYSTICK Y
	LDA	JOYY,Y
	STA	DATA2
	LDA	#0
	STA	DATA1
	STA	JOYY,Y		;AND THEN ZERO IT
	JMP	CMD115

CMD13:	JSR	GETJOY	;ZERO JOYSTICK X
	LDA	#0
	STA	JOYX,Y	
	RTS

CMD14:	JSR	GETJOY	;ZERO JOYSTICK Y
	LDA	#0
	STA	JOYY,Y	
	RTS

CMD15:	JSR	GETJOY		;MOVE EXECUTE POINTER IF JOYSTICK BITS ARE SET
	LDA	DATA3
	AND	J1FLAGS,Y	;SEE IF ANY OF THE BITS ARE SET
	BEQ	CMD109
	JMP	MOVEPTR		;IF SO, MOVE EXECUTE POINTER

CMD16:	LDA	DATA1		;ACTIVATE ANIMATION SEQUENCE
	STA	SUBSVAR1
	LDA	DATA2
	STA	SUBSVAR2
	JSR	SETUP2		;SET IT UP
	RTS

;THIS SUB WILL FETCH DATA FROM (ENEMYPTR) FOR LENGTH X INTO CMDBUF
;AND THEN RESTORE ENEMYPTR FROM THE ENTITIES STORAGE AND POINT
;(SUBSVAR1) TO THE DATA FETCHED.  YOU MUST USE SETPTR BEFOREHAND
;AND SET UP (ENEMYPTR) YOURSELF.

FILL_POINT:			
	JSR	FILLCBUF	;GET THE DATA TO SEQUENCE WITH
	LDX	SAFEBYTE
	JSR	EBACKUP
POINT_CMDBUF:			;CALL HERE JUST TO POINT SUBSVAR1 TO CMDBUF
	LDA	#CMDBUF & H'FF
	STA	SUBSVAR1
	LDA	#CMDBUF >> 8
	STA	SUBSVAR2	;POINT TO THE DATA
	RTS

CMD17:	LDA	ENEMYRSH,X	;GET RESUME POINTER HIGH
	CMP	#-1		;NO POINT TO RESUME TO?
	BEQ	CMD175		;IF SO, IGNORE IT
	STA	ENEMYPTR+1
	LDA	ENEMYRSL,X
	STA	ENEMYPTR
	LDA	ENEMYSD,X
	STA	ENEMYDELAY,X	;SET BACK WHATEVER DELAY WE HAD
	LDA	ENEMYSINT,X
	STA	ENEMYINTS,X
	LDA	CLOCKP
	STA	PASSCNT		;ALLOW SOME INSTRUCTIONS TO RUN
CMD175:	RTS

CMD19:	JSR	GETFLAGS	;WAIT FOR ANIMATION TO FREEZE.  
	TAY			;SAVE A COPY
	AND	#H'07		;MAKE SURE ANIMATION
	CMP	#2
	BNE	CMD175		;IF NOT, ACT AS IF FROZEN
	TYA
	AND	#H'40		;GET FREEZE BIT
	BNE	CMD175		;ALLOW CONTINUE IF FROZEN, BACKUP OTHERWISE
	JSR	NOCMDS

EBACKUP: 			;CALL HERE TO DELAY ON THIS COMMAND.
	LDA	ENEMYINL,X
	STA	ENEMYPTR
	LDA	ENEMYINH,X
	STA	ENEMYPTR+1	;ITS NOT FROZEN, BACK UP
	RTS

LOADPTR:			;CALL HERE TO SET Y:A TO THE STORED POINTER
	LDA	ENEMYINH,X	;X MUST HAVE SAFEBYTE
	TAY
	LDA	ENEMYINL,X
	RTS

;THIS ROUTINE WILL RETURN THE ANIMATION'S FLAG BYTE IN A AND KEEP X=SAFEBYTE

GETFLAGS:
	LDA	SAFEBYTE	;WAIT FOR ANIMATION TO FREEZE.  
	JSR	USEDINDX	;MAKE INDEX
	LDA	ANIM_RAM+FB,X	;GET FLAGS
	LDX	SAFEBYTE
	RTS	

CMD1A:	LDA	DATA1		;SET COUNTER.  
	JSR	REGVAL
	STA	ENEMYCNT,X
CMD1A9:	RTS

CMD1B:	LDA	DATA3		;MOVE EXECUTE POINTER IF COUNTER BELOW OR =
	CMP	ENEMYCNT,X	;BELOW OR EQUAL TO THE VALUE?
	BCC	CMD1A9		
	JMP	MOVEPTR

CMD1C:				;SPECIFY FRICTION
	LDA	ENEMYLINK,X	;ILLEGAL IF LINKED
	BPL	CMD1C4
	LDA	DATA1
	CMP	#-1
	BEQ	CMD1C2
	STA	ENEMYXFRICT,X
CMD1C2:	LDA	DATA2
	CMP	#-1
	BEQ	CMD1C4
	STA	ENEMYYFRICT,X
CMD1C4:	RTS

CMD1D:	LDA	DATA1		;GOTO X,Y POSITION
	JSR	REGVAL
	CMP	#-1
	BEQ	CMD1D2
	STA	ENEMYX,X

CMD1D2:	LDA	DATA2
	JSR	REGVAL
	CMP	#-1
	BEQ	CMD1D4
	SEC
	SBC	ENEMYHIGH,X	;CORRECT FOR ENEMIES HEIGHT
	CLC
	ADC	#1
	STA	ENEMYY,X

CMD1D4:	JSR	FINDLOCS
	RTS

CMD1E:	JSR	NOCMDS		;DIE
	LDA	DATA1		;GET FLAG TO KILL OR NOT KILL
	BEQ	CMD1E9		;SKIP IF NO KILL
	LDA	ENEMYNUM,X
	JSR	MAKELIFE
	LDX	SAFEBYTE
	ORA	REMEMBER,Y
	STA	REMEMBER,Y	;SET THE BIT ON TO SIGNAL PERMANENT DEATH
CMD1E9:	JSR	ENEMYGONE		;MAKE IT GO AWAY
CMD1E8:	RTS

;THIS ROUTINE WILL TAKE A PERMANENT MEMORY INDEX IN A AND MAKE A POINTER
;TO THE RAM BYTE IN REMEMBER WITH A BIT MASK IN A.  A WILL HAVE THE 
;APPROPRIATE BIT SET.  ACCESS THE RAM WITH REMEMBER,Y.  X IS CHANGED.
;

MAKELIFE:
	PHA		;SAVE A COPY
	JSR	DIV8	;MAKE THE BYTE LOCATION
	TAY
	PLA
	AND	#7	;GET BIT INDEX
	TAX
	LDA	BITS,X	;GET BIT TO TEST FOR
	RTS

BITS:	.DB	1,2,4,8,H'10,H'20,H'40,H'80

CMD1F: 	JSR	FINDFREE	;LAUNCH ENEMY
	BNE	CMD1E8		;DONE IF NONE AVAILABLE
	TXA
	TAY			;MAKE ENEMY INDEX HERE
	LDX	SAFEBYTE	;GET OUR INDEX FROM HERE
	LDA	DATA1		;GET ENEMY TYPE
	JSR	REGVAL
	STA	BYTE1		;SET ENEMY TYPE FOR FINISH_ENEMY
CMD1F2:	LDA	#-1
	STA	ENEMYLCOL,Y	;SET THAT THIS LAUNCH HAS NO ORIGIN
	STA	ENEMYHCOL,Y

	LDA	#0
	STA	ENEMYSTAT,Y	;SET AS NOT ASLEEP

	LDA	DATA4
	STA	ENEMYP2,Y	;SET PARAMETER 2 FROM OUR COMMAND.
	
	LDA	ENEMYX,X
	CLC
	ADC	DATA2		;MAKE LAUNCH X
	STA	ENEMYX,Y
	LDA	ENEMYY,X
	CLC
	ADC	DATA3
	STA	ENEMYY,Y	;MAKE LAUNCH Y

CMD1F20:
	JSR	SETPTR		;SAVE OUR EXECUTION POINTER

	LDA	SAFEBYTE
	PHA			;SAVE OUR ENEMY INDEX
	STY	SAFEBYTE
	LDA	#-1
	STA	ENEMYNUM,Y	;SET AS NO PERMANENT MEMORY FOR THIS ONE
	JSR	FINISH_ENEMY	;SHARE CODE WITH ENEMY LAUNCH WORLD COMMAND
	PLA
	STA	SAFEBYTE
	TAX
	JSR	EBACKUP		;PUT OUR EXECUTE POINTER BACK AND DONE
	RTS

SETPTR:				;CALL HERE TO TAKE ENEMYPTR AND PUT IT INTO
				;THE ENEMY'S SAVE LOCATION
	LDA	ENEMYPTR
	STA	ENEMYINL,X
	LDA	ENEMYPTR+1
	STA	ENEMYINH,X	;RESTORE POINTER FOR NEXT TIME
SPTR9:	RTS

CMD20:	LDA	ENEMYSTAT,X	;MOVE EXECUTE POINTER IF STANDING
	AND	#H'10	   	;GET STANDING BIT
	BEQ	SPTR9
CMD205:	JMP	MOVEPTR		;MOVE POINTER IF SOLID SET

CMD21:	LDA	ENEMYDAMG,X	;APPLY DAMAGE TO HEALTH
	AND	#H'07		;GET DAMAGE
	STA	SAFEWORD
	EOR	ENEMYDAMG,X
	STA	ENEMYDAMG,X	;PUT BACK ZEROED
	LDA	ENEMYHEALTH,X	;GET CURRENT HEALTH LEVEL
	SEC
	SBC	SAFEWORD
	BCS	CMD215
	LDA	#0		;DON'T GO BELOW ZERO
CMD215:	STA	ENEMYHEALTH,X
	RTS

CMD22:	LDA	DATA3		;MOVE EXECUTE POINTER IF HEALTH LESS OR =
	CMP	ENEMYHEALTH,X	;SEE IF LESS THAN OR EQUAL TO 
	BCS	CMD205
	RTS

CMD23:	LDA	DATA3		;MOVE EXECUTE POINTER IF LAST ATTACKER
	CMP	ENEMYID,X	;SEE IF MATCH
	BEQ	CMD205
	RTS

CMD24:	JSR	GETATTACK	;MOVE EXECUTE POINTER IF ATTACK #
	CMP	DATA3		;SEE IF MATCH
	BEQ	CMD205
	RTS

;THIS SUB WILL RETURN THE ATTACK NUMBER OF THE LAST ATTACK IN A.  IT USES
;SUBSVAR1.
GETATTACK:
	LDA	ENEMYDAMG,X	;MOVE EXECUTE POINTER IF ATTACK #
	PHA
	AND	#H'08		;GET 16-31 ATTACK NUMBER FLAG
	ASL	A		;MAKE INTO 0 OR 16.	
	STA	SUBSVAR1
	PLA
	JSR	DIV16		;MAKE ATTACK NUMBER TO MATCH
	CLC
	ADC	SUBSVAR1
	RTS


CMD25:	LDA	ENEMYXMOM,X	;MOVE EXECUTE POINTER IF MOMENTUM
	BPL	CMD251
	JSR	NEGATE
CMD251:	STA	SAFEX2
	LDA	ENEMYYMOM,X
	BPL	CMD252
	JSR	NEGATE
CMD252:	STA	SAFEY2
	LDA	DATA3		;SEE IF WE CARE ABOUT X
	CMP	#-1
	BEQ	CMD254
	CMP	SAFEX2		;SEE IF ITS LESS THAN OR EQUAL
	BCS	CMD254
CMD253:	RTS
CMD254:	LDA	DATA4		;SEE IF WE CARE ABOUT Y
	CMP	#-1
	BEQ	CMD257
	CMP	SAFEY2		;SEE IF ITS LESS THAN OR EQUAL
	BCC	CMD253
CMD257:	JMP	MOVEPTR

CMD26:	LDA	ENEMYSTAT,X		;REARM ATTACK
	ORA	#H'20		
	STA	ENEMYSTAT,X	
	RTS

CMD27:	LDA	ENEMYSTAT,X	;MOVE EXECUTE POINTER IF YOU HAVE ATTACKED
	AND	#8
	BEQ	CMD253
	EOR	ENEMYSTAT,X
	STA	ENEMYSTAT,X
	JMP	MOVEPTR

CMD28:	LDA	SAFEBYTE	;MOVE EXECUTE POINTER IF >= TO FRAME #
	JSR	GETFRAME	;CHECK FRAME # OF THIS SPRITE
	CPX	DATA3		;SEE IF MATCH OR BIGGER
	BCS	CMD257		;IF SO, MOVE POINTER
	RTS

CMD29:
IFDEF( `XDISPLAY', `		
	LDX	DATA1		;DISPLAY INFRONT/BEHIND
	LDA	SAFEBYTE
	JSR	INFRONT
	RTS
	', )

CMD2A:	LDA	DATA3		;MOVE IF PARAM1
	CMP	ENEMYP1,X	;MATCH?
	BEQ	CMD257
	RTS

CMD2B:	LDA	DATA3		;MOVE IF PARAM2
	CMP	ENEMYP2,X	;MATCH?
	BEQ	CMD257
	RTS

CMD2C:	LDA	DATA1		;SET INSTRUCTIONS TO EXECUTE
	STA	PASSCNT
	RTS

CMD2D:	JSR	USEMOM2		;SET MOMENTUMS
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD2E:	LDA	#-1		;TEST FOR WORLD FLAG COMMANDS
	STA	ENEMYLROW,X	;SET LAST ROW TO 255 TO FORCE TEST
	JMP	NOCMDS		;SET US TO LEAVE.

CMD2F:	LDA	ENEMYINTS,X	;DISABLE INTERRUPTS
	ORA	DATA1
	STA	ENEMYINTS,X
	RTS	

CMD30:	LDA	ENEMYINTS,X	;ENABLE INTERRUPTS
	ORA	DATA1
	EOR	DATA1
	STA	ENEMYINTS,X
	RTS

CMD31:	LDA	#0		;PLAY
	STA	SAFEX		;SET CHANNEL FOR LOOP

CMD315:	LDA	SAFEX
	ASL	A
	TAY
	LDA	DATA1,Y
	STA	SAFEWORD
	LDA	DATA2,Y
	STA	SAFEWORD+1
	JSR	DOCHANNEL	;DO THIS SOUND CHANNEL
	LDA	SAFEX
	CMP	#4
	BNE	CMD315
	RTS

;THIS SUB WILL TAKE SOUND COMMAND WORD FLAG IN SAFEWORD FOR CHANNEL
;IN SAFEX AND ACTIVATE IT.  IT SUPPORTS -1 AND 0.  SAFEX IS INCREMENTED.

DOCHANNEL:
	LDA	SAFEWORD+1
	CMP	#-1		;SEE IF IGNORE IT
	BEQ	CMD319
	LDA	SAFEX
	JSR	SILENCE		;IF 0 OR PLAY, SILENCE THE CHANNEL
CMD316:	LDA	SAFEWORD+1	;SEE IF JUST SILENCE IT
	BEQ	CMD319		
	TAY
	LDA	SAFEWORD
	TAX
	LDA	SAFEX
	JSR	PLAY
CMD319:	INC	SAFEX
	RTS

CMD32:	LDA	DATA1		;SET BOUNCE FACTOR
	STA	ENEMYBOUNCE,X
	RTS

CMD33:	JSR	GETJOY		;SET MOMENTUM TO JOYSTICK X MOMENTUM
	LDA	JOYX,Y
	STA	DATA1
	LDA	#-1	
	STA	DATA2		;SIGNAL NO CHANGE FOR Y
	LDA	#0
	STA	JOYX,Y		;AND THEN ZERO IT
CMD335:	JSR	USEMOM3
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD34:	JSR	GETJOY		;SET MOMENTUM TO JOYSTICK Y MOMENTUM
	LDA	JOYY,Y
	STA	DATA2
	LDA	#-1
	STA	DATA1
	LDA	#0
	STA	JOYY,Y		;AND THEN ZERO IT
	JMP	CMD335

CMD35:	LDA	DATA3		;MOVE EXECUTE POINTER IF ACTIVE
	STA	SAFEX
	LDA	DATA4
	STA	SAFEY
	LDA	DATA5
	STA	SAFEY2
	JSR	WORDREG
CMD351:	JSR	FINDENEMY	;TRY TO FIND THIS ONE
	BNE	CMD359
	LDA	ENEMYSTAT,Y	;BUT SEE IF SLEEPING
	BMI	CMD359
	JMP	MOVEPTR		;MOVE POINTER IF MATCH

;THIS ROUTINE CHECKS SAFEY2:SAFEY AND SEES IF THE FULL WORD IS 0 (<REGISTER>).
;IF SO, THE REGISTER IS PUT THERE INSTEAD.

WORDREG:
	LDA	SAFEY2
	BNE	WRG10
	LDA	SAFEY
	BNE	WRG10
	LDA	ENEMYLREG,X
	STA	SAFEY
	LDA	ENEMYHREG,X
	STA	SAFEY2
WRG10:	RTS

;THIS ROUTINE WILL SEARCH ALL ENTITIES FOR A SPECIFIED ONE.  LOAD
;SAFEX WITH 0 TO SEARCH BY WORLD COLUMN THAT LAUNCHED IT OR LOAD IT
;WITH 1 TO SEARCH BY ENEMY ID.  LOAD SAFEY AND SAFEY2 WITH THE NUMBER TO 
;MATCH. (SAFEY ONLY IF ENEMYID, SAFEY2 NEEDED IF WORLD COLUMN (WORD).
;LOAD SAFEBYTE WITH ANY ENTITY INDEX TO
;BE IGNORED (USUALLY YOUR OWN) OR -1 TO SEARCH ALL OF THEM.  ON RETURN,
;IF Z THEN Y HAS THE ENTITY THAT WAS FOUND (ITS INDEX).  SAFEWORD
;IS NOT CHANGED AND X = SAFEBYTE ON RETURN.

FINDENEMY:
	LDY	#0		;START THE SEARCH WITH #0
CMD355:	JSR	VALID2		;SKIP IF OUR INDEX OR INVALID
	BEQ	FINDNEXT	
	LDX	SAFEX		;SEE IF ID BY WORLD COL
	BNE	CMD356
	LDA	ENEMYHCOL,Y	;IF WORLD COL, NEED WORD CHECK
	CMP	SAFEY2
	BNE	FINDNEXT
	LDA	ENEMYLCOL,Y	;IF MATCH, USE SAME CODE TO CHECK LOW BYTE
CMD356:	CMP	SAFEY		;GOT A MATCH?
	BEQ	CMD359

FINDNEXT:			;ENTER HERE TO CONTINUE FINDENEMY
	INY
	CPY	#ECNT		;CHECK ALL ENTRIES FOR MATCH
	BNE	CMD355
	CPY	#0		;SET NZ IF NONE FOUND
CMD359:	PHP
	LDX	SAFEBYTE
	PLP
	RTS

;THIS SUB WILL CHECK TO SEE IF AN ENEMY SPECIFIED IN INDEX Y IS VALID
;(ENEMY0 <> -1).  ON RETURN, IF Z, ITS INVALID.  CALL VALID2 ENTRY
;POINT TO MAKE SURE ITS NOT THE SAME AS ENEMY IN SAFEBYTE TOO.

;IF YOU CALL VALID ONLY AND IT RETURNS Z, A=-1.

VALID2:
	CPY	SAFEBYTE	;CALL HERE TO RULE OUT MATCHES TO SAFEBYTE
	BEQ	VLD10
VALID:	  			;CALL HERE FOR CHECK WITHOUT SAFEBYTE COMPARE
	LDA	ENEMY0,Y	
	CMP	#-1
VLD10:	RTS

	
CMD36:	LDA	DATA2		;HURT ENTITY
	CMP	#ALL		;HURT ALL?
	BEQ	CMD3610	
	STA	SAFEX		;PUT THESE FOR CALL TO FINDENEMY
	LDA	DATA3
	STA	SAFEY
	LDA	DATA4
	STA	SAFEY2
	BNE	CMD361
       	LDA	SAFEY
	JSR	REGVAL
	STA	SAFEY
CMD361:	JSR	FINDENEMY
	BNE	CMD364		;IF NONE, IGNORE CALL.
CMD362:	LDA	ENEMYD3,X
	PHA			;SAVE OUR DAMAGE FLAG
	LDA	DATA1
	STA	ENEMYD3,X	;FAKE IT FOR A CALL TO REPORT
	JSR	REPORT 		;REPORT DAMAGE TO THAT ENTITY
	PLA
	STA	ENEMYD3,X	;RESTORE OUR DAMAGE FLAGS
	JSR	FINDNEXT	;TRY ANOTHER
	BEQ	CMD362
CMD364:	RTS	


CMD3610:			;ITS HURT ALL
	LDY	#0		;START WITH ENEMY 0
CMD3611:
	JSR	VALID2		;SKIP IF US OR INVALID
	BEQ	CMD3620
	LDA	ENEMYJSTAT,Y	;SEE IF THIS ONE HAS A JOYSTICK ATTACHED
	BPL	CMD3620		;IF SO, DON'T HURT IT
	LDA	ENEMYD3,X
	PHA			;SAVE OUR DAMAGE FLAG
	LDA	DATA1
	STA	ENEMYD3,X	;FAKE IT FOR A CALL TO REPORT
	JSR	REPORT 		;REPORT DAMAGE TO THAT ENTITY
	PLA
	STA	ENEMYD3,X	;RESTORE OUR DAMAGE FLAGS
CMD3620:	
	INY
	CPY	#ECNT
	BNE	CMD3611
	RTS	


CMD37:
IFDEF( `XADDSCORE', `		
	LDA	DATA3		;ADD TO THE SCORE
	STA	SAFEY2
	LDA	DATA2
	STA	SAFEY
	JSR	WORDREG
	JSR	FINDJOY		;FIGURE OUT WHICH JOYSTICK TO USE
	BNE	CMD372		;SKIP IF NONE
	LDA	SCOREL,Y
	CLC
	ADC	SAFEY		;ADD LOW BYTE
	STA	SCOREL,Y
	LDA	SCOREH,Y
	ADC	SAFEY2
	STA	SCOREH,Y
	LDX	SAFEY2		;GET BACK HIGH BYTE
	BMI	CMD375		;SKIP IF NEGATIVE
	BCC	CMD372		;PLUS SCORE MUST NOT HAVE CARRY
	LDA	#-1
CMD371:	STA	SCOREL,Y
	STA	SCOREH,Y
CMD372:	RTS

CMD375:	LDA	#0
	BCC	CMD371		;MINUS SCORE MUST HAVE CARRY
	RTS
	', )

CMD38:
IFDEF( `XSETSCORE', `		
	JSR	FINDJOY		;SET THE SCORE
	BNE	CMD382		;SKIP IF NONE
	LDA	DATA2
	STA	SCOREL,Y
	LDA	DATA3
	STA	SCOREH,Y
CMD382:	RTS
	', )

CMD39: 
IFDEF( `XSCORE', `		
	JSR	FINDJOY		;MOVE EXECUTE POINT IF SCORE
	BNE	CMD399		;SKIP IF NONE
	SEC
	LDA	SCOREL,Y
	SBC	DATA2		;SUBTRACT LOW BYTE
	LDA	SCOREH,Y
	SBC	DATA3		;AND HIGH
	BCC	CMD399		;SKIP IF NOT GREATER OR EQUAL
	LDA	DATA4
	STA	DATA1
	LDA	DATA5
	STA	DATA2
	JMP	MOVEPTR
CMD399:	RTS
	', )

CMD3A:	JSR	FINDJOY		;ADD TO THE HERO COUNT
	BNE	CMD3A2		;SKIP IF NONE
	LDA	DATA2
	JSR	REGVAL
CMD3A7:	CLC
	ADC	HEROCOUNT,Y	;ADD HERO COUNT
	STA	HEROCOUNT,Y
	LDX	DATA2		;GET BACK SIGN OF BYTE
	BMI	CMD3A5		;SKIP IF NEGATIVE
	BCC	CMD3A2		;PLUS SCORE MUST NOT HAVE CARRY
	LDA	#-1
CMD3A1:	STA	HEROCOUNT,Y
CMD3A2:	RTS
CMD3A5:	LDA	#0
	BCC	CMD3A1		;MINUS SCORE MUST HAVE CARRY
	RTS

CMD3B:	JSR	FINDJOY		;SET THE HERO COUNT
	BNE	CMD3B2		;SKIP IF NONE
	LDA	DATA2
	JSR	REGVAL
	STA	HEROCOUNT,Y
CMD3B2:	RTS

CMD3C:	JSR	FINDJOY		;MOVE IF HERO COUNT
	BNE	CMD3C9		;SKIP IF NONE
	LDA	HEROCOUNT,Y	;GET COUNT TO CHECK FOR
	CMP	DATA2		;SEE IF ABOVE OR EQUAL
	BCC	CMD3C9
	LDA	DATA3
	STA	DATA1
	LDA	DATA4
	STA	DATA2
	JMP	MOVEPTR		;IF SO, USE THE POINTER
CMD3C9:	RTS

CMD3D:	LDA	RESETFLG	;MOVE IF RESET FALSE
	LDY	#0
	STY	RESETFLG
	CMP	#0
	BNE	CMD3C9
	JMP	MOVEPTR

CMD3E:				;LOAD REGISTER
CMD3E1:	LDA	DATA1
	STA	ENEMYLREG,X
	LDA	DATA2
	STA	ENEMYHREG,X
	RTS

CMD3F:	JSR	CLEARHIGH	;FETCH REGISTER
	LDY	DATA1		
	LDA	ENEMYP2,X	;ASSUME PARAM2
	CPY	#PARAM2
	BNE	CMD3F3
CMD3F1:	JMP	CMD3F9

CMD3F3:	LDA	ENEMYP1,X	;ASSUME THE LAST WORLD COMMAND
	CPY	#WORLDCMD
	BEQ	CMD3F1	

	JSR	GETATTACK	;MOVE EXECUTE POINTER IF ATTACK #
	CPY	#ATTACK
	BEQ	CMD3F1

	LDA	ENEMYID,X	;GET LAST ATTACKER
	CPY	#ATTACKER	;LAST ATTACKER?
	BEQ	CMD3F1

	LDA	ENEMYVCTM,X	;GET LAST VICTIM
	CPY	#VICTIM		;LAST VICTIM?
	BEQ	CMD3F1

	LDA	CURWORLD	;CURRENT WORLD?
	CPY	#WORLD
	BEQ	CMD3F9

	LDA	ENEMYHEALTH,X	;HEALTH LEVEL?
	CPY	#HEALTH
	BEQ	CMD3F9

	LDA	ENEMY0,X	;ENTITY #?
	CPY	#ENTITY
	BEQ	CMD3F9

	LDA	ENEMYTRACK,X	;DIRECTION FLAG?
	AND	#H'C0
	CPY	#FACE
	BEQ	CMD3F9

	LDA	ENEMYCENTR,X	;X LOCATION?
	CPY	#XVISUAL
	BEQ	CMD3F9

	LDA	ENEMYFEET,X	;Y LOCATION?
	CPY	#YVISUAL
	BEQ	CMD3F9

	LDA	ENEMYBEHAVE,X	;ENEMY BEHAVIOR BITS?
	CPY	#BEHAVIOR
	BEQ	CMD3F9

	LDA	ENEMYXMOM,X	;X MOMENTUM?
	CPY	#XMOM
	BEQ	CMD3F9
	
	LDA	ENEMYYMOM,X	;Y MOMENTUM?
	CPY	#YMOM
	BEQ	CMD3F9

	CPY	#SLOTS		;FREE SLOTS?
	BEQ	CMD3F8

	CPY	#XDIR		;X DIRECTION TO TARGETED ENTITY?
	BEQ	CMD3F7

	CPY	#YDIR		;Y DIRECTION TO TARGETED ENTITY?
	BEQ	CMD3F7

	CPY	#XDIST		;X DISTANCE TO TARGETED ENTITY?
	BEQ	CMD3F7

	CPY	#YDIST		;Y DISTANCE TO TARGETED ENTITY?
	BEQ	CMD3F7

	CPY	#DEF_SOLID	;DEFAULT SOLID FOR THIS ENTITY?
	BEQ	CMD3F20

	LDA	ENEMYXFRICT,X
	CPY	#XLINK
	BEQ	CMD3F9

	LDA	ENEMYYFRICT,X
	CPY	#YLINK
	BEQ	CMD3F9

	LDA	ENEMYFLG,X
	CPY	#ENTITYBITS
	BEQ	CMD3F9

	CPY	#MUSTDEFEAT
	BEQ	CMD3F25

	LDA	ENEMYDAMG,X
	AND	#H'07
	CPY	#DAMAGE
	BEQ	CMD3F9
	
	JSR	GETRANDOM

CMD3F9:	STA	ENEMYLREG,X
	RTS

CMD3F9A:   			;GO HERE TO RETURN VALUE IN BOTH REGISTERS
	STA	ENEMYLREG,X	;(TYPICALLY -1).
	STA	ENEMYHREG,X
	RTS

CMD3F8:	JSR	GETSLOTS

CMD3F2:	TYA
	LDX	SAFEBYTE
	JMP	CMD3F9

CMD3F7:	STY	SAFEX		;SET YDIR OR XDIR FLAG
	JSR	MAKETRACKS	;GET TARGET X AND Y 
	CMP	#-1
	BEQ	CMD3F9A		;IF NONE, RETURN -1.
	LDA	SAFEX		;GET WHICH WE WANTED.  Y=YDIR
	CMP	#YDIST		;Y DISTANCE?
	BEQ	CMD3F15
	CMP	#XDIST
	BEQ	CMD3F17
	CMP	#YDIR
	BEQ	CMD3F6
	LDY	#0		;ASSUME HE'S RIGHT OF US
	LDA	SUBSVAR1	;GET HIS LOCATION
       	CMP	ENEMYCENTR,X	;COMPARE TO OUR X SAME AS TRACKDIR DOES
	BCS	CMD3F2
	LDY	#1		;HE WAS TO THE LEFT.
	JMP	CMD3F2

CMD3F6:	LDY	#0		;ASSUME HE'S BELOW US
	LDA	SUBSVAR2
	CMP	ENEMYFEET,X
	BCS	CMD3F2
	LDY	#1    		;HE WAS ABOVE US
	JMP	CMD3F2

CMD3F20:
	JSR	POINTENEMY	;POINT TO THE ENEMY TABLE FOR THIS ONE
	LDY	#3
	LDA	(SUBSVAR1),Y	;GET THE SOLID VALUE
	JMP	CMD3F9

CMD3F15:
	LDA	SUBSVAR2
	SEC
	SBC	ENEMYFEET,X	;MAKE DISTANCE
CMD3F18:
	BPL	CMD3F16
	JSR	NEGATE		;RETURN ABSOLUTE VALUE
CMD3F16:
	JMP	CMD3F9

CMD3F17:
	LDA	SUBSVAR1
	SEC
	SBC	ENEMYCENTR,X	;RETURN ABSOLUTE X DISTANCE TO TARGET
	JMP	CMD3F18

CMD3F25:
	LDY	#0
	STY	SAFEWORD
CMD3F26:
	JSR	VALID2		;SKIP USJ OR INVALID ENTRIES
	BEQ	CMD3F28
	BEQ	CMD3F28
	LDA	ENEMYFLGS,Y	;GET THE FLAGS
	AND	#4
	BEQ	CMD3F28
	INC	SAFEWORD
CMD3F28:	
	INY
	CPY	#ECNT
	BNE	CMD3F26
	LDA	SAFEWORD
	JMP	CMD3F9

;THIS SUB WILL RETURN THE NUMBER OF FREE ENTITY SLOTS IN Y.  IT CHANGES
;ALL REGISTERS.

GETSLOTS:
	LDY	#0
	LDX	#0
GSL10:	LDA	ENEMY0,X
	CMP	#-1
	BNE	GSL20
	INY		;FOR EVERY AVAILABLE SLOT, INCREASE COUNT
GSL20:	INX
	CPX	#ECNT	;DONE?
	BNE	GSL10
	RTS	

CMD40:	LDA	DATA1		;AND REGISTER
	AND	ENEMYLREG,X
	STA	ENEMYLREG,X
	LDA	DATA2
	AND	ENEMYHREG,X
	STA	ENEMYHREG,X
CMD401:	RTS

CMD41:				;COMPARE REGISTER
CMD411:	LDA	ENEMYLREG,X	;GET REGISTER VALUE
	SEC
	SBC	DATA3
	LDA	ENEMYHREG,X
	SBC	DATA4
	BCC	CMD401
	JMP	MOVEPTR
		
CMD42:	LDA	DATA1		;ADD REGISTER
	CLC
	ADC	ENEMYLREG,X
	STA	ENEMYLREG,X
	LDA	DATA2
	ADC	ENEMYHREG,X
	STA	ENEMYHREG,X
	RTS

CMD43:	LDA	DATA1		;SET PAUSE
	EOR	#OFF		;MAKE OFF BE FALSE
	STA	PAUSEFLG
	RTS

CMD44:	LDA	ENEMYLREG,X	;INDEX		
	ASL	A
	CLC
	ADC	ENEMYPTR
	STA	ENEMYPTR
	BCC	CMD442
	INC	ENEMYPTR+1
CMD442:	LDX	#2		;GET THE SELECTION
	JSR	FILLCBUF
	LDX	SAFEBYTE 
	LDA	DATA1
	STA	DATA2
	LDA	CMDBUF
	STA	DATA1
CMD444:	JMP	MOVEPTR	

CMD45:
IFDEF( `XVICTIM', `		
	LDA	DATA3		;MOVE EXECUTE POINTER IF LAST VICTIM
	CMP	ENEMYVCTM,X	;SEE IF MATCH
	BEQ	CMD444
	RTS
	', )

CMD46:	JSR	DATAINDX		;LOAD BYTE FROM COMMON RAM
	BEQ	CMD465
	LDA	COMMONDATA,Y
	STA	ENEMYLREG,X
CLEARHIGH:			;CLEAR THE HIGH REGISTER FOR ENTITY X
	LDA	#0
	STA	ENEMYHREG,X
	RTS

CMD465:	LDA	STATERAM,Y	;WE ARE LOADING THE <STATE> VALUE
	STA	ENEMYLREG,X
	LDA	STATERAM+1,Y
	STA	ENEMYHREG,X
	RTS

CMD47:	JSR	DATAINDX		;STORE BYTE INTO COMMON RAM
	BEQ	CMD475
	LDA	ENEMYLREG,X
	STA	COMMONDATA,Y
	RTS

CMD475:	LDA	ENEMYLREG,X	;STORE INTO THE STATE VARIABLE
	STA	STATERAM,Y
	LDA	ENEMYHREG,X
	STA	STATERAM+1,Y
	RTS

;THIS SUB WILL TAKE A COMMON DATA AREA SPECIFIER IN DATA1 AND RETURN
;AN INDEX TO IT IN Y.  ON RETURN, IF Z THEN Y WAS <STATE>.

DATAINDX:
	LDY	DATA1		
	CPY	#STATE
	BNE	DIX10
	LDA	SAFEBYTE
	ASL	A
	TAY
	LDA	#0
DIX10:	RTS	

CMD48:	JSR	DATAINDX		;ADD BYTE FROM COMMON RAM
	BEQ	CMD485
	LDA	ENEMYLREG,X
	CLC
	ADC	COMMONDATA,Y
	STA	ENEMYLREG,X
	BCC	CMD481
	INC	ENEMYHREG,X
CMD481:	RTS

CMD485:	LDA	ENEMYLREG,X		;IF <STATE> ADD FULL WORD
	CLC
	ADC	STATERAM,Y
	STA	ENEMYLREG,X
	LDA	ENEMYHREG,X
	ADC	STATERAM+1,Y
	STA	ENEMYHREG,X
	RTS

CMD49:	LDA	#DINGSLOT	;NOISE
	LDA	#DINGSLOT
	JSR	SILENCE		;IF 0 OR PLAY, SILENCE THE CHANNEL

CMD50:	LDA	DATA2		;LOW PRIORITY NOISE
	BEQ	CMD499		;SKIP IF JUST SILENCE IT (ILLEGAL)
	TAY
	LDA	DATA1
	TAX
	LDA	#DINGSLOT 
	JSR	PLAY
CMD499:	RTS

CMD4A:	LDA	DATA1		;SET ALTERNATE COUNTER.  
	JSR	REGVAL		
	STA	ENEMYALT,X
CMD4A9:	RTS

CMD4B:	LDA	DATA3		;MOVE EXECUTE POINTER IF ALT COUNTER BELOW
	CMP	ENEMYALT,X	;BELOW THE VALUE?
	BCC	CMD4A9
	JMP	MOVEPTR

CMD4C:	LDA	DATA1		;SET DIRECTION FLAG
	JSR	REGVAL		
	STA	ENEMYFACE,X
	RTS	     

CMD4D:	LDX	DATA1		;SET BACKGROUND PALETTE
	LDY	DATA2
	CPY	#-1
	BNE	CMD4D5
	JSR	WORLD_BPAL
	RTS
CMD4D5:	JSR	BACKPAL
	RTS

CMD4E:	LDX	DATA1		;SET SPRITE PALETTE
	LDY	DATA2
	CPY	#-1
	BNE	CMD4E5
	JSR	WORLD_SPAL
	RTS
CMD4E5:	JSR	SPRITEPAL
	RTS

CMD4F:	LDA	DATA1		;SHAKE.
	STA	SHAKEAMT	;SET SHAKE AMOUNT
CMD4F5:	RTS

CMD51:	LDA	DATA3		;MOVE IF X<VALUE
	CMP	ENEMYCENTR,X
	BCC	CMD4F5
CMD515:	JMP	MOVEPTR

CMD52:	LDA	DATA3		;MOVE IF Y<VALUE
	CMP	ENEMYFEET,X	;COMPARE HIS LOW BYTE TO WHAT WE WANT
	BCS	CMD515
	RTS			;CARRY ALWAYS SET IF ITS BIGGER

CMD53:	LDA	DATA3		;EQUAL REGISTER
	CMP	ENEMYLREG,X	;GET REGISTER VALUE
	BNE	CMD4F5
	LDA	DATA4
	CMP	ENEMYHREG,X
	BEQ	CMD515
	RTS

CMD54: 	JSR	SETPTR		;SAVE ENEMYPTR
	LDA	DATA1		;INDEX INTO TABLE
	CLC
	ADC	ENEMYLREG,X	;INDEX INTO THE TABLE
	STA	ENEMYPTR
	LDA	DATA2
	ADC	ENEMYHREG,X
	STA	ENEMYPTR+1	;MAKE (ENEMYPTR) POINT TO THE DATA
	LDX	#2
	JSR	FILLCBUF	;GET THE DATA
	LDX	SAFEBYTE	;RESTORE OUR INDEX
	LDA	CMDBUF
	STA	ENEMYLREG,X
	LDA	DATA1
	STA	ENEMYHREG,X
 	JSR	EBACKUP		;RESTORE ENEMYPTR
	RTS	

CMD55: 
IFDEF( `XDISSCROLL', `		
	LDA	SCROLLFLG	;DISABLE SCROLLING
	ORA	DATA1		;SET THE BITS
	STA	SCROLLFLG
	RTS
	', )

CMD56:	LDA	SCROLLFLG	;ENABLE SCROLLING
	ORA	DATA1
	EOR	DATA1		;RESET THE BITS
	STA	SCROLLFLG
	RTS

CMD57: 
IFDEF( `XSETCOL', `		
	LDA	DATA1		;SET WORLD COLUMN
	STA	SAFEY
	LDA	DATA2
	STA	SAFEY2
	JSR	WORDREG
	LDA	SAFEY
	STA	ENEMYLCOL,X
	LDA	SAFEY2
	STA	ENEMYHCOL,X
	RTS
	', )

CMD58:	JSR	DATAINDX	;COMPARE TO COMMON DATA AREA RAM
	BEQ	CMD585
	LDA	#0
	STA	DATA4		;CLEAR HIGH BYTE FOR COMPARE
	LDA	COMMONDATA,Y
	JMP	CMD586		;GO SHARE CODE
CMD585:	LDA	STATERAM+1,Y
	STA	DATA4
	LDA	STATERAM,Y

CMD586:	TAY			;SAVE LOW BYTE FOR COMPARE
	LDA	DATA2
	STA	DATA1
	LDA	DATA3
	STA	DATA2
	STY	DATA3
	JMP	CMD411

CMD59:	LDA	DATA1		;ADD TO MOMENTUMS USING REGISTER
	JSR	REGVAL
	STA	DATA1
	LDA	DATA2
	JSR	REGVAL
	STA	DATA2
	JSR	USEMOM		
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD5A:	JSR	DATAINDX	;EXCHANGE BYTE WITH COMMON RAM
	BEQ	CMD5A5
	LDA	COMMONDATA,Y
	PHA
	LDA	ENEMYLREG,X
	STA	COMMONDATA,Y
CMD5A2:	PLA
	STA	ENEMYLREG,X
	RTS
CMD5A5:	LDA	STATERAM,Y	;IF <STATE> FULL WORD EXCHANGE
	PHA
	LDA	STATERAM+1,Y
	PHA
	LDA	ENEMYLREG,X
	STA	STATERAM,Y
	LDA	ENEMYHREG,X
	STA	STATERAM+1,Y
	PLA
	STA	ENEMYHREG,X
	JMP	CMD5A2


CMD5B:	LDA	DATA1		;XOR REGISTER
	EOR	ENEMYLREG,X
	STA	ENEMYLREG,X
	RTS

CMD5C: 
IFDEF( `XRGB', `		
	LDA	DATA1
	JSR	REGVAL		;RGB MONO CONTROL
	STA	DATA1
	LDA	REG2001
	AND	#30
	ORA	DATA1
	STA	REG2001
	RTS
	', )

CMD5D:	LDA	DATA1
	JSR	REGVAL		;SET BEHAVIOR BIT
	ORA	ENEMYBEHAVE,X
	STA	ENEMYBEHAVE,X
	RTS

CMD5E:	LDA	DATA1
	JSR	REGVAL		;RESET BEHAVIOR BIT
	STA	DATA1
	ORA	ENEMYBEHAVE,X
	EOR	DATA1
	STA	ENEMYBEHAVE,X
CMD5E5:	RTS

CMD5F:	LDA	DATA3		;IF BEHAVIOR BIT SET
	AND	ENEMYBEHAVE,X
	BEQ	CMD5E5
	JMP	MOVEPTR

CMD60:	LDA	DATA3		;IF BEHAVIOR BIT NOT SET
	AND	ENEMYBEHAVE,X
	BNE	CMD5E5
	JMP	MOVEPTR

;CREATE IS ALSO SHARED BY SPAWN.  SPAWN HAS THE SAME PARAMETERS BUT
;EXPECTS THAT ON RETURN Y WILL HAVE THE CREATED ENTITIES INDEX AND
;Z INDICATES SUCCESS.

CMD61: 	JSR	FINDFREE	;CREATE ENEMY
	BNE	CMD5E5		;DONE IF NONE AVAILABLE
	TXA
	TAY			;MAKE ENEMY INDEX HERE
	LDX	SAFEBYTE	;GET OUR INDEX FROM HERE
	LDA	DATA1		;GET ENEMY TYPE
	JSR	REGVAL
	STA	BYTE1		;SAVE FOR CMD1F20
	LDA	#-1
	STA	ENEMYLCOL,Y	;SET THAT THIS LAUNCH HAS NO ORIGIN
	STA	ENEMYHCOL,Y

	LDA	#0
	STA	ENEMYSTAT,Y	;SET AS NOT ASLEEP

	LDA	DATA4
	STA	ENEMYP2,Y	;SET PARAMETER 2 FROM OUR COMMAND.
	
	LDA	DATA2		;GET LAUNCH X
	STA	ENEMYX,Y
	LDA	DATA3
	STA	ENEMYY,Y	;MAKE LAUNCH Y
	TYA
	PHA
	JSR	CMD1F20
	PLA
	TAY
	LDA	#0
	RTS

CMD62:	LDA	ENEMYTRACK,X	;MOVE EXECUTE POINTER IF STAIR
	BPL	CMD621
	LDX	#-8
	JMP	CMD622
CMD621:	LDX	#8
CMD622:	LDY	#0
	STX	SAFEX2		;SAVE X MOVEMENT DIRECTION
	
	JSR	TESTMOVE	;MAKE SURE WE CAN'T MOVE 8 AHEAD
	BEQ	CMD662		;IF WE CAN, NO STAIR	

	LDA	DATA3
	ASL	A
	ASL	A
	ASL	A		;MAKE AMOUNT UP INTO PIXELS
	JSR	NEGATE		;ABOVE US
	TAY
	LDX	SAFEX2
	JSR	TESTMOVE	;SEE IF WE COULD MOVE THERE
	BNE	CMD662
CMD623:	JMP	MOVEPTR

CMD63:	LDA	DATA2		;ACTIVATE ANIMATION ONLY
	STA	SETUPFLG
	JSR	PICKMOD3	;SET IT UP
	RTS

CMD64:	LDA	DATA1		;CHEAT MODE
	EOR	#OFF
	STA	ENABLE_SELECT
	RTS

CMD65:				;RESET FRICTION COUNTER
	LDA	ENEMYFCTR,X	;GET STATUS BITS
	LDY	DATA1
	BEQ	CMD651
	AND	#H'F0		;REMOVE COUNTER ON DELAY TO FRICTION ON
	ORA	#XFCTR
CMD651:	LDY	DATA2
	BEQ	CMD652
	AND	#H'0F		;REMOVE Y COUNTER VALUE
	ORA	#YFCTR*16
CMD652:	STA	ENEMYFCTR,X
	RTS

CMD66:				;MOVE EXECUTE POINTER IF FLOOR

CMD661:	LDA	DATA3
	ASL	A
	ASL	A
	ASL	A		;MAKE INTO PIXELS
	TAY
	LDX	#0
	JSR	TESTMOVE	;SEE IF WE COULD MOVE THERE
	BNE	CMD623		;IF NOT, WE FOUND A LEDGE
	DEC	DATA3
	BNE	CMD661
CMD662:	RTS

CMD67: 	LDA	DATA3
	STA	SAFEX
	LDA	DATA4		;LINK TO ENEMY.  FIRST SKIP X AND Y DISPLACE
	STA	SAFEY
	LDA	DATA5
	STA	SAFEY2
	BNE	CMD671
	LDA	SAFEY
	JSR	REGVAL
	STA	SAFEY		;MAKE VALUES FOR FINDENEMY
CMD671:	JSR	FINDENEMY	;TRY TO FIND THIS ONE
	BNE	CMD662		;DON'T LINK IF NONE
	TYA
	STA	ENEMYLINK,X	;SET THIS ENTITY AS LINKED TO ENTITY Y
	LDA	DATA1
	CMP	#-1
	BNE	CMD672
       	LDA	ENEMYX,X
	SEC
	SBC	ENEMYX,Y	;MAKE OFFSET IF -1 SPECIFIED
CMD672:	STA	ENEMYXFRICT,X
	LDA	DATA2
	CMP	#-1
	BNE	CMD673
       	LDA	ENEMYY,X
	SEC
	SBC	ENEMYY,Y	;MAKE OFFSET IF -1 SPECIFIED
CMD673:	STA	ENEMYYFRICT,X	;SET OFFSETS FOR THE LINK
	JMP	NOCMDS		;LET EXIT CODE POSITION HIM

CMD68:	LDA	#-1		;UNLINK
	STA	ENEMYLINK,X
	LDA	#DEF_XFRICT
	STA	ENEMYXFRICT,X
	LDA	#DEF_YFRICT	;SET FRICTIONS
	STA	ENEMYYFRICT,X
	RTS	

CMD69:	LDA	DATA2		;SPAWN
	PHA			;SAVE RELATIVE OFFSET FOR X
	LDA	#255
	STA	DATA2		
	LDA	DATA3
	PHA	     		;SAVE Y RELATIVE OFFSET TOO
	LDA	#H'F8
	SEC
	SBC	SPYADJ		;MAKE Y THAT HIDES IT UNTIL PUTLINK FIXES IT
	STA	DATA3
 	JSR	CMD61		;SPAWN ENEMY
	BNE	CMD691
	LDA	SAFEBYTE
	STA	ENEMYLINK,Y	;SET AS LINKED TO US
	PLA
	STA	ENEMYYFRICT,Y
	PLA
	STA	ENEMYXFRICT,Y	;SET RELATIVE OFFSETS FOR LINK
	LDA	SAFEBYTE
	PHA			;SAVE OUR INDEX
	STY	SAFEBYTE
	JSR	PUTLINK		;PUT HIM WITH CORRECT INVERSION
	PLA
	STA	SAFEBYTE	
	RTS
CMD691:	PLA			;IF CAN'T CREATE, THROW OUT RELATIVE OFFSETS
	PLA
	RTS

CMD6A:	LDA	ENEMYJSTAT,X		;HALF FREQUENCY
	AND	#H'BF		;ASSUME OFF
	LDY	DATA1
	CPY	#OFF		;WAS IT OFF?
	BEQ	CMD6A5
	ORA	#H'40
CMD6A5:	STA	ENEMYJSTAT,X
CMD6A6:	RTS

CMD6B:	LDA	ENEMYLINK,X	;MOVE IF LINKED
	CMP	#-1
	BEQ	CMD6A6
	JMP	MOVEPTR

CMD6C:	LDA	DATA1		;RELINK TO ENEMY.  
	CMP	#-1
	BEQ	CMD6C2
	JSR	REGVAL
	STA	ENEMYXFRICT,X

CMD6C2:	LDA	DATA2
	CMP	#-1
	BEQ	CMD6C4
	JSR	REGVAL
	STA	ENEMYYFRICT,X	;SET OFFSETS FOR THE LINK
CMD6C4:	JMP	NOCMDS		;LET EXIT CODE POSITION HIM

CMD6D:				;TOPSTAT
	LDA	DATA4		;SEE IF USE CURRENT SET
	BPL	CMD6D1
	LDY	CURWORLD
	LDA	USE_BCHRS,Y
	STA	DATA4
CMD6D1:	LDA	REG2000
	STA	H'2000		;DISABLE NMI
	JSR	INITSTAT
	LDA	REG2000
	ORA	#H'80		;ENABLE NMI INTS
	STA	H'2000
	RTS

CMD6E:	LDA	STATLEN		;WRITE TO STATUS LINE
	BEQ	CMD6E1
CMD6E2:	JSR	EBACKUP		;WE CAN'T GO NOW, RESTORE OLD PTR
	JMP	NOCMDS		;AND EXIT

CMD6E1:	LDA	DATA1	
	STA	STATDATA
	LDA	DATA2
	STA	STATDATA+1	;SET THE POINTER
	LDA	DATA3
	STA	STATROW
	LDA	DATA4
	STA	STATCOL		;SET ROW AND COLUMN
	LDA	#WRITEVID
	STA	STATTYPE	;SET COMMAND TYPE
	LDA	DATA5
	STA	VIDTYPE		;SET VIDEO TYPE
	LDA	DATA6		;GET LENGTH
	STA	STATLEN
	RTS

CMD6F:	LDA	STATLEN		;FILL STATUS LINE
	BNE	CMD6E2
	LDA	DATA1
	STA	STATROW
	LDA	DATA2
	STA	STATCOL		;SET ROW AND COLUMN
	LDA	DATA3
	STA	STATDATA	;AND DATA
	LDA	#FILLVID
	STA	STATTYPE	;SET TYPE OF WRITE
	LDA	DATA4
	STA	VIDTYPE		;SET VIDEO TYPE
	LDA	DATA5
	STA	STATLEN		;SET LENGTH
	RTS

CMD70:	LDA	STATLEN		;SET STATUS LINE PALETTE COLORS
	BNE	CMD6E2
	LDA	DATA1
	STA	STATROW
	JSR	LOADPTR
	CLC
	ADC	#2
	STA	STATDATA	
	TYA
	ADC	#0
	STA	STATDATA+1	;SET POINTER TO THE 8 BYTES IN ROM
	LDA	#SETSTATPAL
	STA	STATTYPE	;SET TYPE OF WRITE
	LDA	#8
	STA	STATLEN		;SET LENGTH
	RTS

CMD71:	JSR	DATAINDX	;DIVIDE BY COMMON DATA AREA RAM
	BEQ	CMD715
	STY	SAFEWORD	;SAVE IT OUT
	LDA	COMMONDATA,Y	;GET BYTE TO DIVIDE BY
	PHA
	LDA	ENEMYHREG,X	;GET BYTE TO DIVIDE
	TAY
	LDA	ENEMYLREG,X
	TAX
	PLA
	JSR	DIVIDE		;DO THE DIVIDE
	TXA			;GET RESULT
	LDX	SAFEBYTE
	STA	ENEMYLREG,X	;SAVE RESULT
	TYA			;GET REMAINDER
	LDY	SAFEWORD
	STA	COMMONDATA,Y	;SET REMAINDER
	JMP	CLEARHIGH

CMD715:	STY	SAFEWORD	;SAVE WHERE TO PUT RESULT.  ITS <STATE>
	LDA	STATERAM,Y
	PHA
	LDA	ENEMYHREG,X
	TAY
	LDA	ENEMYLREG,X
	TAX
	PLA
	JSR	DIVIDE		;MAKE A FULL WORD DIVIDE BY A BYTE VALUE
	TXA
	LDX	SAFEBYTE
	STA	ENEMYLREG,X
	TYA
	LDY	SAFEWORD
	STA	STATERAM,Y	;SET REMAINDER
	LDA	#0
	STA	STATERAM+1,Y	;BUT CLEAR HIGH BYTE
	JMP	CLEARHIGH

CMD72:	JSR	DATAINDX	;MULTIPLY BY COMMON DATA AREA RAM
	BNE	CMD721
	LDA	STATERAM,Y
	JMP	CMD722
CMD721:	LDA	COMMONDATA,Y	;GET BYTE TO MULTIPLY BY
CMD722:	LDY	ENEMYLREG,X	;GET BYTE TO BE MULTIPLIED
	TAX
	JSR	MUL		;DO THE MULTIPLY
	TXA			;GET RESULT
	LDX	SAFEBYTE
	STA	ENEMYLREG,X	;SAVE RESULT
	TYA			;GET HIGH BYTE RESULT
	STA	ENEMYHREG,X	;SET HIGH RESULT
	RTS

CMD73:	JSR	FINDJOY		;GET HEROS COUNT
	BNE	CMD731		;SKIP IF NONE
	LDA	HEROCOUNT,Y	;GET COUNT TO RETURN
	STA	ENEMYLREG,X
	JMP	CLEARHIGH
CMD731:	RTS 

CMD74:
IFDEF( `XSHOWSCORE', `		
	LDA	STATLEN		;SHOW THE SCORE
	BNE	CMD740
	JSR	FINDJOY		;FIGURE OUT WHICH SCORE TO USE
	BNE	CMD731		;END IF NONE APPLICABLE
	STY	STATDATA	;SET INDEX TO USE FOR THE SCORE HERE
	LDA	DATA2
	STA	STATROW
	LDA	DATA3
	STA	STATCOL
	LDA	DATA4
	STA	VIDTYPE		;SET VIDEO PAGE OR STAT FLAG HERE
	LDA	#SHOWSCORE
	STA	STATTYPE	;SET STATUS TYPE
	LDA	#5		;5 DIGITS MAX.  ITS ASSUMED WE INIT THIS!
	STA	STATLEN
	RTS
	', )
CMD740:	JMP	CMD6E2

CMD75:	LDA	STATLEN		;SHOW THE REGISTER
	BNE	CMD740
	LDA	DATA1
	STA	STATROW
	LDA	DATA2
	STA	STATCOL
	LDA	DATA3
	STA	VIDTYPE		;SET VIDEO PAGE OR STAT FLAG HERE
	LDA	#SHOWREG
	STA	STATTYPE	;SET STATUS TYPE
	LDA	ENEMYLREG,X
	STA	STATDATA	;SET THE REGISTER VALUE
	LDA	ENEMYHREG,X
	STA	STATDATA+1
	LDA	#5		;5 DIGITS MAX.  ITS ASSUMED WE INIT THIS!
	STA	STATLEN
	RTS

CMD76:	LDA	DATA1
	JSR	REGVAL		;SET HEALTH
	STA	ENEMYHEALTH,X
	RTS

CMD77:				;SKIP THE POINTER, GET THE FIRST 2 FLAGS
	LDX	DATA3		;CHECK FIRST
	LDA	#0
	JSR	CHECKCHANNEL
	LDX	DATA4		;CHECK NEXT
	LDA	#1
	JSR	CHECKCHANNEL
	LDX	DATA5		;CHECK NEXT
	LDA	#2
	JSR	CHECKCHANNEL
	LDX	DATA6		;CHECK NEXT
	LDA	#3
	JSR	CHECKCHANNEL
	RTS

CHECKCHANNEL:
	CPX	#DONTCARE
	BEQ	CMD778
	JSR	PLAYING
	BEQ	CMD778
	PLA
	PLA
CMD777:	JMP	MOVEPTR
CMD778:	RTS

CMD78: 	JSR	SETPTR		;REGISTER INDEXED SOUND TABLE
	LDA	#0		
	STA	ENEMYPTR+1
	LDA	ENEMYLREG,X
	ASL	A
	ROL	ENEMYPTR+1
	ASL	A
	ROL	ENEMYPTR+1
	ASL	A
	ROL	ENEMYPTR+1
	CLC	
	ADC	DATA1
	STA	ENEMYPTR
	LDA	DATA2
	ADC	ENEMYPTR+1
	STA	ENEMYPTR+1	;MAKE BASE MUSIC POINTER
	LDX	#8
	JSR	FILL_POINT	;GET THE DATA AND RESTORE POINTERS
	LDA	SUBSVAR1
	STA	EXTRA_PTR
	LDA	SUBSVAR2
	STA	EXTRA_PTR+1

	LDA	#0
	STA	SAFEX		;SET CHANNEL FOR LOOP

CMD782:	ASL	A
	TAY
	LDA	(EXTRA_PTR),Y
	STA	SAFEWORD
	INY
	LDA	(EXTRA_PTR),Y
	STA	SAFEWORD+1
	JSR	DOCHANNEL	;DO THIS SOUND CHANNEL
	LDA	SAFEX
	CMP	#4		;DONE?
	BNE	CMD782
	RTS

CMD79:				;HIDE ALL ENEMIES
	STX	SAFEX		;SAVE OUR INDEX
	LDA	#ECNT-1
	STA	SAFEBYTE
CMD791:	LDA	SAFEBYTE	;GET NEXT ONE TO HIDE
	CMP	SAFEX
	BEQ	CMD792
	JSR	ENEMYGONE	;REMOVE THIS ONE
CMD792:	DEC	SAFEBYTE
	BPL	CMD791		;DO ALL OF THEM.
	LDX	SAFEX
	STX	SAFEBYTE	;RESTORE OUR INDEX
	RTS

CMD7A:	LDA	DATA1
	JSR	REGVAL		;GET HOW MANY OF A SPECIFIC ENTITY
	LDY	#0
	STY	DATA1
CMD7A2:	CMP	ENEMY0,Y	;MATCH?
	BNE	CMD7A3
	INC	DATA1
CMD7A3:	INY
	CPY	#ECNT
	BNE	CMD7A2
	LDA	#0
	STA	DATA2
	JMP	CMD3E1		;RETURN DATA1 IN REGISTER

CMD7B:	LDX	DATA3		;TEST FOR SOLID
	LDY	DATA4
	JSR	TESTMOVE	;SEE IF SOLIDS
	BEQ	CMD7B1
	JMP	MOVEPTR
CMD7B1:	RTS	

CMD7C:	LDA	#0		;WIPEOUT.
	STA	SAFEX		;SET VIDEO PAGE TO DO
	STA	SAFEX2		;SET TOP FLAG = 0 (1=BOTTOM)
	STA	SAFEY		;SET TOP ROW TO DO
	LDA	#29
	STA	SAFEY2		;SET BOTTOM ROW TO DO
	
CMD7C1:	LDA	STATLEN		;WAIT FOR BUFFER AVAILABLE
	BNE	CMD7C1

	LDY	SAFEY		;ASSUME TOP ROW IS BEING DONE
	LDA	SAFEX2		;SEE IF ITS SO
	BEQ	CMD7C2
	LDY	SAFEY2		;IF NOT TOP, ITS BOTTOM
CMD7C2:	STY	STATROW		;SET ROW TO WRITE TO

	LDA	SAFEX		;GET VIDEO PAGE TO DO
	STA	VIDTYPE		;SET FOR THE SUB

	LDA	#ERASECHAR
	STA	STATDATA	;SET CHAR TO USE FOR ERASE

	LDA	#0
	STA	STATCOL		;SET COLUMN

	LDA	#FILLVID
	STA	STATTYPE	;SET TYPE OF WRITE

	LDA	#32
	STA	STATLEN		;SET LENGTH TO FILL


	LDA	SAFEX		;GET BACK VIDEO PAGE TO DO
	EOR	#1		;MOVE TO NEXT
	STA	SAFEX		;IF NOW 0, TIME TO GO TO BOTTOM
	BNE	CMD7C1

	LDA	SAFEX2		;GET TOP/BOTTOM FLAG
	EOR	#1
	STA	SAFEX2
	BNE	CMD7C1		;IF HAVEN'T DONE BOTTOM YET, DO IT

	INC	SAFEY		;GO TO NEXT ROW ON TOP IF DONE
	DEC	SAFEY2		;AND GO UP 1 ON THE BOTTOM
	LDA	SAFEY2		;DONE WHEN BOTTOM ROW=14 AND TOP=15
	CMP	#15
	BCS	CMD7C1
CMD7C3:	LDA	STATLEN
	BNE	CMD7C3
	LDA	SCCNT
	BNE	CMD7C3
	JSR	ALLSILENCE	;TURN OFF ALL SOUNDS
	LDY	#0
	LDX	SAFEBYTE
	JMP	CMD0F		;FINISH WITH THE WORLD COMMAND.

CMD7D:	LDA	DATA1		;THROW BACK
	JSR	REGVAL
	STA	DATA1
	LDA	DATA2
	JSR	REGVAL
	STA	DATA2
	LDY	ENEMYATK,X	
	LDA	ENEMYTRACK,Y	;GET THE DIRECTION OF THE OTHER ENEMY
	BPL	CMD7D1	
	LDA	DATA1
	JSR	NEGATE
	STA	DATA1
CMD7D1:	JSR	USEMOM3
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.

CMD7E:	JSR	MAKE_ECOL	;MAKE THIS ENTITIES COLUMN
	LDA	SAFEWORD
	STA	ENEMYLREG,X
	LDA	SAFEWORD+1
	STA	ENEMYHREG,X
	RTS

CMD7F:	LDA	STATLEN		;TABLED WRITE TO STATUS LINE
	BEQ	CMD7F1
	JMP	CMD6E2

CMD7F1:	JSR	SETPTR
	LDA	ENEMYLREG,X
	ASL	A
	CLC
	ADC	DATA1
	STA	ENEMYPTR
	LDA	DATA2
	ADC	#0
	STA	ENEMYPTR+1	;POINT TO THE DATA
	LDX	#2
	JSR	FILLCBUF	;GET THE ENTRY
	LDX	SAFEBYTE
	JSR	EBACKUP
	LDA	DATA1
	STA	DATA2
	LDA	CMDBUF
	STA	DATA1
	JMP	CMD6E1

CMD80:	LDA	DATA1			;LIMIT
	SEC
	SBC	ENEMYLREG,X
	LDA	DATA2
	SBC	ENEMYHREG,X
	BCS	CMD801		;IF ITS ABOVE THE REGISTER, ITS OK
	LDA	DATA1
	STA	ENEMYLREG,X
	LDA	DATA2
	STA	ENEMYHREG,X
CMD801:	RTS

CMD81:	LDA	DATA1	  	;MOVE IN
	JSR	REGVAL
	STA	DATA1
	LDA	DATA2
	JSR	REGVAL
	STA	DATA2
	LDA	ENEMYTRACK,X	;SEE IF NEED REVERSAL FOR FACING LEFT
	BPL	CMD811
	LDA	DATA1
	CMP	#-1
	BEQ	CMD811
	JSR	NEGATE
	STA	DATA1
CMD811:	LDA	ENEMYTRACK,X
	AND	#H'40
	BEQ	CMD812
	LDA	DATA2
	CMP	#-1
	BEQ	CMD812
	JSR	NEGATE
	STA	DATA2
CMD812:	JSR	USEMOM4
	JMP	SEECMDS

CMD82:	LDA	DATA3		;EQUAL REGISTER
	CMP	ENEMYLREG,X	;GET REGISTER VALUE
	BNE	CMD821
	LDA	DATA4
	CMP	ENEMYHREG,X
	BEQ	CMD801
CMD821:	JMP	MOVEPTR

CMD83:	LDA	STATLEN		;SET PALETTE COLOR
	BNE	CMD839
	LDA	DATA1
	STA	STATCOL		;SET PALETTE COLOR TO WRITE TO
	LDA	DATA2
	STA	STATROW		;SET VALUE TO WRITE OUT
	LDA	#PALCLR
	STA	STATTYPE	;SET TYPE OF WRITE
	LDA	#1
	STA	STATLEN		;SET LENGTH
	RTS
CMD839:	JMP	CMD6E2

CMD84:	JSR	GETJOY		;SPECIFY SELECT FUNCTION
	LDA	DATA1
	STA	SELKEY,Y	
	RTS

CMD85:	LDA	ENEMYHREG,X	;DIVIDE BY CONSTANT
	TAY
	LDA	ENEMYLREG,X
	TAX
	LDA	DATA1		;GET BYTE TO DIVIDE BY
	JSR	DIVIDE		;DO THE DIVIDE
	TXA			;GET RESULT
	LDX	SAFEBYTE
	STA	ENEMYLREG,X	;SAVE RESULT
	JSR	CLEARHIGH
CMD851:	RTS

CMD86:	JSR	ACCESS_JOY		;GET JOYSTICK ENTITIES HEALTH
	LDA	ENEMYHEALTH,Y
	STA	ENEMYLREG,X	
	JMP	CLEARHIGH
				;CALL HERE WITH JOYSTICK SPECIFIER (CMD86)
ACCESS_JOY:			;IN DATA1 TO POINT Y TO THAT ENTITY.  IT
				;POPS STACK AND RETURNS IF NONE.
	JSR	FINDJOY		;GET JOYSTICK ENTITIES HEALTH
	BNE	AJY10		;SKIP IF NONE
	LDA	JOYENEMY,Y	;SEE IF THERE IS AN ENTITY ATTACHED TO IT
	TAY
	BPL	AJY20
AJY10:	PLA
	PLA
AJY20:	RTS

CMD87:	JSR	ACCESS_JOY	;SET JOYSTICK ENTITIES HEALTH
	LDA	ENEMYLREG,X	
	STA	ENEMYHEALTH,Y
	RTS

CMD88:	LDA	DATA1		;SET ENEMYFLG
	JSR	REGVAL
	STA	ENEMYFLGS,X
	RTS	

CMD89:	JSR	SETPTR		;WORLD GOTO
	LDY	#7
	LDA	DATA1
	STA	ENEMYPTR
	LDA	DATA2
	STA	ENEMYPTR+1	;GET BASE OFFSET OF TABLE
CMD890:	LDA	ENEMYLREG,X
	CLC
	ADC	ENEMYPTR
	STA	ENEMYPTR
	LDA	ENEMYPTR+1
	ADC	#0
	STA	ENEMYPTR+1
	DEY
	BNE	CMD890		;ADD 7*REGISTER TO CURRENT POINTER
	LDX	#7
	JSR	FILLCBUF
	LDX	SAFEBYTE
	JSR	EBACKUP		;RESTORE NEXT EXECUTION POINT	
	LDA	CMDBUF
	CMP	#NOCHANGE
	BNE	CMD891A
	JMP	CMD899

CMD891A:
	LDA	DATA4
	CMP	#-1		;SEE IF DON'T CARE
	BNE	CMD891
       	LDA	DATA3
	CMP	#-1
	BNE	CMD891		;THE LEFTMOST MUST BE FLOATING TO NOT RELAUNCH
	
	CMP	CURWORLD	;SEE IF SAME WORLD AS CURRENT
	BEQ	CMD899		;IF SAME WE MIGHT BE ABLE TO DO IT HERE.
	
;MOVE THE HERO TO THE NEW LOCATION AHEAD OF TIME.  THIS IS BECAUSE WE
;DON'T HAVE ENOUGH STORAGE TO SAVE IT NOW AND OUR FLAG MAKES US NOT GO AWAY

CMD891:	LDA	#-1
	STA	SPECGOTO	;SET GOTO LOCATION
	
	LDA	CURWORLD
	STA	WORLD_REQUEST
	LDA	#0
	STA	CHEATMODE	;FLAG ITS NOT A CHEAT MODE ENTERED WORLD
	LDA	CMDBUF
	CMP	#NOCHANGE
	BEQ	CMD893
	STA	WORLD_REQUEST	;REQUEST THE WORLD

CMD893:	LDA	DATA3
	STA	LEFTCOL		;SET LEFTMOST COLUMN FOR THE WORLD
	LDA	DATA4
	STA	LEFTCOL+1
	CMP	#-1		;SEE IF DON'T CARE
	BNE	CMD892
       	LDA	DATA3
	CMP	#-1
	BNE	CMD892
	LDA	DATA5
	SEC
	SBC	#16		;IF DON'T CARE, CENTER IT
	STA	LEFTCOL
	LDA	DATA6
	SBC	#0
	STA	LEFTCOL+1
	BCS	CMD892		
	LDA	#0
	STA	LEFTCOL
	STA	LEFTCOL+1	;IF CAN'T BACK UP 16, BACK UP 0.

CMD892:

IFDEF( `BLOCKMODE', `		

	LDA	DATA2
	STA	TOPROW		;SET TOPMOST ROW FOR THE WORLD
	CMP	#-1		;SEE IF DONT CARE
	BNE	CMD894
	LDA	DATA1
	SEC
	SBC	#16		;IF DONT CARE, CENTER IT
	STA	TOPROW
	BCS	CMD893A
	LDA	#0
	STA	TOPROW
CMD893A:
	LDA	TOPROW
	STA	DATA2	
	', )

;THIS CODE TO MOVE THE HERO TO THE NEW LOCATION IS SHARED.

CMD894:	LDA	DATA1
	SEC
	SBC	DATA2		;MAKE Y LOCATION RELATIVE TO TOP
	JSR	TIMES8		;MAKE PIXEL OFFSET
	STA	ENEMYY,X
	LDA	DATA5
	SEC
	SBC	LEFTCOL
	AND	#H'1F		;MAKE X COLUMN 0-31 FROM DIFFERENCE
	JSR	TIMES8		;MAKE *8
	STA	ENEMYX,X
	JSR	FINDLOCS	;UPDATE HERO'S FLAGS
	JMP	NOCMDS

CMD898:	JMP	CMD891

;WE ARE STAYING IN THIS WORLD. SEE IF WE CAN DO IT WITHOUT HAVING TO
;MOVE THE SCREEN

CMD899:	LDA	DATA5
	SEC
	SBC	STARTCOL
	STA	SAFEWORD
	LDA	DATA6
	SBC	STARTCOL+1	;SEE OUT HERO'S LOCATION IS ON SCREEN
	BCC	CMD898
	BNE	CMD898
	LDA	SAFEWORD
	CMP	#31		;HE HAS TO BE AT LEAST 1 FROM RIGHT
	BCS	CMD898
	CMP	#1
	BCC	CMD898		;AND AT LEAST 1 FROM LEFT

IFDEF( `BLOCKMODE', `		

	LDA	DATA1		;GET WHERE WE WANT HEROS FEET
	SEC
	SBC	STARTROW	;SEE HOW FAR FROM TOP
	CMP	#24		;MUST BE WITHIN 24
	BCS	CMD898
	CMP	#5
	BCC	CMD898		;AND BELOW 5
	', )

;WE CAN STAY WHERE WE ARE.  

	LDA	DATA1		;GET Y LOCATION
	SEC
	SBC	DATA2		;MAKE IT RELATIVE TO TOP
	JSR	TIMES8		;MAKE PIXEL OFFSET
	TAY
	STA	ENEMYY,X
	LDA	DATA5
	SEC
	SBC	STARTCOL
	AND	#H'1F		;MAKE X COLUMN 0-31 FROM DIFFERENCE
	JSR	TIMES8		;MAKE *8
	STA	SAFEWORD
	LDA	XBACK
	AND	#7		;GET ODD PIXELS
	CLC
	ADC	SAFEWORD
	STA	ENEMYX,X
	JSR	FINDLOCS
	JMP	NOCMDS

CMD8A:	LDA	DATA1		;RESET ENTITY MEMORY
	CMP	#ALL		;RESET ALL OF THEM?
	BNE	CMD8A3
	LDA	#0
	TAX
	LDY	#32		;IF ALL, DO ALL
CMD8A1:	STA	REMEMBER,X	;SET THE SPECIFIED BYTE(S) TO -1
	INX
	DEY
	BNE	CMD8A1
CMD8A2:	RTS	

CMD8A3:	JSR	MAKELIFE
	LDX	SAFEBYTE
	STA	SAFEWORD
	ORA	REMEMBER,Y
	EOR	SAFEWORD	;RESET THE BIT TO MAKE IT ALIVE AGAIN
	STA	REMEMBER,Y
	RTS

CMD8B:	LDA	CHEATMODE	;BRANCH IF NOT CHEAT MODE ENTERED WORLD
	PHA
	LDA	#0
	STA	CHEATMODE	;FLAG ITS NOT A CHEAT MODE ENTERED WORLD
	PLA
	BNE	CMD8A2
	JMP	MOVEPTR

CMD8C:	JSR	FULLMINUS	;WHOS LINKED TO US
	LDY	#0
CMD8C1:	JSR	VALID2
	BEQ	CMD8C2
	LDA	ENEMYLINK,Y
	CMP	SAFEBYTE	;SEE IF HE'S LINKED TO US
	BNE	CMD8C2
	LDA	ENEMY0,Y	;GET HIS ENTITYTAB NUMBER
	STA	ENEMYLREG,X
	JSR	CLEARHIGH
	RTS
CMD8C2:	INY
	CPY	#ECNT
	BNE	CMD8C1
CMD8C3:	RTS

CMD8D:
IFDEF( `XGETSCORE', `		
	JSR	FINDJOY		;GET THE JOYSTICK SCORE BYTE
	BNE	CMD8C3
	LDA	SCOREL,Y
	STA	ENEMYLREG,X
	LDA	SCOREH,Y
	STA	ENEMYHREG,X
	RTS
	', )

CMD8E:
IFDEF( `XPUTSCORE', `		
	JSR	FINDJOY		;PUT THE JOYSTICK SCORE BYTE
	BNE	CMD8C3
	LDA	ENEMYLREG,X
	STA	SCOREL,Y
	LDA	ENEMYHREG,X
	STA	SCOREH,Y
	RTS
	', )

CMD8F:	LDA	ENEMYLREG,X	;SWAP REGISTER BYTES
	PHA
	LDA	ENEMYHREG,X
	STA	ENEMYLREG,X
	PLA
	STA	ENEMYHREG,X
	RTS

CMD90: 
IFDEF( `XPEEK', `		
	JSR	GETADDR		;PEEK
	LDA	(SUBSVAR1),Y
	STA	ENEMYLREG,X
	JMP	CLEARHIGH
	', )

CMD91:
IFDEF( `XPOKE', `		
	JSR	GETADDR		;POKE
	LDA	ENEMYLREG,X
	STA	(SUBSVAR1),Y
	RTS
	', )

GETADDR:			;GETS DATA2:DATA1 INTO SUBSVAR1 WORD.
	LDA	DATA1		;ALSO CLEARS Y.
	STA	SUBSVAR1
	LDA	DATA2
	STA	SUBSVAR2
	LDY	#0
CMD912:	RTS

CMD92:	JSR	GETJOY		;MOVE EXECUTE POINTER IF JOYSTICK BITS ARE OFF
	LDA	DATA3
	AND	J1FLAGS,Y	;GET THE SPECIFIED BITS
	BNE	CMD8C3
	JMP	MOVEPTR		;IF SO, MOVE EXECUTE POINTER

CMD93:	LDA	DATA3		;MOVE EXECUTE POINTER IF COUNTER ABOVE
	CMP	ENEMYCNT,X	;ABOVE THE VALUE?
	BCS	CMD8C3
	JMP	MOVEPTR

CMD94:	LDA	ENEMYCENTR,X	;IF EDGE
	BPL	CMD942		;IF LEFT HALF, USE THIS AS DISTANCE
CMD941:	JSR	NEGATE
CMD942:	CMP	DATA3		;NEAR EDGE?
	BCS	CMD8C3
	JMP	MOVEPTR

CMD95:	LDX	#4		;CASE TABLE
	JSR	FILLCBUF	;GET NEXT POSSIBLE ENTRY
	LDX	SAFEBYTE	;RESTORE INDEX
	JSR	INCINC		;WE ALWAYS SKIP AT LEAST 1 WORD
	LDA	CMDBUF
	ORA	DATA1		;SEE IF END OF LIST
	BEQ	CMD912		;IF SO, JUST CONTINUE EXECUTION WITH NEXT
	JSR	INCINC		;SKIP THE REG VALUE TOO
	LDA	DATA2
	CMP	ENEMYLREG,X	;SEE IF FULL WORD MATCH
	BNE	CMD95
	LDA	DATA3
	CMP	ENEMYHREG,X
	BNE	CMD95
	LDA	DATA1
	STA	DATA2
	LDA	CMDBUF
	STA	DATA1
	JMP	MOVEPTR		;IF WE FOUND IT, MOVE THE POINTER

CMD96: 
IFDEF( `XEDGEMOM', `		
	LDA	DATA1		;EDGE ADJUSTED MOMENTUM
	LDY	ENEMYCENTR,X
	BPL	CMD961
	JSR	NEGATE		
CMD961:	STA	DATA1
	LDA	DATA2
	LDY	ENEMYFEET,X
	BPL	CMD962
	JSR	NEGATE
CMD962:	STA	DATA2
	JSR	USEMOM4
	JMP	SEECMDS		;NO MORE COMMANDS IF MOMENTUM CHANGED.
	', )

CMD97:	JSR	DATAINDX		;AND FROM COMMON RAM
	BEQ	CMD975
	LDA	ENEMYLREG,X
	AND	COMMONDATA,Y
	STA	ENEMYLREG,X
	LDA	ENEMYHREG,X
	AND	COMMONDATA+1,Y
	STA	ENEMYHREG,X
	RTS

CMD975:	LDA	ENEMYLREG,X		;IF <STATE> ADD FULL WORD
	AND	STATERAM,Y
	STA	ENEMYLREG,X
	LDA	ENEMYHREG,X
	AND	STATERAM+1,Y
	STA	ENEMYHREG,X
	RTS

CMD98:	LDA	CURWORLD		;STATREQUEST
	STA	SAVEDWORLD		;SAVE THE WORLD
	LDA	STARTCOL
	STA	LEFTCOL
	LDA	STARTCOL+1
	STA	LEFTCOL+1		;SAVE THE CURRENT COLUMN FOR RESUMEING

IFDEF( `BLOCKMODE', `		;BLOCK MODE HAS A Y STARTING OFFSET

	LDA	STARTROW
	STA	TOPROW		;SAVE THE CURRENT ROW FOR RESUMEING

	', )

	LDA	JOYENEMY
	STA	SAVEJOY
	LDA	JOYENEMY+1	;SAVE WHO HAS THE JOYSTICKS
	STA	SAVEJOY+1

	LDA	SELKEY
	STA	SAVESEL
	LDA	SELKEY+1
	STA	SAVESEL+1	;SAVE WHAT SELECT DOES

	LDA	DATA1
	STA	WORLD_REQUEST		;REQUEST THE STATUS WORLD

	LDA	#ECNT-1
	STA	SAFEWORD		;SET LOOP TO HIDE ALL SPRITES
	LDA	#H'F8
	SEC
	SBC	SPYADJ		;MAKE LOCATION TO HIDE THE SPRITE
	STA	SAFEWORD+1
CMD981:	LDX	SAFEWORD
	LDA	ENEMYJSTAT,X
	ORA	#H'20		;SET HIDDEN BIT
	STA	ENEMYJSTAT,X	;PROTECT THIS SPRITE FROM BEING DISPLAYED
	LDA	SAFEWORD
	LDY	SAFEWORD+1
	JSR	PUTSPRT		;HIDE THE SPRITE
	DEC	SAFEWORD	;HIDE THE NEXT ONE
	BPL	CMD981
CMD991:	RTS

CMD99:	LDA	#-1		;END REQUEST WORLD
	STA	SPECGOTO	;SET DOUBLE FLAG TO SIGNAL END OF REQUEST 

	LDA	SAVED1
	STA	DATA1
	LDA	SAVED2
	STA	DATA2
	LDA	SAVED3
	STA	DATA3
	LDA	SAVED4
	STA	DATA4		;SET UP TO RESTORE TOP STATUS LINE
	JSR	INITSTAT	;RESTORE IT

	LDA	SAVEDWORLD
	JMP	CMD0F2		;SHARE <WORLD> CODE

CMD9A:	JSR	INSTAT		;IF REQUEST WORLD
	BEQ	CMD991		;IF SO, MOVE EXECUTE POINTER
	JMP	MOVEPTR

INSTAT:				;RETURNS NZ IF WE ARE IN OR GOING INTO A
				;WORLD VIA STATREQUEST.
	LDA	SAVEDWORLD	;OR IF STATREQUEST WORLD
	CMP	#-1
	RTS

CMD9B:
IFDEF( `XUSERSUB', `		
	LDA	DATA2		;USER SUB
	PHA
	LDA	DATA1
	PHA
	RTS
	', )

CMD9C:	LDA	DATA1		;ROTATION ON OR OFF
	EOR	#OFF		;SET OFF TO 0
	STA	ROTATEFLG
	RTS

CMD9D:
IFDEF( `XLOWEXEC', `		
	LDA	ENEMYCTRL,X	;LOW PRIORITY BIT CONTROL
	AND	#223		;ASSUME ITS OFF
	LDY	DATA1
	CPY	#OFF
	BEQ	CMD9D1
	ORA	#32
CMD9D1:	STA	ENEMYCTRL,X
	', )
CMD9D2:	RTS

CMD9E:	
IFDEF( `XXVIRTUAL', `		
 	LDA	ENEMYCENTR,X	;MOVE IF VIRTUAL X<VALUE
	CLC
	ADC	XBACK
	STA	SAFEWORD
	LDA	XBACK+1
	ADC	#0
	STA	SAFEWORD+1
CMD9E4:	LDA	DATA3		
	SEC
	SBC	SAFEWORD
	LDA	DATA4
	SBC	SAFEWORD+1
	BCC	CMD9D2
	', )
CMD9E5:	JMP	MOVEPTR

CMD9F:
IFDEF( `XYVIRTUAL', `		
 	LDA	ENEMYFEET,X	;MOVE IF VIRTUAL Y<VALUE
	CLC
	ADC	YBACK
	STA	SAFEWORD
	LDA	YBACK+1
	ADC	#0
	STA	SAFEWORD+1
	JMP	CMD9E4
	', )

CMDA0:
IFDEF( `XBVIRTUAL', `		
 	LDA	ENEMYFEET,X	;MOVE IF VIRTUAL Y<VALUE
	CLC
	ADC	YBACK
	STA	SAFEWORD
	LDA	YBACK+1
	ADC	#0
	STA	SAFEWORD+1
	
	LDA	#0
	STA	SAFEX
	LDA	WORLD_HEIGHT

	ASL	A
	ROL	SAFEX
	ASL	A
	ROL	SAFEX
	ASL	A
	ROL	SAFEX		;MAKE HEIGHT IN PIXELS FOR BACKGROUND HEIGHT

	SEC
	SBC	SAFEWORD
	STA	SAFEWORD
	LDA	SAFEX
	SBC	SAFEWORD+1
	STA	SAFEWORD+1	;MAKE COUNT OF PIXELS FROM BOTTOM UP
	JMP	CMD9E4
	', )

CMDA1: 
IFDEF( `XBLOAD', `		
	JSR	DATAINDX	;LOAD BYTE FROM COMMON RAM WITHOUT ZERO HIGH
	LDA	COMMONDATA,Y
	STA	ENEMYLREG,X
	RTS
	', )

CMDA2:
IFDEF( `XLINKMOM', `		
	LDY	ENEMYLINK,X	;GET MOMENTUM OF ENTITY WE ARE LINKED TO
	LDA	ENEMYXMOM,Y
	STA	ENEMYXMOM,X
	LDA	ENEMYYMOM,Y
	STA	ENEMYYMOM,X
	RTS
	', )

CMDA4: 
IFDEF( `XLINKFACE', `		
	LDA	ENEMYJSTAT,X	;LINKED ENTITY FACE CONTROL
	AND	#251		;ASSUME WE FACE DIRECTION OF WHO WE ARE LINKED
	LDY	DATA1
	CPY	#OFF
	BEQ	CMDA41
	ORA	#4		;IF NOT, SET BIT
CMDA41:	STA	ENEMYJSTAT,X
	RTS
	', )

CMDA5:
IFDEF( `XREADCHAR', `		
	LDA	ENEMYX,X	;READ CHAR UNDER CURSOR
	CLC
	ADC	ENEMYLREG,X
	STA	TESTX
	LDA	ENEMYY,X
	CLC
	ADC	ENEMYHREG,X
	STA	TESTY
	JSR	GETCHAR
	LDX	SAFEBYTE
	STA	ENEMYLREG,X
	JMP	CLEARHIGH
	', )


CMDA6:
IFDEF( `XREGLAUNCH', `		
	LDA	DATA2		;REGISTER LAUNCH
	STA	DATA4
	LDA	ENEMYLREG,X
	STA	DATA2
	LDA	ENEMYHREG,X
	STA	DATA3
	JMP	CMD1F
	', )


CMDA7:
IFDEF( `XWHOSTHERE', `		
	LDA	ENEMYX,X	;WHOS THERE
	CLC
	ADC	ENEMYLREG,X
	STA	DATA1
	LDA	ENEMYY,X
	CLC
	ADC	ENEMYHREG,X
	STA	DATA2		;MAKE LOCATIONS TO CHECK

	LDY	#0		;START ENTITY CHECK WITH #0
DA7100:	JSR	VALID2		;MAKE SURE VALID AND NOT US
	BEQ	DA7150		

	LDA	ENEMYY,Y 	;GET ENTITY TO CHECKS TOP EDGE
	SEC
	SBC	#8
	BCS	DA7102
       	LDA	#0
DA7102:	CMP	DATA2		;SEE IF TOP IS ABOVE ATTACK AREA TOP
	BCS	DA7150
	LDA	ENEMYFEET,Y	;IF SO, BOTTOM MUST BE BELOW ATTACK TOP
	CLC
	ADC	#8
	BCC	DA7103
	LDA	#-1
DA7103:	CMP	DATA2
	BCC	DA7150		;IF Y OUT OF RANGE, END	

	LDA	ENEMYX,Y	;Y IS IN RANGE.   REPEAT LOGIC FOR X
	SEC
	SBC	#8
	BCS	DA7104
       	LDA	#0
DA7104:	CMP	DATA1		
	BCS	DA7150
	LDA	ENEMYX,Y
	CLC
	ADC	ENEMYWIDE,Y	
	BCC	DA7132
      	LDA	#-1
DA7132:	CLC
	ADC	#8
	BCC	DA7133
       	LDA	#-1
DA7133:	CMP	DATA1
	BCC	DA7150		
	LDA	ENEMY0,Y
	STA	ENEMYLREG,X
	JMP	CLEARHIGH	;WE FOUND ONE

DA7150:	INY
	CPY	#ECNT		;DONE WITH CHECK?
	BNE	DA7100
	', )

FULLMINUS:
	LDA	#-1		
	STA	ENEMYLREG,X	;RETURN FULL WORD OF -1
	STA	ENEMYHREG,X
	RTS

CMDA8:
IFDEF( `XALIGNXY', `		
	LDA	ENEMYLREG,X	;ALIGN X AND Y
	CLC
	ADC	XBACK
	AND	#7		;GET ODD BITS
	JSR	NEGATE
	CLC
	ADC	ENEMYLREG,X
	STA	ENEMYLREG,X

      	LDA	ENEMYHREG,X	;ALIGN Y
	CLC
	ADC	YBACK
	AND	#7
	JSR	NEGATE
	CLC
	ADC	ENEMYHREG,X
	STA	ENEMYHREG,X
	RTS
	', )

CMDA9:
IFDEF( `XMOVEOVER', `		
	LDA	DATA1		;MOVE OVER
	BNE	CMDA91
	LDA	DATA2
	BNE	CMDA91
	LDA	ENEMYLREG,X
	STA	DATA1
	LDA	ENEMYHREG,X
	STA	DATA2		;IF BOTH ZERO, USE REGISTER
CMDA91:	LDA	ENEMYX,X
	CLC
	ADC	DATA1
	STA	ENEMYX,X
	LDA	ENEMYY,X
	CLC
	ADC	DATA2
	STA	ENEMYY,X
	JSR	FINDLOCS	;UPDATE HEROS FLAGS
	RTS
	', )


;THIS SUB WILL FINISH A TOPSTAT COMMAND (CMD6D) ASSUMING FILLCBUF SET UP
;THE VALUES.  IT SAVES THE 4 BYTES NEEDED TO ACCOMPLISH THIS SO THAT YOU
;CAN RESTORE THEM IN CASE OF ENDREQUEST.  IT ONLY SAVES THEM IF
;INSTAT RETURNS Z.   

INITSTAT:
	JSR	INSTAT		;SEE IF WE SHOULD SAVE THE INFO FOR ENDREQUEST
	BNE	INST10
	LDA	DATA1		;SAVE THESE FOR ENDREQUEST
	STA	SAVED1
	LDA	DATA2
	STA	SAVED2
	LDA	DATA3
	STA	SAVED3
	LDA	DATA4
	STA	SAVED4

INST10:	LDA	#H'F8		;ASSUME NO TOP OF SCREEN STATUS BAR
	STA	PUTBAR		;SET INVISIBLE PLACE TO PUT SPRITE 0
	LDA	DATA1
       	STA	STARTSTAT	;IF DISABLED (LENGTH=0) SET THIS TO 0.
	BEQ	INST12		;AND LEAVE IT.  BUT WE NEED OTHER CALCULATIONS

	LDA	#H'F0		;VIDEO WRAPS AT F0 CAUSE OF PALLETTE INFO
	SEC
	SBC	DATA1		;MAKE STATUS BAR SCROLL START
	STA	STARTSTAT	;SO WE USE THIS AS THE SCROLL VALUE

	LDA	DATA2
	SEC
	SBC	#9		;MAKE THE Y POSITION VALUE FOR THE SPRITE
	STA	PUTBAR	;changed value above, was #9



INST12:	LDA	DATA3
	STA	CUTOFF		;SET SCROLL VALUE FOR AFTER THE STATUS BAR

	LDA	DATA4
	AND	#1
	ASL	A
	ASL	A
	ASL	A
	ASL	A		;GET UPPER/LOWER SET BIT INTO REG2000 POSITION
	ORA	#8		;AND WE ALWAYS USE UPPER FOR SPRITES
	STA	STATBITS
	
	LDA	DATA4
	ROL	A
	ROL	A
	ROL	A		;MOVE SET # UP INTO VIDEO SET NIBBLE
	AND	#H'F0		;KEEP ONLY VIDEO BITS
	JSR	MAKEBANK	;MAKE INDEX AND BANK SELECT VALUE
	STA	STATBANK	;SET THE VALUE TO WRITE TO PAGETAB
	STX	STATINDX	;AND SET THE INDEX TO USE WHEN IN STAT BAR

	LDA	DATA2		;GET SCAN LINES DISPLAYED IN STATUS BAR
	CLC
	SBC	DATA3		;SUBTRACT BACKGROUND CUTTOFF TO 
	STA	SPYADJ		;MAKE SPRITE Y CENTERING AMOUNT

	JSR	TOPSPRITE

	LDA	#H'27
	STA	STATHI
	LDA	#H'C0
	STA	STATLO		;SET UP STATUS BAR LOCATION FOR SUBTRACT

	LDA	DATA1		;GET BACK STARTING SCAN LINE
	CLC
	ADC	#7		;ROUND UP
	AND	#H'F8		;THROW OUT EXTRA
	ASL	A
	ASL	A		;MULTIPLY BY 32
	STA	DATA2
	LDA	STATLO
	SEC
	SBC	DATA2		;MAKE LOCATION OF TOP OF STATUS BAR
	STA	STATLO
	LDA	STATHI
	SBC	#0
	STA	STATHI		;LOCATE THE STATUS BAR	
 	RTS

;THIS ROUTINE WILL TAKE A VIDEO AND PROGRAM ROM BANK VALUE IN A AND
;MAKE THE VALUE AND INDEX TO USE WITH PAGETAB FOR A ROM VERSION.
;A HAS THE VALUE TO WRITE TO PAGETAB AND X HAS THE INDEX.

MAKEBANK:
	TAY			;SAVE THE ORIGINAL VALUE
	AND	#1		;GET JUST THE ROM BIT
	STA	SAFEWORD	;SAVE THEM
	TYA			;GET THE ORIGINAL VALUE
	LSR	A
	LSR	A
	LSR	A		;MOVE HIGH BITS DOWN TO ADD IN LOWEST.
	ORA	SAFEWORD
	TAX			;MAKE IT INTO AN INDEX
	TYA			;GET BACK ORIGINAL VALUE
	ORA	#12		;PUT IN THE KEY CIRCUIT BITS
	RTS

;THIS ROUTINE WILL TAKE A USER JOYSTICK IDENTIFIER IN DATA1 AND PUT
;THE JOYSTICK INDEX INTO Y.  SEE COMMAND 37 FOR THE VALUES.  IF NONE
;EXISTS, NZ ON RETURN.  IF ONE EXISTS, Z AND Y=INDEX 0 OR 1.

FINDJOY:
	LDA	DATA1
	CMP	#2		;CATCH 0 OR 1
	BCC	FJY10
	BNE	FJY5
	LDA	ENEMYJSTAT,X	;IF 2, ITS OUR JOYSTICK
	BPL	FJY8
FJY4:	RTS			;NZ IF -1

FJY5:	LDA	ENEMYATK,X	;IF 3, LAST ATTACKER
	CMP	#-1
	BEQ	FJY4	
	TAY
	LDA	ENEMYJSTAT,Y	;IF HAVE LAST ATTACKER, HE HAS JOYSTICK?
	BMI	FJY4
FJY8:	AND	#H'03

FJY10:	TAY			;HAVE INDEX IN A
	LDA	#0		;SET Z
	RTS	

;THIS SUB WILL POP THE RETURN STACK AND RETURN IF WE ARE NOT IN CHARGE
;OF A JOYSTICK.  OTHERWISE IT PUTS THAT JOYSTICK INDEX IN Y.  IF
;SUCCESS, A AND X ARE NOT CHANGED.

GETJOY:	PHA
	LDA	ENEMYJSTAT,X
	AND	#H'83
	TAY	     	;GET OUR JOYSTICK
	PLA
	CPY	#H'80	;SEE IF ACTIVE
	BCC	GJ10
	PLA
	PLA
GJ10:	RTS

;****** DONE EXECUTING ****************
;WE HAVE TO MAKE SURE THE ENTITY IS STILL ALIVE.  SOME ENTRY
;POINTS WILL HAVE GOTTEN RID OF IT.

ME250: 	LDA	WORLD_REQUEST	;SEE IF WORLD REQUESTED
	BNE	GJ10		;IF SO, DON'T DO GRAVITY.  WORLDGOTO MESSES UP
	LDA	ENEMY0,X
	CMP	#-1
	BNE	ME251
	RTS			;END IF GONE NOW

;EXERT FRICTION ON THE ENTITY.

ME251:	LDA	ENEMYLINK,X	;NO FRICTION IF LINKED ENTITY
	BMI	ME252
	JMP	EF200

ME252:	LDA	#-1
	STA	SAFEX		;SET FLAG OF FRICTION ENABLED
	LDA	ENEMYFLGS,X	;SEE IF FRICTION IS DEPENDANT ON SOLID
	AND	#1
	BNE	EF10		;IF SET, ALWAYS HAVE FRICTION

	LDA	ENEMYSTAT,X	;IF DEPENDANT ON SOLID, ARE WE TOUCHING IT?
	AND	#H'10
	BNE	EF10
	LDA	#0
	STA	SAFEX		;IF NOT, DISABLE FRICTION

EF10:	LDA	ENEMYFCTR,X	;SEE IF WE APPLIED X MOMENTUM RECENTLY
	AND	#H'0F
	BEQ	EF15		;IF NOT, USE FRICTION
	DEC	ENEMYFCTR,X	;IF WE DID, LOWER THE COUNT
	JMP	EF100		;BUT DON'T APPLY FRICTION ON X AXIS

EF15: 	LDA	SAFEX		;SEE IF WE ARE GOING TO HAVE FRICTION
	BEQ	EF100
	LDA	ENEMYXMOM,X
	BEQ	EF100
	BMI	EF30
	SEC
	SBC	ENEMYXFRICT,X
	BEQ	EF19
	BPL	EF20
EF19:	LDA	#1
EF20:	STA	ENEMYXMOM,X	;SET RESULT
	JMP	EF100
EF30:	CLC
 	ADC	ENEMYXFRICT,X
	BMI	EF40
	LDA	#-1		;KEEP A BIT SO WE WILL FACE LEFT.
EF40:	STA	ENEMYXMOM,X	;IF NEGATIVE, MAKE MORE POSITIVE

EF100:	LDA	ENEMYFCTR,X	;SEE IF WE APPLIED Y MOMENTUM RECENTLY
	AND	#H'F0
	BEQ	EF115		;IF NOT, USE FRICTION
	LDA	ENEMYFCTR,X
	SEC
	SBC	#H'10		
	STA	ENEMYFCTR,X	;IF WE DID, LOWER THE COUNT
	JMP	EF200

EF115: 	LDA	SAFEX		;SEE IF WE HAVE FRICTION
	BEQ	EF200
	LDA	ENEMYYMOM,X
	BEQ	EF200
	BMI	EF130
	SEC
	SBC	ENEMYYFRICT,X
	BEQ	EF119
	BPL	EF120
EF119:	LDA	#1
EF120:	STA	ENEMYYMOM,X	;IF PLUS NOW, MAKE MORE NEGATIVE DOWN TO 0.
	JMP	EF200
EF130: 	CLC
	ADC	ENEMYYFRICT,X
	BMI	EF140
	LDA	#-1
EF140:	STA	ENEMYYMOM,X	;IF NEGATIVE, MAKE MORE POSITIVE

;******   APPLY GRAVITY TO THE ENEMY.  ********

EF200:	LDA	ENEMYGRAV,X
	CLC
	ADC	ENEMYYMOM,X
	BVS	ME260
	STA	ENEMYYMOM,X

;APPLY MOMENTUM LIMITS TO THE ENEMY'S MOMENTUM

ME260:	LDY	#0		;SET FLAG OF DIDN'T NEED NEGATE
	LDA	ENEMYXMOM,X	;GET X MOMENTUM
	BPL	ME262
	JSR	NEGATE
	LDY	#1
ME262:	CMP	ENEMYXLIM,X	;SEE IF OVER LIMIT
	BCC	ME264
	LDA	ENEMYXLIM,X
ME264: 	CPY	#0
	BEQ	ME266
	JSR	NEGATE
ME266:	STA	ENEMYXMOM,X

	LDY	#0		;SET FLAG OF DIDN'T NEED NEGATE
	LDA	ENEMYYMOM,X	;GET X MOMENTUM
	BPL	ME272
	JSR	NEGATE
	LDY	#1
ME272:	CMP	ENEMYYLIM,X	;SEE IF OVER LIMIT
	BCC	ME274
	LDA	ENEMYYLIM,X
ME274: 	CPY	#0
	BEQ	ME276
	JSR	NEGATE
ME276:	STA	ENEMYYMOM,X

;NOW MOVE THE ENEMY ACCORDING TO HIS MOMENTUM.  

	LDA	ENEMYLINK,X	;LINKED ENEMY?
	BMI	ME290
	JSR	PUTLINK		;IF ITS LINKED, SEPERATE LOGIC FOR IT
	JMP	FE100

ME290:	LDA	ENEMYYMOM,X
	BPL	ME291
      	JSR	NEGATE		;IF NEGATIVE, MAKE + FOR SHIFT
ME291:	JSR	DIV8
	STA	SAFEX		;NEED ABSOLUTE VALUE FOR LATER
	LDY	ENEMYYMOM,X	;SEE IF WE ADJUSTED FOR NEGATIVE
	BPL	ME292
	JSR	NEGATE

;NOW HAVE Y MOVEMENT DESIRED.  BUT WE NEED TO CASE SPECIAL CASE OF ENTITIES
;THAT AREN'T ALLOWED TO GO ABOVE TOP OR BELOW BOTTOM.

ME292:	STA	SAFEY
	LDA	ENEMYFLGS,X	;SEE IF CAN'T GO ABOVE TOP OR BELOW BOTTOM
	AND	#H'28
	BEQ	ME293
	LDA	SAFEY		;IF SO, GET AMOUNT TO MOVE
	BPL	ME292A		;HANDLE IT DIFFERENTLY IF +

	LDA	ENEMYY,X	;ASSUME ITS CONDITION HEAD CAN'T MOVE UP
	STA	SAFEWORD
	LDA	ENEMYFLGS,X
	AND	#H'20		;IS IT THE HEAD?
	BNE	ME292D
	LDA	ENEMYFEET,X
	STA	SAFEWORD	;IF NOT, ITS THE FEET

ME292D:	LDA	SAFEX		;GET ABSOLUTE VALUE OF MOVE
	CMP	SAFEWORD	;SEE IF TOO MUCH
	BCC	ME293
	LDA	SAFEWORD
	STA	SAFEX
	JSR	NEGATE
	JMP	ME292C		;USE MAX IF TOO MUCH

ME292A:	CLC
	ADC	ENEMYFEET,X	;IF PLUS MOVEMENT, ADD IT TO THE FEET
	BCS	ME292B
	CMP	#239
	BCC	ME293		;DON'T ALLOW BELOW 239
ME292B:	LDA	#239
	SEC
	SBC	ENEMYFEET,X	;MOVE MAX THAT GETS US TO THE BOTTOM
	STA	SAFEX
ME292C:	STA	SAFEY

;NOW BREAK THAT Y MOVEMENT UP INTO 2 CHUNKS IN CASE ITS LARGER THAN 8.
;THE ABSOLUTE VALUE IS IN SAFEX.

ME293: 	LDA	SAFEY
	STA	SAFEY2		;SAVE FIRST AMOUNT TO MOVE
	LDA	#0
	STA	SAFEY		;SET SECOND AMOUNT TO MOVE AS 0
	LDA	SAFEX
	SEC
	SBC	#8
	BCC	ME190		;IF NOT ABOVE 8, ITS OK AS IS
	BEQ	ME190
	STA	SAFEY
	LDA	#8
	STA	SAFEY2		;SET THE TWO AMOUNTS TO MOVE
	LDA	ENEMYYMOM,X	;SEE IF NEED NEGATE
	BPL	ME190
	LDA	SAFEY
	JSR	NEGATE
	STA	SAFEY
	LDA	SAFEY2
	JSR	NEGATE
	STA	SAFEY2		;MAKE THE CORRECT DIRECTION IF NEGATIVE

;NOW MAKE THE DESIRED X MOVEMENT.  AGAIN, IF MORE THAN 8 PIXELS WE HAVE
;TO BREAK IT UP INTO 2 MOVEMENT AMOUNTS.  ALSO, WE DON'T ALLOW SOME ENEMIES
;TO MOVE RIGHT OFF THE VISUAL SCREEN.

ME190: 	LDA	#0
	STA	SAFEX		;ASSUME THE SECOND MOVEMENT IS 0
	LDA	ENEMYXMOM,X
	BPL	ME294
	JSR	NEGATE
	JSR	DIV8	;MAKE /8 VALUE
	LDX	#H'FF	;SET FLAG OF WE HAD TO NEGATE IT.
	JMP	ME294A
ME294:	JSR	DIV8	;MAKE ACTUAL MOVEMENT
	STA	SAFEX2	;SAVE HERE FOR CAN'T MOVE RIGHT OFF SCREEN FLAG
	LDA	ENEMYFLGS,X
	AND	#H'10	;CAN'T MOVE RIGHT OFF VISUAL SCREEN?
	BEQ	ME191
	LDA	ENEMYX,X	;SEE IF WE ARE ANYWHERE NEAR RIGHT SIDE
	BPL	ME191		;IF NOT, DON'T BOTHER WITH CHECK
	JSR	NEGATE		;MAKE DISTANCE TO RIGHT
	SEC
	SBC	ENEMYWIDE,X	;MAKE PIXELS TO RIGHT OF HERO
	BCS	ME192
      	LDA	#0
	STA	SAFEX2		;IF ERROR, ZERO AMOUNT TO MOVE
ME192:	CMP	SAFEX2		;MAKE SURE ITS MORE THAN ENOUGH
	BCS	ME191
	STA	SAFEX2		;IF NOT, USE WHAT WE HAVE LEFT
ME191: 	LDX	#0	;SET FLAG OF DIDN'T HAVE TO NEGATE IT
	LDA	SAFEX2	;GET BACK AMOUNT TO MOVE

ME294A:	STA	SAFEX2	;PUT IT HERE AS THE FIRST CHUNK TO MOVE
	SEC
	SBC	#8	
	BCC	ME294B		;IF NOT ABOVE 8, ITS OK AS IS
	BEQ	ME294B
	STA	SAFEX
	LDA	#8
	STA	SAFEX2		;SET THE TWO AMOUNTS TO MOVE
ME294B:	CPX	#0		;SEE IF NEED NEGATE
	BEQ	ME295
	LDA	SAFEX
	JSR	NEGATE
	STA	SAFEX
	LDA	SAFEX2
	JSR	NEGATE
	STA	SAFEX2		;MAKE THE CORRECT DIRECTION IF NEGATIVE

;RESET THE BITS THAT SIGNAL WE MOVED ON AN AXIS.  THEY ARE NEEDED FOR
;BOUNCING.

ME295: 	LDX	SAFEBYTE	;GET ENEMY INDEX
	LDA	ENEMYSTAT,X	;GET MOVEMENT BITS FOR X AND Y
	LDY	SAFEY2
	BNE	MEY3
	AND	#H'FE		;IF Y VELOCITY 0, RESET Y MOVED BIT  
MEY3:	LDY	SAFEX2		;NOW CHECK X FOR 0
	BNE	MEY4
	AND	#H'FD		;IF X IS 0, RESET X MOVED BIT
MEY4:	STA	ENEMYSTAT,X

;WE HAVE THE DESIRED X AND Y MOVEMENTS.  IF THERE WAS MORE THAN 8 PIXELS
;TO MOVE WE BROKE IT UP INTO 2 MOVEMENTS IN SAFEX AND SAFEX2 (OR SAFEY).
;IF WE TRIED TO MOVE MORE THAN 8 IN A PASS WE'D MISS 1 HIGH SOLIDS.

MEY32:	LDX	SAFEX2
	LDY	SAFEY2
	TXA
	ORA	SAFEY2		;END IF NOTHING TO MOVE
	BNE	MEY6
	JMP	MEY50

MEY6:	JSR	MOVESET
	BNE	MEY10		;IF IT WOULDN'T MOVE, GO DO IT PIXEL WISE
	LDA	SAFEX2		;SEE IF REAL X MOVEMENT
	BEQ	MEY5
	JSR	REALXMOVE	;SET FLAG FOR REAL X MOVEMENT
MEY5:	LDA	SAFEY2
	BEQ	MEY7
	JSR	REALYMOVE	;AND FOR Y IF APPLICABLE
	LDA	ENEMYSTAT,X
	AND	#H'EF
	STA	ENEMYSTAT,X	;RESET CONTACTED SOLID BIT
MEY7: 	LDA	SAFEY
	STA	SAFEY2
	LDA	SAFEX
	STA	SAFEX2
	LDA	#0
	STA	SAFEX
	STA	SAFEY
	JMP	MEY32

;ENEMY WOULD NOT MOVE.  MOVE X AS FAR AS POSSIBLE.  WE HAVE TWO AMOUNTS
;LEFT TO MOVE IN SAFEX2 AND SAFEX.

MEY10:	LDX	SAFEX2
	BEQ	MEY20
	LDY	#0
	JSR	MOVESET		;TRY TO MOVE JUST THE X
	BNE	MEY12
	JSR	REALXMOVE	;SET FLAG TO SIGNAL WE DID FOR BOUNCE
 	LDA	SAFEX
	STA	SAFEX2		;MOVE THE SECOND AMOUNT UP
	LDA	#0
	STA	SAFEX		;ZERO THE SECOND AMOUNT
	JMP	MEY10

MEY12:	LDA	ENEMYSTAT,X	;IF WE NEED TO BOUNCE, SEE IF WE MOVED BEFORE
	AND	#2
	BNE	MEY13		;IF SO, MAKE BOUNCE FACTOR.
	LDA	ENEMYXMOM,X	;IF NOT, WE WANT TO ZERO BUT PRESERVE SIGN
	AND	#H'80
	BEQ	MEY13B
	LDA	#-1
	JMP	MEY13B

MEY13:	LDA	ENEMYXMOM,X	;GET OLD MOMENTUM
	JSR	MAKEMOM		;FIX IT FOR BOUNCE FACTOR
MEY13B:	STA	ENEMYXMOM,X	;REVERSE THE X MOMENTUM, WE HIT SOLID
	
MEY15: 	LDA	SAFEX2		;GET CURRENT VALUE
	ROL	A
	LDA	SAFEX2
	ROR	A		;DO SIGNED DIVIDE BY 2
	STA	SAFEX2		;SET FOR NEXT TIME
	TAX			;AND WE'LL TRY TO MOVE THAT AMOUNT
	BNE	MEY17
	INX			;BUT DON'T MOVE 0
MEY17:	LDY	#0
	JSR	MOVESET	
	BNE	MEY18
	JSR	REALXMOVE
	JMP	MEY15		;IF DIDN'T HIT, CONTINUE

MEY18:	LDA	SAFEX2
	BEQ	MEY20		;IF WE TRIED 1 AND COULDN'T, DONE
	CMP	#-1		;OR IF WE TRIED -1
	BNE	MEY15
	
;MOVE Y AS FAR AS POSSIBLE

MEY20:	LDY	SAFEY2
	BEQ	MEY50
	LDX	#0
	JSR	MOVESET		;TRY TO MOVE JUST THE Y
	BNE	MEY22
	JSR	REALYMOVE	;SET FLAG FOR BOUNCE THAT WE DID MOVE SOME
 	LDA	SAFEY
	STA	SAFEY2		;MOVE THE SECOND AMOUNT UP
	LDA	#0
	STA	SAFEY		;ZERO THE SECOND AMOUNT
	JMP	MEY20

MEY22:	LDA	SAFEY2		;SEE IF IT WAS + ON Y (DOWN)
	BMI	MEY23
	LDA	ENEMYSTAT,X
	ORA	#H'10		;SET STANDING BIT
	STA	ENEMYSTAT,X	
MEY23:	LDA	ENEMYSTAT,X	;IF WE NEED TO BOUNCE, SEE IF WE MOVED BEFORE
	AND	#1
	BNE	MEY24		;IF SO, MAKE BOUNCE FACTOR.
	LDA	ENEMYYMOM,X	;IF NOT, WE WANT TO ZERO BUT PRESERVE SIGN
	AND	#H'80
	BEQ	MEY24B
	LDA	#-1
	JMP	MEY24B

MEY24:	LDA	ENEMYYMOM,X	;GET OLD MOMENTUM
	JSR	MAKEMOM		;FIX IT FOR BOUNCE FACTOR
MEY24B:	STA	ENEMYYMOM,X	;REVERSE THE X MOMENTUM, WE HIT SOLID
	
MEY25:	LDA	SAFEY2		;GET CURRENT VALUE
	ROL	A
	LDA	SAFEY2
	ROR	A		;DO SIGNED DIVIDE BY 2
	STA	SAFEY2		;SAVE FOR NEXT TIME
	TAY			;AND WE'LL TRY TO MOVE THAT AMOUNT
	BNE	MEY27
	INY			;BUT DON'T LET CARRY GO OUT
MEY27:	LDX	#0
	JSR	MOVESET	
	BNE	MEY28
	JSR	REALYMOVE
	JMP	MEY25		;IF DIDN'T HIT, CONTINUE

MEY28:	LDA	SAFEY2
	BEQ	MEY50		;ZERO IS 1 FROM ABOVE, IF WE COULDN'T: DONE.
	CMP	#-1		;AND ALSO DONE IF -1 WOULDN'T MOVE.
	BNE	MEY25
	
;DONE MOVING ENEMY. SET THE DIRECTION THE ENEMY FACES.  

MEY50:	JSR	USEFACE
	JSR	MIRRORINVERT

;CHECK FOR A NEW WORLD COLUMN TO TEST.

FE100:	LDX	SAFEBYTE
	LDA	ENEMYFLGS,X
	BPL	ME350		;SKIP IF THIS ENTITY DOESN'T CHECK COLUMNS
	JSR	MAKE_ECOL	;MAKE THIS ENTITIES COLUMN
	LDA	SAFEWORD
	CMP	ENEMYLTST,X	;SEE IF LAST COLUMN MATCHES IT
	BNE	ME340		;IF NOT, WE NEED TEST AGAIN
	LDA	SAFEWORD+1
	CMP	ENEMYHTST,X
	BNE	ME340
	LDA	SAFEY
	CMP	ENEMYLROW,X	;SEE IF LAST ROW MATCHES IT
	BEQ	ME350		;IF IT DOES, DON'T TEST AGAIN

ME340:	LDA	SAFEWORD
	STA	ENEMYLTST,X	;SET AS ONE WE JUST TESTED
	LDA	SAFEWORD+1
	STA	ENEMYHTST,X
	LDA	SAFEY
	STA	ENEMYLROW,X	;AND SET ROW TOO
	JSR	TESTFLGS	
ME350:	RTS

;THIS SUB WILL CORRECTLY MIRROR OR INVERT THE ENTITY SAFEBYTE ACCORDING
;TO ITS FACE BITS.  IT USES ENEMYFACE:

;				<CURRENT> (H'80) FOR NO CHANGE
;				<TRAVELING> (H'40) LEFT/RIGHT TRAVEL DIRECTION
;				<RISING> (H'20) UP/DOWN TRAVEL DIRECTION
;				<JOYDIR> (H'10) JOYSTICK LEFT/RIGHT DIRECTION
;				<UP> (8) TO TURN THE SPRITE UPSIDE DOWN
;				<DOWN> (4) TO REVERT THE SPRITE TO THE WAY IT
;				<LEFT> (2) TO MIRROR THE SPRITE AND LOCK IT
;				<RIGHT> (1) TO FACE RIGHT
USEFACE:
	LDX	SAFEBYTE
	LDA	ENEMYFACE,X	;GET DIRECTION FLAG
	BPL	UFE20
	JMP	UFE100

UFE20:	TAY			;KEEP A COPY
	AND	#H'40		;SEE IF DIRECTION OF TRAVEL
	BNE	UFE40
	TYA			;GET BACK A COPY
	AND	#H'10		;JOYSTICK DIRECTION?
	BNE	UFE30
	TYA
	AND	#3		;GET LEFT/RIGHT BITS
	BEQ	UFE60		;IF NEITHER, LEAVE X AXIS ALONG
	LSR	A
	JMP	UFE50		;IF NONE OF ABOVE, USE LEFT BIT

;JOYSTICK DIRECTION.

UFE30:	LDY	ENEMYLINK,X	;SEE IF WE ARE LINKED TO SOMEONE
	BMI	UFE31	
	LDA	ENEMYJSTAT,Y	;IF SO, USE THEIR JOYSTICK DIRECTION BIT
	JMP	UFE32
UFE31:	LDA	ENEMYJSTAT,X	;IF JOYSTICK DIRECTION, GET STAT BIT
UFE32:	AND	#H'10
	BNE	UFE45
     	LDA	#0		;RIGHT IF NOT SET
	JMP	UFE50

UFE40:	LDA	#0		;ITS THE MOMENTUM DIRECTION
	LDY	ENEMYXMOM,X	;GET MOMENTUM FOR HORIZONTAL TRAVEL
	BPL	UFE50
UFE45:	LDA	#1		;IF NEGATIVE MOMENTUM, MIRROR ENEMY
UFE50: 	ASL	ENEMYTRACK,X
	ROR	A
	ROR	ENEMYTRACK,X	;MOVE THE BIT INTO BIT H'80 OF ENEMYTRACK

UFE60:	LDX	SAFEBYTE	;NOW CHECK Y DIRECTION.
	LDA	ENEMYFACE,X
	TAY			;KEEP A COPY
	AND	#H'20		;SEE IF DIRECTION OF TRAVEL UP AND DOWN
	BNE	UFE80
	TYA
	AND	#H'0C		;GET UP/DOWN BITS
	BEQ	UFE99		;IF NEITHER, LEAVE Y AXIS ALONG
	JSR	DIV8
	JMP	UFE90		;OTHERWISE, USE UP BIT

UFE80:	LDA	#0		;ITS THE MOMENTUM DIRECTION
	LDY	ENEMYYMOM,X	;GET MOMENTUM FOR VERTICAL TRAVEL
	BPL	UFE90
UFE85:	LDA	#1		;IF NEGATIVE MOMENTUM, INVERT ENEMY
UFE90: 	CLC
	ROR	A
	ROR	A
	ROR	A		;MOVE THE BIT INTO BIT H'40 
	STA	SAFEWORD
	LDA	ENEMYTRACK,X
	AND	#H'BF
	ORA	SAFEWORD
	STA	ENEMYTRACK,X	;SET DIRECTION WE ARE FACING
UFE99:	RTS

;CALL HERE TO MIRROR OR INVERT ACCORDING TO THE ENEMYTRACK BITS.
;X RETURNS SAFEBYTE

MIRRORINVERT:

	LDX	SAFEBYTE
	LDA	ENEMYTRACK,X
	AND	#H'80
	TAX
	LDA	SAFEBYTE
	JSR	MIRROR
	LDX	SAFEBYTE
	LDA	ENEMYTRACK,X
	AND	#H'40
	TAX
	LDA	SAFEBYTE
	JSR	INVERT
	LDX	SAFEBYTE
UFE100:	RTS

;THIS SUB WILL MAKE THE SCREEN COLUMN THAT THE ENTITY IN X IS 
;CURRENTLY ON AND RETURN IT IN SAFEWORD (WORD).  IT RETURNS THE ROW
;THAT THE ENTITY'S FEET ARE CURRENTLY ON IN SAFEY (BYTE).

MAKE_ECOL:
	LDA	ENEMYCENTR,X	;GET ENEMIES CENTER LINE
	CLC
	ADC	XBACK
	STA	SAFEWORD
	LDA	XBACK+1
	ADC	#0	
	STA	SAFEWORD+1
	LSR	SAFEWORD+1
	ROR	SAFEWORD
	LSR	SAFEWORD+1
	ROR	SAFEWORD
	LSR	SAFEWORD+1
	ROR	SAFEWORD
	LDA	ENEMYFEET,X
	JSR	DIV8
	STA	SAFEY		;SET ROW HE'S ON
	RTS

REALXMOVE:		;CALL HERE TO SET THE X MOVED BIT IN ENEMYSTAT.
	LDA	ENEMYSTAT,X
	ORA	#2
	STA	ENEMYSTAT,X
	RTS

REALYMOVE:		;CALL HERE TO SET THE Y MOVED BIT IN ENEMYSTAT.
	LDA	ENEMYSTAT,X
	ORA	#1
	STA	ENEMYSTAT,X
	RTS

;THIS ROUTINE WILL POSITION AN ENTITY THAT IS LINKED TO ANOTHER ENTITY
;AND CORRECTLY MIRROR/INVERT IT.  YOU MUST MAKE SURE IT IS LINKED
;(ENEMYLINK <> -1).  SAFEBYTE MUST HAVE ITS INDEX.  IF THE ENTITY TO
;WHICH YOURS IS LINKED DIES YOUR ENTITY WILL UNLINK.

PUTLINK:
	LDX	SAFEBYTE
	LDY	ENEMYLINK,X
	JSR	VALID		;MAKE SURE ITS STILL ALIVE
	BNE	PLN5
     	STA	ENEMYLINK,X	;IF NOT, UNLINK US
	RTS

;SEE IF WE ARE GOING TO USE OUR OWN FACE FLAG OR DO IT FROM THE
;ONE WE ARE LINKED TO.

PLN5: 	LDA	ENEMYJSTAT,X	;SEE IF IT HONORS FACE BITS ANYWAY
	AND	#4
	BEQ	PLN6

;WE ARE CALCULATING OFF OUR OWN BITS.

	JSR	USEFACE		;USE ITS OWN FACE FLAG
	JMP	PLN7

;WE ARE CALCULATING OFF THE ENTITY WE ARE LINKED TO.

PLN6:	LDA	ENEMYTRACK,Y	;GET ONE ITS LINKED TO'S DIRECTION BITS
	AND	#H'C0
	STA	SAFEWORD
	LDA	ENEMYTRACK,X
	AND	#H'3F
	ORA	SAFEWORD
	STA	ENEMYTRACK,X	;SET AS OUR DIRECTION BITS

PLN7:	JSR	MIRRORINVERT	;USE THE BITS WE CREATED

	LDY	ENEMYLINK,X
	LDA	ENEMYTRACK,Y	;GET ONE TO WHOM WE ARE LINKED'S BITS
	STA	SAFEWORD
	ROL	A		;MOVE MIRROR BIT INTO CARRY
	LDA	ENEMYXFRICT,X	;GET OUR RELATIVE X
	BCC	PLN10
	JSR	NEGATE		;NEGATE IT IF MIRRORED
	CLC
	ADC	ENEMYWIDE,Y	;AND CORRECT FOR HIS WIDTH
	SEC
	SBC	ENEMYWIDE,X	;AND CORRECT FOR OUR WIDTH
PLN10:	CLC
	ADC	ENEMYX,Y	;POSITION OUR X RELATIVE TO HIS
	STA	ENEMYX,X	;SET OUR NEW X POSITION

	LDA	ENEMYYFRICT,X	;GET OUR RELATIVE Y
	ROL	SAFEWORD
	ROL	SAFEWORD	;GET UPSIDE DOWN BIT
	BCC	PLN20
	JSR	NEGATE		;IF UPSIDE DOWN, INVERT OUR RELATIVE Y
	CLC
	ADC	ENEMYHIGH,Y	;AND CORRECT FOR HIS HEIGHT
	SEC
	SBC	ENEMYHIGH,X
PLN20:	CLC
	ADC	ENEMYY,Y
	STA	ENEMYY,X	;SET OUR NEW Y
	JSR	FINDLOCS
	RTS

;THIS ROUTINE WILL TAKE A MOMENTUM VALUE IN A AND APPLY THE BOUNCE FACTOR
;TO IT AND REVERSE ITS DIRECTION.  IT RETURNS THE RESULT IN A.  
;IT USES SAFEWORD.  X AND SAFEBYTE MUST HAVE THE ENEMY INDEX.
;IF THE BOUNCE IS SET TO ZERO, IT WILL PRESERVE THE SIGN OF THE OLD
;MOMENTUM BUT SET IT TO -1 OR 0.

MAKEMOM:
	STA	SAFEWORD+1	;SAVE ORIGINAL VALUE HERE FOR SIGN CHECK
	BPL	MM5
	JSR	NEGATE
MM5:	STA	SAFEWORD	;SAVE ABSOLUTE VALUE HERE
	LDA	ENEMYBOUNCE,X	;GET BOUNCE
	BEQ	MM20		;CATCH SPECIAL CONDITION OF 0 TO SAVE TIME
	TAX			;GET BOUNCE FACTOR HERE
	LDY	SAFEWORD	;MULTIPLY BY ABSOLUTE VALUE
	INX			;INCREASE BOUNCE FACTOR AS PROMISED
	BEQ	MM6
	JSR	MUL
MM6:	TYA			;THEN DIVIDE BY 256
	LDY	SAFEWORD+1	;SEE IF WE NEED SIGN REVERSAL
	BMI	MM10
	JSR	NEGATE		;REVERSE SIGN OF ORIGINAL AMOUNT
MM10: 	LDX	SAFEBYTE
	RTS

MM20:	LDA	SAFEWORD+1	;IF NO BOUNCE, GET SIGN TO PRESERVE IT
	AND	#H'80
	BEQ	MM10
	LDA	#-1
	JMP	MM10

;CALL HERE WITH DATA1 AND DATA2 TO APPLY IT TO THE ENTITIES X AND Y MOMENTUM 
;CHANGES. IT WILL SIGN CORRECT FOR THE TRACKING DIRECTION BUT WILL
;NOT LIMIT IT OR APPLY GRAVITY.  IT PREVENTS OVERFLOW AND IT SETS THE 
;STATUS BITS THAT FRICTION USES AND DETECTS.  ENTITY INDEX SHOULD BE 
;IN SAFEBYTE ON ENTRY.  THIS ROUTINE USES SAFEX AND SAFEY AND SAFEX2.

;IN REPLACEMENT MODE, -1 WILL MEAN DON'T CHANGE THE OLD VALUE.

USEMOM:				;CALL HERE FOR ADD TO MOMENTUM WITH SIGN 
	LDA	#0		;CORRECTION ACCORDING TO TRACKING.
	JMP	USM5

USEMOM2:	     		;CALL HERE FOR REPLACE MOMENTUM WITH SIGN
	LDA	#H'80		;CORRECTION ACCORDING TO TRACKING.
	JMP	USM5

USEMOM3:			;CALL HERE FOR REPLACE MOMENTUM WITHOUT 
	LDA	#H'C0		;TRACKING.
	JMP	USM5

USEMOM4:			;CALL HERE FOR ADD MOMENTUM WITHOUT TRACKING.
	LDA	#H'40
	
USM5:	STA	SAFEX2		;SET CONDITION OF ADJUSTMENT FLAGS.
				;80H = REPLACE, 40H=DON'T TRACK
	LDX	SAFEBYTE
	LDA	ENEMYFCTR,X	;GET STATUS BITS
	LDY	DATA1
	STY	SAFEX		;SAVE IT HERE IN CASE OF REPLACE
	BEQ	USM10
	AND	#H'F0		;REMOVE COUNTER ON DELAY TO FRICTION ON
	ORA	#XFCTR
USM10:	LDY	DATA2
	STY	SAFEY		;SAVE HERE IN CASE OF REPLACE
	BEQ	USM20
	AND	#H'0F		;REMOVE Y COUNTER VALUE
	ORA	#YFCTR*16
USM20:	STA	ENEMYFCTR,X

	LDA	SAFEX2		;SEE IF TRACKING DESIRED
	AND	#H'40
	BNE	USM44

	JSR	TRACKDIR	;SEE WHAT THE TRACKING DIRECTION CORRECTION IS
	BPL	USM42		;IF PLUS, VALUE IS OK	
	LDA	DATA1
	JSR	NEGATE
	STA	DATA1
USM42: 	LDA	SUBSVAR5	;GET BACK TRACKDIR
	AND	#1
	BEQ	USM44
	LDA	DATA2
	JSR	NEGATE
	STA	DATA2

USM44:	LDA	SAFEX2		;TIME TO UPDATE.  GET ADD OR REPLACE BIT
	BPL	USM50

	LDA	SAFEX
	CMP	#-1
	BEQ	USM45
	LDA	DATA1
	STA	ENEMYXMOM,X
USM45:	LDA	SAFEY
	CMP	#-1
	BEQ	USM47
	LDA	DATA2
	STA	ENEMYYMOM,X	;DO REPLACEMENT IF SO SPECIFIED
USM47:	RTS

USM50:	LDA	DATA1
	CLC
	ADC	ENEMYXMOM,X
	BVS	USM55
	STA	ENEMYXMOM,X	;IF NO OVERFLOW, USE NEW VALUE

USM55:  LDA	DATA2
	CLC
	ADC	ENEMYYMOM,X
	BVS	USM65
	STA	ENEMYYMOM,X	
USM65:	RTS

;THIS ROUTINE WILL TAKE AN ENEMY INDEX IN SAFEBYTE AND AN ANIMATION INDEX
;IN A AND WILL SETUP UP THE ANIMATION, DO ITS INIT OPTIONS, GET ITS
;AUXILARY FLAG, AND SET THE EXECUTE POINTER.  ON RETURN, EVERYTHING
;IS SETUP UP UNLESS THERE WAS NO ROOM TO INITIALIZE THE ANIMATION.
;IF THAT WAS THE CASE, THIS ROUTINE RETURNS NZ.  IF Z, SUCCESS.

;ON ENTRY, ENEMYX AND ENEMYY MUST HAVE YOUR DESIRED X, Y COORDINATE TO
;PUT THE ENEMY DOWN.  THIS ROUTINE WILL ATTEMPT TO PREVENT PUTTING DOWN
;ON TOP OF SOLID IN A HORIZONTAL DIRECTION.  ENEMYCENTR
;MUST HAVE THE CENTER OF THE LAST ANIMATION THIS ENEMY WAS USING OR 0
;IF YOU ARE STARTING OUT WITH A COMPLETELY NEW ONE.  THIS ROUTINE WILL
;"CENTER" THE ENEMY IF THE NEW WIDTH IS DIFFERENT.  SETUPFLG MUST BE SET
;AS DESCRIBED BELOW.

;THIS ROUTINE SETS ENEMYPTR TO THE NEW INDEX BECAUSE SOME CALLERS
;EXPECT THAT TOO.  SAFEWORD IS USED.

;YOU MAY USE THIS ROUTINE TO PICK AN ANIMATION ONLY (AND OPTIONALLY ITS
;DAMAGE FLAGS) BY SETTING SETUPFLG:
;0 = USE ALL INFORMATION FROM THE TABLE
;1 = USE JUST THE ANIMATION, NO DAMAGE FLAGS OR MOVEMENT TABLE.
;2 = USE THE ANIMATION, DAMAGE FLAGS, NOT THE MOVEMENT TABLE.

SETUPANIM:
	PHA			;SAVE INDEX INTO THE ANIMATION LIST
	JSR	POINTENEMY
SETUPA2:
	LDY	#0
	LDA	(SUBSVAR1),Y
	PHA
	INY
	LDA	(SUBSVAR1),Y
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;MAKE POINTER TO THE ANIMATION LIST
	PLA
	CLC
	ADC	SUBSVAR1
	STA	SUBSVAR1
	LDA	SUBSVAR2
	ADC	#0
	STA	SUBSVAR2	;MAKE DIRECT POINTER TO THE ANIMATION ENTRY

;CALL HERE WITH (SUBSVAR1) POINTING TO THE ANIMATION/MOVEMENT ENTRY TO USE.

SETUP2:	LDA	ENEMYPTR
	PHA
	LDA	ENEMYPTR+1
	PHA
	LDA	SUBSVAR1
	STA	ENEMYPTR
	LDA	SUBSVAR2
	STA	ENEMYPTR+1
	LDX	#10
	JSR	FILLCBUF	;ALLOW THE DATA TO BE IN ANY PAGE
	PLA
	STA	ENEMYPTR+1
	PLA
	STA	ENEMYPTR	;BUT PRESERVE THE NEEDED ENEMYPTR
	JSR	POINT_CMDBUF	;POINT TO THE DATA WE GOT	

	LDX	SAFEBYTE
	LDY	#3
	LDA	SETUPFLG	;DON'T USE THE MOVEMENT TABLE AT ALL?
	BNE	SAM2
	LDA	(SUBSVAR1),Y	;GET EXECUTE INDEX HIGH
	CMP	#-1		;IS IT THE DON'T CHANGE FLAG?
	BEQ	SAM2
	DEY
	STA	ENEMYINH,X
	STA	ENEMYPTR+1
	LDA	(SUBSVAR1),Y
	STA	ENEMYINL,X	;SET INTO STORAGE
	STA	ENEMYPTR	;SET HERE FOR SOME CALLERS AS PROMISED

	
SAM2: 	LDY	#1		;SEE IF WE ARE GOING TO USE THE ANIMATION
	LDA	(SUBSVAR1),Y
	CMP	#-1		;-1 MEANS WE ARE NOT
	BNE	SAM3
	JMP	SAM40		;SKIP REST IF NOT
SAM3: 	LDY	#4
	LDA	(SUBSVAR1),Y
	STA	SAFEWORD	;SAVE INIT OPTIONS HERE

	LDA	SETUPFLG	;SEE IF WE WANT THE DAMAGE FLAGS OR NOT
	CMP	#1
	BEQ	SAM4		;1 = DON'T USE THEM

	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #1
	STA	ENEMYD1,X
	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #2
	STA	ENEMYD2,X
	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #3
	STA	ENEMYD3,X
	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #4
	STA	ENEMYD4,X
	INY
	LDA	(SUBSVAR1),Y	;GET DAMAGE FLAG #5
	STA	ENEMYD5,X

	LDA	ENEMYSTAT,X	;GET STATUS BITS
	ORA	#H'28
	EOR	#8		;RESET THE WE ATTACKED SOMEONE BIT
	STA	ENEMYSTAT,X	;REARM ATTACK, ITS A NEW ANIMATION

SAM4:	LDY	#0
	LDA	(SUBSVAR1),Y
	STA	EXTRA_PTR
	PHA			;SAVE COPY
	INY
	LDA	(SUBSVAR1),Y
	STA	EXTRA_PTR+1	;GIVE OURSELVES ACCESS TO THE ANIMATION INFO
	STA	SUBSVAR2	;PUT RESULTING ANIMATION HERE
	PLA
	STA	SUBSVAR1	;NOW SUBSVAR1 HAS INIT PTR FOR INITSPRT.

	LDY	#0
	LDA	(EXTRA_PTR),Y	
	CMP	#83		;ASCII "S"?
	BNE	SAM5		;IF NOT, IT WAS A SIMPLE SPRITE.

	LDY	#3		;OTHERWISE ITS AN ANIMATION.
	LDA	(EXTRA_PTR),Y
	PHA
	INY
	LDA	(EXTRA_PTR),Y
	STA	EXTRA_PTR+1	;SET A POINTER TO THE FIRST ANIMATION FRAME
	PLA
	STA	EXTRA_PTR

SAM5: 	LDY	#0
	LDA	(EXTRA_PTR),Y	;GET DOUBLE BIT
	ROL	A		;MOVE IT INTO THE CARRY
	LDY	#2
	LDA	(EXTRA_PTR),Y	;GET HEIGHT OF ANIMATION IN CELLS
	BCC	SAM5A	
	ASL	A		;DOUBLE BECAUSE HE'S 2 BY 2 MODE
SAM5A:	JSR	TIMES8
	LDY	ENEMYHIGH,X	;GET OLD HEIGHT
	STA	ENEMYHIGH,X	;SAVE HEIGHT IN PIXELS
	TYA
	BEQ	SAM5B
	SEC
	SBC	ENEMYHIGH,X	;MAKE DIFFERENCE IN HEIGHT
	CLC
     	ADC	ENEMYY,X
	STA	ENEMYY,X

SAM5B:	LDY	#1
	LDA	(EXTRA_PTR),Y	;GET WIDTH OF ANIMATION IN CELLS
	JSR	TIMES8
	STA	ENEMYWIDE,X	;SET NEW WIDTH FOR ENTITY
	LSR	A		;MAKE HALF WIDTH
	STA	SAFEWORD+1	;SAVE HERE FOR CENTER CORRECTION

	LDA	ENEMYCENTR,X	;SEE IF WE HAD AN OLD CENTER TO LOCATE FROM
	BEQ	SAM8		;IF OLD CENTER 0, NO CORRECTION NEEDED
	SEC
	SBC	SAFEWORD+1	;MAKE LOCATION OF LEFT HALF TO KEEP CENTER
	BCS	SAM7		
	LDA	#0
SAM7: 	STA	ENEMYX,X

SAM8:  	LDA	ENEMY0,X	;GET ENEMY FLAG BEFORE WE CHANGE HIM
	PHA
	LDA	#-1
	STA	ENEMY0,X	;MARK IT OFF SO LOW LEVEL WON'T MOVE IT
	TXA
	JSR	KILLSPRT	;GET RID OF THE OLD SPRITE
	LDY	SUBSVAR2
	LDX	SUBSVAR1
	LDA	SAFEBYTE
	JSR	INITSPRT	;PUT UP THE NEW ONE
	BEQ	SAM10
	PLA			;THROW OUT THE SAVED ENEMY0 IF CAN'T INIT
	PHA
	JSR	MAKEDING
	LDX	SAFEBYTE
	PLA
	CMP	#0
      	RTS			;OOPS!!! WE COULDN'T SET IT UP.

SAM10: 	LDX	SAFEBYTE
       	LDY	ENEMYY,X
       	LDA	ENEMYX,X
       	TAX
       	LDA	SAFEBYTE
       	JSR	PUTSPRT		;WE HAVE TO PUT IT ASAP, CAN'T WAIT FOR NMI
				;OR IT'LL FLASH A BIT.
 	JSR	FINDLOCS
	PLA			;GET BACK ENEMY0 FLAG
	STA	ENEMY0,X	;RESTORE IT

	LDA	ENEMYSTAT,X	;SEE IF SOLID IS ON
	AND	#4
	BEQ	SAM20		;IF NOT, IGNORE OUR SOLID VALUE
	JSR	SOLIDON

	LDY	ENEMYY,X
	LDA	ENEMYX,X
	TAX
	LDA	SAFEBYTE	;SEE IF THE NEW POSITION IS COOL
	JSR	TESTPUT
	BEQ	SAM20

;THE ENTITY WAS LAUNCHED OVER SOLID.  TRY MOVING TO THE LEFT BY 8 PIXELS
;OR TO THE RIGHT BY 8.

	LDX	SAFEBYTE
	LDY	ENEMYY,X
	LDA	ENEMYX,X
	SEC
	SBC	#8
	BCS	SAM12
      	LDA	#0
SAM12:	TAX
	LDA	SAFEBYTE
	JSR	TESTPUT		;TRY 8 TO THE LEFT
	BEQ	SAM19

	LDX	SAFEBYTE
	LDY	ENEMYY,X
	LDA	ENEMYX,X
	CLC
	ADC	#8
	BCC	SAM13
      	LDA	#-1
SAM13:	TAX
	LDA	SAFEBYTE
	JSR	TESTPUT		;TRY 8 TO THE RIGHT
	BNE	SAM20

SAM19:	LDX	SAFEBYTE
	LDA	TESTX
	STA	ENEMYX,X	;IF WE CORRECTED LOCATION, SET NEW PLACE
	LDA	TESTY
	STA	ENEMYY,X

SAM20:	LDA	SAFEWORD
	AND	#H'30		;SEE IF ANY ALIGNMENT SPECIFIED
	BEQ	SAM30
	TAX			;IF SO, THESE BITS HAVE TYPE OF ALIGNMENT
	LDA	SAFEWORD
	AND	#7		;THESE HAVE SHIFT COUNT
	TAY
	LDA	SAFEBYTE
	JSR	ALIGNANIM		;MAKE HERO ALIGN TO BACKGROUND

;SEE IF ITS AN AUTOFREEZE ANIMATION.

SAM30: 	LDA	SAFEWORD	;SEE IF AUTOFREEZE ANIMATION
	AND	#H'40
	BEQ	SAM40
      	LDA	SAFEBYTE
	JSR	AUTOFREEZE

SAM40:	LDX	SAFEBYTE
	LDA	#0		;RETURN SUCCESS
	RTS

;THIS ROUTINE WILL MAKE AN INDEX TO THE ENEMY INFO IN ENTITYTAB FOR THE
;ENEMY IN SAFEBYTE.  ON RETURN, (SUBSVAR1) POINTS TO THE ENTITYTAB ENTRY
;AND X HAS SAFEBYTE.

POINTENEMY:
	LDX	SAFEBYTE
	LDA	ENEMY0,X	;GET ENEMY NUMBER

POINTE2:			;SET UP YOUR OWN ENEMY0 AND X

	STA	SUBSVAR1	;PUT INDEX INTO POINTER
	LDA	#0
	STA	SUBSVAR2
	ASL	SUBSVAR1	;MAKE *2 INDEX
	ROL	SUBSVAR2

	LDA	SUBSVAR1	;GET *2 INDEX

	ASL	SUBSVAR1
	ROL	SUBSVAR2	;MAKE *4 INDEX

	CLC
	ADC	SUBSVAR1
	STA	SUBSVAR1
	LDA	SUBSVAR2
	ADC	#0
	STA	SUBSVAR2	;MAKE *6 INDEX

	LDA	#ENTITYTAB & H'FF
	CLC
	ADC	SUBSVAR1
	STA	SUBSVAR1
	LDA	#ENTITYTAB >> 8
	ADC	SUBSVAR2
	STA	SUBSVAR2	;SET UP AN INDIRECT POINTER TO THE ENEMY ENTRY
	RTS

;THIS SUB WILL INCREMENT THE WORD VALUE ENEMYPTR.  NO REGS ARE CHANGED.

INCINC:	JSR	INCPTR		;CALL HERE FOR DOUBLE INC

INCPTR:
	INC	ENEMYPTR
	BNE	IPT10
	INC	ENEMYPTR+1
IPT10:	RTS

;THIS SUBS WILL RETURN A FLAG IN A THAT REPRESENTS WHAT SIGN CORRECTIONS
;WE SHOULD MAKE FOR A MOMENTUM VALUE ACCORDING TO THE CURRENT TRACKING
;STATUS AND TARGET.  A HAS THE FLAG ON RETURN (X ASSUMED TO BE ENEMY INDEX
;AND IT'S NOT CHANGED).  SUBSVAR5 ALSO HAS THE FLAG:
;80 = SET IF REVERSE X DIRECTION
;01 = SET IF REVERSE Y DIRECTION

;SAFEX,X2, Y, Y2 ARE NOT USED.

TRACKDIR:
	LDA	#0
	STA	SUBSVAR5	;ZERO THE FLAG FOR RETURN
	JSR	MAKETRACKS	;GET THE LOCATION OF THE ONE TO TRACK
	CMP	#-1		;SEE IF THE NOTHING TO TRACK CONDITION EXISTS
	BEQ	TDR100

;SEE IF WE HAVE X TRACKING

	LDA	ENEMYTRACK,X	;GET THE TRACKING FLAG
	AND	#H'03		;X TRACKING?
	BEQ	TDR50
	CMP	#3		;ORIGIN?
	BEQ	TDR50
	AND	#H'01		;SEE IF TRACK TOWARDS TARGET (H'01 TRUE)
	STA	SUBSVAR4	;BUT WE MUST SAVE IT 
	LDY	#0		;ASSUME PLUS TOWARDS TARGET
	LDA	SUBSVAR1	;GET X LOCATION OF TARGET
	CMP	ENEMYCENTR,X	;SEE IF PLUS
	BCS	TDR30
      	LDY	#H'80		;IF TARGET BEHIND US, USE NEGATIVE
TDR30:	TYA			;GET BACK VALUE TO USE
	LDY	SUBSVAR4	;GET TOWARDS BIT
	BNE	TDR40
	EOR	#H'80		;IF TRACK AWAY, INVERT SIGN
TDR40:	STA	SUBSVAR5	;SET DIRECTION WE NEED ON X
	
;SEE IF WE HAVE Y TRACKING	

TDR50:	LDA	ENEMYTRACK,X
	AND	#H'30
	BEQ	TDR100
	AND	#H'10		;SEE IF TRACK TOWARDS TARGET (H'10 TRUE)
	STA	SUBSVAR4	;BUT WE MUST SAVE IT 
	LDY	#0		;ASSUME TOWARDS
	LDA	SUBSVAR2	;GET Y LOCATION OF TARGET
	CMP	ENEMYFEET,X	;SEE WHAT DIRECTION WE WANT
	BCS	TDR80
	LDY	#1		;IF TRACK AWAY, INVERT SIGN
TDR80:	TYA
	LDY	SUBSVAR4	;SEE IF TOWARDS OR AWAY
	BNE	TDR90
	EOR	#1
TDR90:	ORA	SUBSVAR5
	STA	SUBSVAR5

;DONE.  BUT WE NEED TO CHECK FOR SPECIAL CONDITION OF TRACK TOWARDS ORIGIN
;REGARDLESS OF TARGET.

TDR100:	LDA	ENEMYTRACK,X	;GET THE TRACKING FLAG
	AND	#H'03		;X ORIGIN TRACKING?
	EOR	#3
	BNE	TDR110
	JSR	MAKE_ECOL
	LDY	#0		;ASSUME PLUS DIRECTION
	LDA	ENEMYLCOL,X
	SEC
	SBC	SAFEWORD
	LDA	ENEMYHCOL,X
	SBC	SAFEWORD+1
	BCS	TDR105
	LDY	#H'80
TDR105:	STY	SAFEWORD
	LDA	SUBSVAR5
	AND	#H'7F
	ORA	SAFEWORD
	STA	SUBSVAR5
TDR110:	LDA	SUBSVAR5	;GET RESULTING FLAG
	RTS

;THIS SUB WILL SET SUBSVAR1 AND SUBSVAR2 TO THE CENTER X AND HEAD 
;Y OF THE CURRENT TARGET THAT THE ENEMY SPECIFIED IN X IS SUPPOSED TO BE 
;TRACKING.  IF THE ENEMY IS SUPPOSED TO BE TARGETING ENEMIES ONLY, AND NO 
;OTHER ENEMY EXISTS, SUBSVAR2 WILL BE SET TO -1 (AN IMPOSSIBLE Y LOCATION).  
;IF THE ENEMY IS SUPPOSED TO ATTACK THE LAST ATTACKER AND THAT ONE IS DEAD, 
;HIS LAST ATTACKER WILL BE CORRECTED TO THE HERO AND HE WILL RETURN THE HERO'S
;VALUE.  ON RETURN FROM THIS ROUTINE SUBSVAR2 IS ALWAYS IN A SO YOU CAN
;CHECK FOR THE -1 CONDITION.

MAKETRACKS:

	LDA	ENEMYTRHI,X	;SEE IF LAST ATTACKER (SPECIAL CASE
	BPL	GTT100		;SKIP IF NOT
	LDA	ENEMYATK,X	;IF LAST ATTACKER, IS THERE ONE?
	CMP	#-1
	BEQ	GTT100
	TAY			;IF THERE WAS A LAST ATTACKER, STILL ALIVE?
	JSR	VALID
	BNE	GTT50
	STA	ENEMYATK,X	;IF NONE ALIVE, RESET LAST ATTACKER
	JMP	GTT100

;		LAST ATTACKER IS TARGET

GTT50:	LDA	ENEMYCENTR,Y	;JUMP HERE TO USE ENEMY SPECIFIED IN Y.
	STA	SUBSVAR1
	LDA	ENEMYFEET,Y
	STA	SUBSVAR2
	RTS

;		3 = ENEMY MATCHING OUR ATTACK LEVEL IS TARGET 

GTT100:	LDA	#-1
	STA	SUBSVAR1	;SET MAX DISTANCE FOR COMPARE OF CLOSEST
	STA	SUBSVAR21	;SET NONE PICKED
	LDY	#0		;START BY CHECKING WITH ENEMY 0

GTT110:	JSR	VALID		;CHECK NEXT ENEMY
	BEQ	GTT140		;SKIP IF INVALID
	TYA
	CMP	SAFEBYTE	;BUT IS IT US?
	BEQ	GTT140		;IF SO, CAN'T ATTACK OURSELVES

	LDA	ENEMYTLLOW,Y	;GET ENEMIES TARGET LEVEL
	AND	ENEMYTRLOW,X	;SEE IF WE HAVE A MATCH
	BNE	GTT112
	LDA	ENEMYTLHI,Y	
	AND	ENEMYTRHI,X	;CHECK THE FULL WORD
	BEQ	GTT140

GTT112:	LDA	ENEMYX,Y	;GET THIS ENEMIES X
	SEC
	SBC	ENEMYX,X
	BCS	GTT115
	JSR	NEGATE
GTT115:	CMP	SUBSVAR1	;SEE IF ITS SMALLER THAN CURRENT
	BCS	GTT140		;IF NOT, DON'T USE THIS ONE
	STA	SUBSVAR1
	STY	SUBSVAR2	;IF IT IS, REPLACE ENEMY TO USE WITH THIS ONE
GTT140:	INY			;SKIP TO NEXT ENEMY
	CPY	#ECNT		;DONE?
	BNE	GTT110	
	LDY	SUBSVAR2	;GET WHO WE PICKED
	CPY	#-1
	BNE	GTT50		;IF THERE WAS ONE, RETURN ITS VALUES.	
	TYA			;RETURN THE -1 FLAG AS PROMISED
	RTS

;-----------------------------------------------------------------------------
; Seed random number generator.
;
SEEDRANDOM:
		LDA	#H'FD
		STA	RNDNUM1
		LDA	#H'43
		STA	RNDNUM2
		LDA	#H'03
		STA	XRANDOM
		RTS

;THIS SUB WILL RETURN A RANDOM NUMBER FROM 0-255 IN A.  ITS ALSO STORED
;IN XRANDOM.  X AND Y ARE NOT CHANGED.

GETRANDOM:
		LDA	RNDNUM1
		CLC
		ADC	#H'c3
		STA	RNDNUM1
		LDA	RNDNUM2
		ADC	#H'9e
		STA	RNDNUM2
		LDA	XRANDOM
		ADC	#H'26
		STA	XRANDOM
		LDY	#0
		LDA	(RNDPTR),Y
		CLC
		ADC	XRANDOM	
		STA	XRANDOM
		PHA
		LDA	RNDPTR
		CLC
		ADC	#1
		STA	RNDPTR
		AND	#1		;KEEP LOW BIT OF POINTER
		TAY
		LDA	RNDPTR+1
		ADC	#0
		ORA	#H'80
		AND	#B'10111111	;KEEP IN ROM CODE RANGE
		STA	RNDPTR+1
		PLA
		CPY	#0
		BEQ	GETR10
       		EOR	#H'80		;INVERT TOP BIT FOR GOOD 50/50 LOGIC
GETR10:		RTS

;THIS ROUTINE WILL DO A TESTPUT USING A RELATIVE X AND Y MOVEMENT
;FOR ENTITY SLOT SAFEBYTE.
;IF SUCCESSFULL WILL SET THE NEW X AND Y ENEMY VARIABLES (ENEMYX,ENEMYY,
;ENEMYCENTR, ENEMYFEET). X ALWAYS RETURNS THE ENEMY INDEX.  A HAS THE 
;RESULT CODE, BUT Z IS ALSO SET.
;IF SOLID ON REQUEST IS SET, THIS ROUTINE WILL TRY TO TURN SOLIDS ON AND
;RESET THE BIT. 

;ON ENTRY, X AND Y HAVE THE SIGNED MOVEMENT VALUES TO APPLY TO THE CURRENT
;ENTITIES LOCATION.

MOVESET:
	JSR	MAKEXY
	LDA	SAFEBYTE
	JSR	TESTPUT
	LDX	SAFEBYTE
	CMP	#0
	BNE	MST5
	LDA	TESTX
	STA	ENEMYX,X	;SET RESULTING POSITION TO SAVE TIME ON GET
	LDA	TESTY
	STA	ENEMYY,X
	JSR	FINDLOCS
	LDA	ENEMYSTAT,X	;SEE IF SOLID ON REQUEST
	AND	#H'40		
	BEQ	MST3
	JSR	TRYON		;TRY TO TURN ON SOLIDS IF SO
MST3:	LDA	#0
MST5:	RTS

;THIS ROUTINE FUNCTIONS SIMILAR TO MOVESET EXCEPT THAT ONLY THE FLAG IS
;RETURNED, ENEMYX AND Y ARE NOT CHANGED.  ITS LIKE THE OLD MOVESPRT CALL
;IN THE OLD SUBS.

TESTMOVE:
	JSR	MAKEXY
	LDA	SAFEBYTE
	JSR	TESTPUT
	LDX	SAFEBYTE
	CMP	#0
	RTS

;THIS ROUTINE GENERATES X AND Y FOR TESTMOVE AND MOVESET.

MAKEXY:	
	STX	TESTX
	LDX	SAFEBYTE
      	CLC
	TYA
	BMI	TRM10
	ADC	ENEMYY,X
;	BCC	TRM20
;	LDA	#239		;JUST CAN CORRECTIONS FOR NOW ON Y AXIS
	JMP	TRM20

TRM10:	ADC	ENEMYY,X
;	BCS	TRM20
;	LDA	#0		;THIS PREVENTS JUMPING ONTO STAT BAR
TRM20:	TAY			;MAKE DESIRED Y LOCATION

      	CLC
	LDA	TESTX
	BMI	TRM30
	ADC	ENEMYX,X
	BCC	TRM40
	LDA	#-1
	JMP	TRM40

TRM30:	ADC	ENEMYX,X
	BCS	TRM40
	LDA	#0
TRM40:	TAX			;MAKE DESIRED X LOCATION
	RTS

;CALL HERE TO CALCULATE THE CENTER OF AN ENEMY AND PUT IT INTO ENEMYCENTR
;AND THE FEET AND PUT IT INTO ENEMYFEET.
;SAFEBYTE SHOULD HAVE THE ENEMY INDEX AND IT IS RETURNED IN X.

FINDLOCS:			
	LDX	SAFEBYTE
	JSR	FINDCENTER
	JSR	FINDFEET
	RTS

FINDCENTR: 	 		;CALL HERE WITH X TO FIND IF ENEMYCENTR.
	LDA	ENEMYWIDE,X
	LSR	A
	CLC
	ADC	ENEMYX,X
	BCC	MST2
	LDA	#H'FF
MST2:	STA	ENEMYCENTR,X
	RTS

FINDFEET:			;CALL HERE WITH X TO FIND ENEMYFEET
	LDA	ENEMYY,X
	CLC
	ADC	ENEMYHIGH,X
	STA	ENEMYFEET,X
	DEC	ENEMYFEET,X	
	RTS

;************* CODE INSIDE THE VERTICAL RETRACE INTERRUPT *************
;
;THE MAIN STATE MACHINE LOGIC RUNS OUTSIDE NMI (VERTICAL RETRACE INTERRUPT).
;BECAUSE OF THIS, THE ROUTINES INSIDE THIS INTERRUPT MUST BE CAREFUL OF 
;MIXING SPRITE OR BACKGROUND CALLS BECAUSE KUNGSUBS DOES NOT ALLOW MIXING
;SOME LEVELS (KEY VARIABLES ARE NOT SAVED DURING INT).  THIS CODE
;MUST RESTRICT ITSELF TO SPECIFIC FUNCTIONS.  ALSO, IT MUST NOT
;USE VARIABLES USED BY THE NON-NMI CODE.
;
;THE TIMER ROUTINE HERE SETS THE FLAG "PHASE4" BIT 01 TRUE EVERY X NMI 
;INTERRUPTS AS SPECIFIED BY THE VARIABLE CLOCKPHASE IN KUNGTAB.ASM
;THIS GIVES A 15-30 TICKS PER SECOND CLOCK ON NTSC SYSTEMS AND A 50/60
;PHASE CLOCK ON PAL.  SINCE SMOOTH ANIMATION REQUIRES 12 FRAMES,
;WE ARE SAFE FOR SPRITE MOVEMENT ON BOTH SYSTEMS.  AT ANY RATE,
;ONLY THE FLAG IS SET HERE, THE MAINLINE CODE OUTSIDE NMI WILL
;RESET AND USE THIS FLAG.

;******************** NMI PROCESSING CODE **************
;
;THIS ROUTINE IS CALLED AT THE END OF EACH NMI INTERRUPT.  THERE ARE
;ONLY ABOUT 8 MILLISECONDS REMAINING TILL THE NEXT NMI WHEN THIS 
;CODE IS CALLED SO DON'T TAKE TOO LONG!

USER_NMI:

	LDA	BPAUSE		;IF PAUSE, DON'T INC THE CLOCK
	ORA	WORLD_REQUEST	;OR IF WORLD CHANGE IN PROGRESS
	BEQ	RSP5
	RTS

RSP5:	LDA	SAFEBYTE
	PHA			;WE NEED A LOOP COUNTER DURING NMI.

;DEC THE TIME CLOCK.

 	DEC	TIMETICK	;KEEP OUR CLOCK GOING
	BEQ	RSP13
	JMP	RSP20

RSP11:	INC	TIMETICK
	JMP	RSP20

RSP13:	LDA	PHASE4		;MAKE SURE MAINLINE FINISHED ROTATING SPRITES
	AND	#1
	BNE	RSP11		

;ITS ANOTHER CLOCK PHASE

	LDA	CLOCKP
	STA	TIMETICK
	INC	PHASE4		;SET THE NEW MOVEMENT INTERVAL FLAG
				;FOR THE HIGH LEVEL
	INC	ALTPHASE	;FOR HALF FREQUENCE EXECUTERS

;SEE IF THERE'S DATA TO WRITE OUT

RSP20:	LDA	STATLEN
	BEQ	RSP100
	ADC	#4		;ADD HEADER AMOUNT
	STA	SUBSVAR1
	JSR	GET_ROOM		;SEE HOW MUCH ROOM WE HAVE LEFT
	CMP	SUBSVAR1		;MAKE SURE THERE'S ENOUGH ROOM NOW
	BCC	RSP100

;WE HAVE TO WRITE DATA OUT TO THE STATUS LINE.  WE CALL THE SUB BECAUSE
;IT MONKEYS WITH THE STACK TO GET THE DATA.

	JSR	STATWRITE

RSP100:	PLA
	STA	SAFEBYTE	;RESTORE THE LOOP COUNTER WE NEEDED
	RTS

;THIS SUB PROCESSES A STATUS BAR WRITE.  CALL ONLY IF STATLEN IS TRUE
;AND THERE IS ENOUGH ROOM.  STATLEN IS RESET.  

STATWRITE:
	TSX
	TXA
	SEC
	SBC	#33		;MAKE ROOM TO HOLD DATA FOR SOUND COMMANDS
	TAX
	TXS

	LDA	STATTYPE
	CMP	#PALCLR
	BNE	SWR24
	JMP	SWR50

SWR24:	CMP	#SETSTATPAL
	BEQ	SWR23
 	CMP	#WRITEVID
	BNE	SWR25

SWR23:	LDA	STATDATA
	STA	SUBSVAR1
	LDA	STATDATA+1
	STA	SUBSVAR2	;POINT TO THE DATA
	LDA	STATLEN
	STA	SUBSVAR3
	JSR	FILLSTACK	;GET THE DATA INTO THE BUFFER
	TSX
	INX			;POINT TO WHERE THE DATA WENT
	STX	STATDATA
	LDA	#H'01
	STA	STATDATA+1	;NOW POINT TO THE DATA IN THE BUFFER
	LDA	STATTYPE
	CMP	#SETSTATPAL	;PALETTE COMMAND IS DIFFERENT
	BNE	SWR25
	JMP	SWR40

SWR25:	LDA	VIDTYPE		;SEE IF VIDEO OR STATUS LINE
	CMP	#STATVID
	BEQ	SWR26
	LDX	STATROW
	LDY	#H'20
	JSR	MUL		;IF VIDEO MEMORY, MAKE ROW
	LDA	STATCOL
	JSR	ADD_WORD	;AND ADD COLUMN
	STX	SUBSVAR1
	STY	SUBSVAR2	;MAKE POINTER
	LDA	VIDTYPE
	ASL	A
	ASL	A
	ORA	#H'20		;MAKE PAGE 20 OR 24
	CLC
	ADC	SUBSVAR2
	STA	SUBSVAR2	;SET UPPER LOCATION FOR WRITE TO VID
	JMP	SWR27		;GO DO THE WRITE

SWR26:	LDA	STATROW
	STA	SUBSVAR1
	LDA	#0
	STA	SUBSVAR2
	ASL	SUBSVAR1
	ROL	SUBSVAR2
	ASL	SUBSVAR1
	ROL	SUBSVAR2
	ASL	SUBSVAR1
	ROL	SUBSVAR2
	ASL	SUBSVAR1
	ROL	SUBSVAR2
	ASL	SUBSVAR1		;MAKE 1 WORD OFFSET OF ROW
	ROL	SUBSVAR2
	CLC
	LDA	STATCOL
	ADC	SUBSVAR1
	STA	SUBSVAR1
	LDA	SUBSVAR2
	ADC	#0
	STA	SUBSVAR2		;MAKE OFFSET OF THIS ROW AND COLUMN
	LDA	SUBSVAR1
	CLC
	ADC	STATLO
	STA	SUBSVAR1
	LDA	SUBSVAR2
	ADC	STATHI
	STA	SUBSVAR2
SWR27:	LDA	STATTYPE		;SEE IF SHOW SCORE
	CMP	#SHOWSCORE		;DO WE NEED TO MAKE THE SCORE?
	BNE	SWR32	
	JSR	CONVSCORE	;CONVERT SCORE TO DATA WE NEED AND SET LEN
	JMP	SWR34

SWR32:	CMP	#SHOWREG
	BNE	SWR34
	LDA	STATDATA
	STA	SUBSVAR3
	LDA	STATDATA+1
	STA	SUBSVAR4
	JSR	CONVWORD

SWR34:	LDX	SCCNT
	LDA	#0
	STA	SCNBUF,X
	INX
	LDA	SUBSVAR2
	STA	SCNBUF,X
	INX
	LDA	SUBSVAR1
	STA	SCNBUF,X		;SET HI AND LOW OFFSET
	INX
	LDA	STATLEN
	STA	SCNBUF,X		;SET COUNT
	STA	SUBSVAR1	;SET AS USABLE COUNTER
	INX					      
	LDA	STATTYPE	;SEE WHAT TYPE OF COMMAND IT WAS
	CMP	#FILLVID	;FILL VIDEO?
	BEQ	SWR35		;ITS AN EXCEPTION

	LDY	#0
SWR30:	LDA	(STATDATA),Y
	STA	SCNBUF,X
	INX
	INY
	DEC	SUBSVAR1
	BNE	SWR30
	JMP	SWR38

SWR35:	LDA	STATDATA	;IF SO, GET FILL DATA

SWR37:	STA	SCNBUF,X
	INX
	DEC	SUBSVAR1
	BNE	SWR37
SWR38:	STX	SCCNT
	LDA	#0
	STA	STATLEN		;ZERO LENGTH TO WRITE OUT

	TSX
	TXA
	CLC
	ADC	#33		;RESTORE THE STACK POINTER
	TAX
	TXS
	RTS

;ITS THE STATUS LINE PALETTE COMMAND.  WE MUST MAKE CALCULATIONS

SWR40:	LDA	STATROW
	ASL	A
	ASL	A
	ASL	A		;MAKE A SET OF 8 BYTES FROM THE GROUP ROW
	STA	STATROW

	LDA	#H'F8
	SEC
	SBC	STATROW
	STA	SUBSVAR1
	LDA	#H'27
	SBC	#0
	STA	SUBSVAR2	;MAKE LOCATION TO WRITE TO

	LDA	#WRITEVID	;FAKE A WRITE OUT DATA COMMAND
	STA	STATTYPE	
	JMP	SWR27		;SHARE CODE

SWR50:	LDA	#H'3F
	STA	SUBSVAR2
	LDA	STATCOL
	STA	SUBSVAR1	;SET PLACE TO WRITE
	LDA	#STATROW & H'FF
	STA	STATDATA
	LDA	#STATROW >> 8
	STA	STATDATA+1	;POINT TO IT
	JMP	SWR34		;SHARE THE ENDING TO WRITE IT OUT

;THIS ROUTINE WILL CHECK IF A JOYSTICK CONTROLLED ENTITY IS TOO CLOSE TO
;THE LEFT OR RIGHT OF THE SCREEN.  IT FINDS THE BEST COMPROMISE FOR
;SCROLL IF THERE ARE 2 JOYSTICK ENTITIES.  IT SUPPORTS LEFT AND RIGHT
;SCROLL LIMIT COMMANDS.  THIS ROUTINE IS RESPONSIBLE FOR SETTING 
;THE VARIABLE "GLOBAL_XSCR" WHICH IS USED TO ADJUST 
;THE ENTITIES EACH MOVEMENT CYCLE.   IT ALSO MAINTAINS THE HALF AND
;QUARTER SCROLL VALUES.

;FIRST WE MUST SEE IF THERE ARE 2 OR JUST 1.

CHECKSCROLL:
	LDX	JOYENEMY	;SET UP TO USE FIRST FOR SCROLL
	LDY	JOYENEMY+1	;BUT SEE IF THE SECOND IS VALID
	BMI	CSR90		;IF THIS ONE INVALID, CAN USE FIRST
	
  	LDX	JOYENEMY+1	;SET UP TO USE THIS ONE INSTEAD
	LDY	JOYENEMY	;AND SEE IF FIRST IS VALID
	BMI	CSR90		;IF SO, WE CAN USE THE SECOND FOR SCROLL.

;THERE ARE 2 JOYSTICK ENTITIES.  WE ONLY LET THE SCREEN SCROLL IF
;THEY ARE BOTH ON THE SAME HALF OF THE SCREEN.

	JSR	VALID		;SEE IF FIRST IS INVALID ENEMY
	BEQ	CSR90		;IF SO, X HAS SECOND AND MAKESCROLL IS OK.
	LDA	ENEMY0,X	;OR IS JOYENEMY+1 INVALID?
	CMP	#-1
	BNE	CSR10
	STA	JOYENEMY+1	;IF IT WAS, STOP IT FROM EXISTING
	JMP	CHECKSCROLL	;AND LET THE LOGIC TRY AGAIN.

CSR10:	LDA	#0		;ASSUME CONFLICT
	STA	GLOBAL_XSCR
	LDA	ENEMYCENTR,X
	EOR	ENEMYCENTR,Y	;SEE IF THEY ARE BOTH ON THE SAME SIDE
	BMI	CSR100		;IF NOT, DON'T ALLOW SCROLLING.	
	LDA	ENEMYCENTR,X	;IF BOTH ON SAME SIDE, WHICH IS CLOSEST?
	BPL	CSR20
	CMP	ENEMYCENTR,Y	;IF WE ARE ON RIGHT SIDE, GET BIGGER ONE
	BCS	CSR90
	JMP	CSR30

CSR20:	CMP	ENEMYCENTR,Y	;SEE IF WE SHOULD SWAP
	BCC	CSR90		;WE SHOULDN'T IF TO LEFT AND +

CSR30:	LDX	JOYENEMY	;SWAP IF OTHER IS CLOSER

;WE HAVE THE ONE TO MAKE THE SCROLL WITH IN X.

CSR90:	JSR	MAKESCROLL	
	STA	GLOBAL_XSCR

;GLOBAL_XSCR HAS BEEN MADE.  MAKE THE OTHER VALUES.  ALSO, CHECK IF
;SCROLLING IS ENABLED IN THE DIRECTION WE ARE GOING.

CSR100:	LDA	GLOBAL_XSCR
	BPL	CSR105
	LDA	SCROLLFLG	;SEE IF RIGHT SCROLL ENABLED
	AND	#RIGHT
	BNE	CSR107
	JMP	CSR110

CSR105:	LDA	SCROLLFLG
	AND	#LEFT		;SEE IF LEFT ENABLED
	BEQ	CSR110

CSR107:	LDA	#0	     	;IF DISABLED, ZERO IT
	STA	GLOBAL_XSCR

CSR110:	LDA	GLOBAL_XSCR
	BNE	CSR111
       	STA	HALF_XSCR
	STA	QUAR_XSCR	;SAVE PROCESSOR POWER IF 0
	RTS

CSR111:	CLC
	ADC	HALFXLOST	;GET 1/2 WE LOST LAST TIME
	STA	SUBSVAR1	;SAVE HERE FOR THE AMOUNT WE NEED
	JSR	HALFIT
	STA	HALF_XSCR	;SAVE AMOUNT WELL SCROLL HERE
	ASL	A		;AND DOUBLE IT
	STA	SUBSVAR2
	LDA	SUBSVAR1	;GET FULL AMOUNT WE WANTED
	SEC
	SBC	SUBSVAR2	;FIND OUT HOW MUCH WE DID
	STA	HALFXLOST	;SAVE FOR NEXT TIME


	LDA	GLOBAL_XSCR
	CLC
	ADC	QUARTERXLOST	;GET 1/4 WE LOST LAST TIME
	STA	SUBSVAR1	;SAVE HERE FOR THE AMOUNT WE NEED
	JSR	HALFIT
	JSR	HALFIT
	STA	QUAR_XSCR	;SAVE AMOUNT WELL SCROLL HERE
	ASL	A		;DOUBLE IT
	ASL	A		;AND DOUBLE IT
	STA	SUBSVAR2
	LDA	SUBSVAR1	;GET FULL AMOUNT WE WANTED
	SEC
	SBC	SUBSVAR2	;FIND OUT HOW MUCH WE DID
	STA	QUARTERXLOST	;SAVE FOR NEXT TIME
	RTS

;THIS ROUTINE WILL CHECK IF A JOYSTICK CONTROLLED ENTITY IS TOO CLOSE TO
;THE TOP OR BOTTOM OF THE SCREEN.  IT FINDS THE BEST COMPROMISE FOR
;SCROLL IF THERE ARE 2 JOYSTICK ENTITIES.  
;THIS ROUTINE IS RESPONSIBLE FOR SETTING 
;THE VARIABLE "GLOBAL_YSCR" WHICH IS USED TO ADJUST 
;THE ENTITIES EACH MOVEMENT CYCLE.   IT ALSO MAINTAINS THE HALF AND
;QUARTER SCROLL VALUES.

;FIRST WE MUST SEE IF THERE ARE 2 OR JUST 1.

IFDEF( `BLOCKMODE', `

CHECKYSCROLL:
	LDX	JOYENEMY	;SET UP TO USE FIRST FOR SCROLL
	LDY	JOYENEMY+1	;BUT SEE IF THE SECOND IS VALID
	BMI	CYR90		;IF THIS ONE INVALID, CAN USE FIRST
	
  	LDX	JOYENEMY+1	;SET UP TO USE THIS ONE INSTEAD
	LDY	JOYENEMY	;AND SEE IF FIRST IS VALID
	BMI	CYR90		;IF SO, WE CAN USE THE SECOND FOR SCROLL.

;THERE ARE 2 JOYSTICK ENTITIES.  WE ONLY LET THE SCREEN SCROLL IF
;THEY ARE BOTH ON THE SAME HALF OF THE SCREEN.

	JSR	VALID		;SEE IF FIRST IS INVALID ENEMY
	BEQ	CYR90		;IF SO, X HAS SECOND AND MAKESCROLL IS OK.
	LDA	ENEMY0,X	;OR IS JOYENEMY+1 INVALID?
	CMP	#-1
	BNE	CYR10
	STA	JOYENEMY+1	;IF IT WAS, STOP IT FROM EXISTING
	JMP	CHECKYSCROLL	;AND LET THE LOGIC TRY AGAIN.

CYR10:	LDA	#0		;ASSUME CONFLICT
	STA	GLOBAL_YSCR
	LDA	ENEMYFEET,X
	EOR	ENEMYFEET,Y	;SEE IF THEY ARE BOTH ON THE SAME HALF
	BMI	CYR100		;IF NOT, DONT ALLOW SCROLLING.	
	LDA	ENEMYFEET,X	;IF BOTH ON SAME SIDE, WHICH IS CLOSEST?
	BPL	CYR20
	CMP	ENEMYFEET,Y	;IF WE ARE ON RIGHT SIDE, GET BIGGER ONE
	BCS	CYR90
	JMP	CYR30

CYR20:	CMP	ENEMYFEET,Y	;SEE IF WE SHOULD SWAP
	BCC	CYR90		;WE SHOULDNT IF TO LEFT AND +

CYR30:	LDX	JOYENEMY	;SWAP IF OTHER IS CLOSER

;WE HAVE THE ONE TO MAKE THE SCROLL WITH IN X.

CYR90:	JSR	MAKEYSCROLL	
	STA	GLOBAL_YSCR

;GLOBAL_YSCR HAS BEEN MADE.  MAKE THE OTHER VALUES.  ALSO, CHECK IF
;SCROLLING IS ENABLED IN THE DIRECTION WE ARE GOING.

CYR100:	LDA	GLOBAL_YSCR
	BPL	CYR105
	LDA	SCROLLFLG	;SEE IF DOWN SCROLL ENABLED
	AND	#DOWN
	BNE	CYR107
	JMP	CYR110

CYR105:	LDA	SCROLLFLG
	AND	#UP		;SEE IF UP ENABLED
	BEQ	CYR110

CYR107:	LDA	#0	     	;IF DISABLED, ZERO IT
	STA	GLOBAL_YSCR

CYR110:	LDA	GLOBAL_YSCR
	BNE	CYR111
       	STA	HALF_YSCR
	STA	QUAR_YSCR	;SAVE PROCESSOR POWER IF 0
	RTS

CYR111:	CLC
	ADC	HALFYLOST	;GET 1/2 WE LOST LAST TIME
	STA	SUBSVAR1	;SAVE HERE FOR THE AMOUNT WE NEED
	JSR	HALFIT
	STA	HALF_YSCR	;SAVE AMOUNT WELL SCROLL HERE
	ASL	A		;AND DOUBLE IT
	STA	SUBSVAR2
	LDA	SUBSVAR1	;GET FULL AMOUNT WE WANTED
	SEC
	SBC	SUBSVAR2	;FIND OUT HOW MUCH WE DID
	STA	HALFYLOST	;SAVE FOR NEXT TIME


	LDA	GLOBAL_YSCR
	CLC
	ADC	QUARTERYLOST	;GET 1/4 WE LOST LAST TIME
	STA	SUBSVAR1	;SAVE HERE FOR THE AMOUNT WE NEED
	JSR	HALFIT
	JSR	HALFIT
	STA	QUAR_YSCR	;SAVE AMOUNT WELL SCROLL HERE
	ASL	A		;DOUBLE IT
	ASL	A		;AND DOUBLE IT
	STA	SUBSVAR2
	LDA	SUBSVAR1	;GET FULL AMOUNT WE WANTED
	SEC
	SBC	SUBSVAR2	;FIND OUT HOW MUCH WE DID
	STA	QUARTERYLOST	;SAVE FOR NEXT TIME
	RTS
	', )

HALFIT:	PHA			;CALL HERE FOR A SIGNED HALF OF A.
	ROL	A
	PLA
	ROR	A
	RTS

;THIS SUB WILL MAKE THE SCROLL REQUEST FOR ENTITY X AND RETURN IT IN
;A.  IT CHECKS FOR ENEMY NOT VALID AND ALSO FOR SCREEN LIMIT STOPS.
;THE VALUE IS ALSO RETURNED IN SUBSVAR3.  THIS ROUTINE CHANGES TESTCOL.

MAKESCROLL:
	LDA	#0
	STA	SUBSVAR3	;ZERO RESULT
	CPX	#-1		;INVALID ENEMY NUMBER?
	BEQ	MSR45
	LDA	ENEMY0,X	;SEE IF THIS ENEMY IS VALID
	CMP	#-1
	BNE	MSR5
MSR4:	JMP	MSR100

;SEE IF WE WANT TO SCROLL LEFT.  

MSR5: 	LDA	#LEFTSCROLL
	SEC
	SBC	ENEMYCENTR,X	;SEE IF POSITIVE LEFT SCROLL (-) NEEDED
	BEQ	MSR4
	BCC	MSR50		;POSSIBLE RIGHT NEEDED IF X BIGGER THAN LEFT
	CMP	#XSCROLLSPEED	;SEE IF TRYING TO MOVE TOO FAST
	BCC	MSR10
	LDA	#XSCROLLSPEED
MSR10:	STA	SUBSVAR4	;SAVE AMOUNT WE WANT HERE BUT WE NEED NEGATE

	LDA	XBACK
	STA	TESTCOL
	LDA	XBACK+1						    
	STA	TESTCOL+1	;NEED TO MAKE COLUMN OF REAL LEFT OF SCREEN
	LSR	TESTCOL+1
	ROR	TESTCOL
	LSR	TESTCOL+1
	ROR	TESTCOL
	LSR	TESTCOL+1
	ROR	TESTCOL

	LDA	TESTCOL+1	;SEE IF NEAR LEFT
	BNE	MSR15
	LDA	STARTCOL
	CMP	#2
	BCS	MSR15
	
	LDA	XBACK
	CMP	SUBSVAR4	;MAKE SURE THERE'S ENOUGH LEFT IF NEAR LEFT
	BCS	MSR15		
	STA	SUBSVAR4	;IF NOT, USE WHAT'S LEFT

MSR15:	JSR	SEEKCMD2	;OR SAME IF LEFT LIMIT COMMAND
	CMP	#H'F3		;CONDITIONAL LEFT LIMIT?
	BNE	MSR17
      	JSR	MUSTKILL	;SEE IF ANY MUST KILL IF CONDITIONAL STOP SCRL
	BEQ	MSR40
	JMP	MSR20
MSR17:	CMP	#H'F1		;LEFT LIMIT?
	BNE	MSR40
MSR20:	LDA	XBACK		;IF ON COMMAND, GET ODD PIXELS OF SCROLL
	AND	#7		;MAKE MAX WE CAN DO
	BEQ	MSR100		;IF NONE LEFT, NO ACTION NEEDED.
	STA	SUBSVAR6
	LDA	SUBSVAR4
	CMP	SUBSVAR6		;SEE IF WE WANTED TOO MUCH
	BCC	MSR40
	LDA	SUBSVAR6
	STA	SUBSVAR4
MSR40:	LDA	SUBSVAR4
	STA	SUBSVAR3
MSR45:	JMP	MSR100

;SEE IF WE WANT TO SCROLL RIGHT

MSR50: 	LDA	ENEMYCENTR,X
	SEC
	SBC	#RIGHTSCROLL	;MAKE RIGHT SCREEN SCROLL
	BEQ	MSR100
	BCC	MSR100		;SKIP IF NONE OR NEGATIVE
	CMP	#XSCROLLSPEED	;DON'T GO FASTER THAN THE MAX ALLOWED
	BCC	MSR55
	LDA	#XSCROLLSPEED
MSR55:	STA	SUBSVAR4		;SAVE IT HERE FOR A BIT
	JSR	GET_RIGHT	;GET MAX WE ARE ALLOWED TO DO IT
	STX	SUBSVAR6
	LDA	SUBSVAR4
	CMP	SUBSVAR6		;SEE IF WE WANT TOO MUCH
	BCC	MSR60	
	LDA	SUBSVAR6
MSR60:	JSR	NEGATE		;NEED TO REVERSE FOR ENTITIES.
	STA	SUBSVAR3		;SET RIGHT SCROLL REQUEST	

MSR100:	LDA	SUBSVAR3		;RETURN RESULT
	RTS	

;THIS SUB WILL MAKE THE SCROLL REQUEST FOR ENTITY X AND RETURN IT IN
;A.  IT CHECKS FOR ENEMY NOT VALID AND ALSO FOR SCREEN LIMIT STOPS.
;THE VALUE IS ALSO RETURNED IN SUBSVAR3.  THIS ROUTINE CHANGES TESTCOL.

IFDEF( `BLOCKMODE', `

MAKEYSCROLL:
	LDA	#0
	STA	SUBSVAR3	;ZERO RESULT
	CPX	#-1		;INVALID ENEMY NUMBER?
	BEQ	MSY45
	LDA	ENEMY0,X	;SEE IF THIS ENEMY IS VALID
	CMP	#-1
	BEQ	MSY100

;SEE IF WE WANT TO SCROLL UP

 	LDA	#TOPSCROLL
	SEC
	SBC	ENEMYFEET,X	;SEE IF POSITIVE UP SCROLL (-) NEEDED
	BEQ	MSY100
	BCC	MSY50		;POSSIBLE RIGHT NEEDED IF X BIGGER THAN LEFT
	CMP	#YSCROLLSPEED	;SEE IF TRYING TO MOVE TOO FAST
	BCC	MSY10
	LDA	#YSCROLLSPEED
MSY10:	STA	SUBSVAR4	;SAVE AMOUNT WE WANT HERE BUT WE NEED NEGATE
	LDA	STARTROW	;SEE IF AT TOP OF SCREEN
	BNE	MSY40
	LDA	YBACK		;GET ODD PIXELS OF SCROLL
	AND	#7		;MAKE MAX WE CAN DO
	BEQ	MSY100		;IF NONE LEFT, NO ACTION NEEDED.
	STA	SUBSVAR6
	LDA	SUBSVAR4
	CMP	SUBSVAR6		;SEE IF WE WANTED TOO MUCH
	BCC	MSY40
	LDA	SUBSVAR6
	STA	SUBSVAR4
MSY40:	LDA	SUBSVAR4
	STA	SUBSVAR3
MSY45:	JMP	MSY100

;SEE IF WE WANT TO SCROLL DOWN

MSY50: 	LDA	ENEMYFEET,X
	SEC
	SBC	#BOTSCROLL	;MAKE DOWN SCREEN SCROLL
	BEQ	MSY100
	BCC	MSY100		;SKIP IF NONE OR NEGATIVE
	CMP	#YSCROLLSPEED	;DONT GO FASTER THAN THE MAX ALLOWED
	BCC	MSY55
	LDA	#YSCROLLSPEED
MSY55:	STA	SUBSVAR4		;SAVE IT HERE FOR A BIT
	JSR	GET_BOT			;GET MAX WE ARE ALLOWED TO DO IT
	STX	SUBSVAR6
	LDA	SUBSVAR4
	CMP	SUBSVAR6		;SEE IF WE WANT TOO MUCH
	BCC	MSY60	
	LDA	SUBSVAR6
MSY60:	JSR	NEGATE		;NEED TO REVERSE FOR ENTITIES.
	STA	SUBSVAR3		;SET RIGHT SCROLL REQUEST	

MSY100:	LDA	SUBSVAR3		;RETURN RESULT
	RTS	

	', )

;THIS ROUTINE WILL APPLY GLOBAL SCROLL TO AN ENEMY.  THE ENEMY INDEX SHOULD 
;BE IN X ON ENTRY.  IT WILL BE RETURNED THERE.  DON'T CALL
;IF GLOBAL_XSCR AND GLOBAL_YSCR ARE BOTH ZERO.  X MAY BE CHANGED ON RETURN

SCROLLENEMY:
	JSR	XINVALID	;SEE IF ENTITY IS VALID
	BEQ	SE00
	JSR	HIDDEN		;SEE IF HIDDEN ENEMY
	BNE	SE00
	JSR	MAKENEWX	;MAKE THE NEW X LOCATION
	BNE	SE00A		;SKIP IF HE'S STILL ON SCREEN
SE00B:	JMP	ENEMYG2		;IF HE'S OFF SCREEN, HIDE HIM.
SE00A:	STA	ENEMYX,X	;IF STILL ON SCREEN, SET NEW LOCATION
	LDA	ENEMYSTAT,X	;BUT IF ASLEEP, DON'T CHANGE CENTER LOCATION
	BMI	SE00		;OR Y EITHER.
	JSR	FINDCENTR	;AND CALCULATE CENTER LOCATION TOO

IFDEF( `BLOCKMODE', `
	JSR	MAKENEWY	;MAKE THE NEW Y LOCATION
	BEQ	SE00B		;SKIP IF HES NOT ON SCREEN
	STA	ENEMYY,X	;IF STILL ON SCREEN, SET NEW LOCATION
	JSR	FINDFEET	;MAKE JUST NEW FEET LOCATION
	', )
SE00:	RTS	

XINVALID:			;THIS ROUTINE CHECKS ENEMY0,X FOR -1.  
	LDA	ENEMY0,X	;IT RETURNS Z IF INVALID.
	CMP	#-1		;INVALID?
     	RTS

HIDDEN:				;SEE IF ENTITY IS HIDDEN FOR A STATREQUEST.
				;RETURNS NZ FOR ENTITY X.
	LDA	ENEMYJSTAT,X	;SEE IF HIDDEN FROM SOME WORLD
	AND	#H'20
	RTS

;THIS SUB WILL RETURN THE NEW X LOCATION OF AN ENTITY WHICH NEEDS
;TO BE SCROLLED.  (MAKE SURE ITS VALID
;BEFORE CALLING).  X SHOULD HAVE THE ENTITY INDEX.  ON RETURN, IF NZ
;THEN A HAS THE NEW LOCATION.  IF Z THEN IT SCROLLED OFF SCREEN.

;SLEEPING ENTITIES ARE ALLOWED TO REMAIN SO LONG AS THEIR LAUNCH COLUMN
;IS STILL IN THE SCREEN'S TESTING RANGE.

MAKENEWX:
	LDA	ENEMYSTAT,X
	BMI	SE20		;BIT H'80 MEANS ASLEEP.  DIFFERENT LOGIC
	LDA	ENEMYCTRL,X	;GET THE FLAGS FOR HIM
	AND	#H'03
	CMP	#H'03		;NO SCROLLING AT ALL?
	BEQ	SE10
	TAY			;PUT IT HERE
	LDA	GLOBAL_XSCR	;GET THE SCROLL
	BEQ	SE10
	CPY	#0
	BEQ	SE25
	LDA	HALF_XSCR	;IF NOT FULL, USE 1/2 
	CPY	#H'01
	BEQ	SE25
	LDA	QUAR_XSCR	;ITS 1/4 SCROLL.
SE25:	CLC
	ORA	#0		;TEST SIGN OF A
	BPL	SE02
	ADC	ENEMYX,X
	BCS	SE03
	LDA	ENEMYFLGS,X
	AND	#2		;NO REMOVE IF SCROLLS TO SIDE?
	BEQ	SE04
	LDA	#0
	JMP	SE03		;IF SO, PUT AGAINST LEFT

SE02:	ADC	ENEMYX,X
	BCC	SE03		

	LDA	ENEMYFLGS,X
	AND	#2		;NO REMOVE IF SCROLLS TO SIDE?
	BNE	SE05		;IF SO, PUT AGAINST SCREEN RIGHT

SE04:  	LDY	#0		;RETURN Z, HE WENT OFF SCREEN
	RTS

SE05:	LDA	#H'FF		;IF SO, PUT AGAINST RIGHT
SE03:	LDY	#-1		;RETURN NZ, WE HAVE A LOCATION
	RTS

;NON-SCROLLER OR NO SCROLL TO USE.  RETURN THE CURRENT X.

SE10: 	LDA	ENEMYX,X
	LDY	#-1		;RETURN NZ
	RTS

;THIS ENTITY IS ASLEEP.  WE JUST NEED TO SEE IF HIS ORIGIN COLUMN
;IS STILL WITHIN THE TESTING RANGE.  ONCE ITS OUTSIDE, WE SHOULD REMOVE
;HIM BECAUSE WE CAN SCROLL BACK ONTO IT AND TEST IT AGAIN.

SE20:	LDA	ENEMYLCOL,X
	SEC
	SBC	STARTCOL	;SEE IF THE LAUNCH COLUMN IS TO THE LEFT
	TAY
	LDA	ENEMYHCOL,X
	SBC	STARTCOL+1
	BCC	SE04		;IF TO LEFT OF 0, HE'S OFF SCREEN
	TYA
	CMP	#32		;IS IT PAST THE RIGHTMOST SCREEN COLUMN?
	BCS	SE04
	LDY	#-1		;IF NOT, RETURN THAT WE HAVE A LOCATION
	RTS		

;THIS SUB WILL RETURN THE NEW Y LOCATION OF AN ENTITY WHO NEEDS TO BE
;SCROLLED.  (MAKE SURE ITS VALID
;BEFORE CALLING).  X SHOULD HAVE THE ENTITY INDEX.  ON RETURN, IF NZ
;THEN A HAS THE NEW LOCATION.  IF Z THEN IT SCROLLED OFF SCREEN.
;Y SCROLLING WILL NOT REMOVE AN ENTITY THAT IS ASLEEP WAITING TO COME
;ONTO SCREEN.

IFDEF( `BLOCKMODE', `
MAKENEWY:
	LDA	ENEMYCTRL,X	;GET THE FLAGS FOR HIM
	AND	#12
	CMP	#12		;NO SCROLLING AT ALL?
	BEQ	SEY10
	TAY			;PUT IT HERE
	LDA	GLOBAL_YSCR	;GET THE SCROLL
	BEQ	SEY10
	CPY	#0
	BEQ	SEY25
	LDA	HALF_YSCR	;IF NOT FULL, USE 1/2 
	CPY	#4
	BEQ	SEY25
	LDA	QUAR_YSCR	;ITS 1/4 SCROLL.
SEY25:	CLC
	ORA	#0		;TEST SIGN OF A
	BPL	SEY02
	ADC	ENEMYY,X
	BCS	SEY03
	LDA	ENEMYSTAT,X
	BMI	SEY03		;BIT H80 MEANS ASLEEP.   NO REMOVAL ON Y.
	LDA	ENEMYFLGS,X
	AND	#2		;NO REMOVE IF SCROLLS TO SIDE?
	BEQ	SEY04
	LDA	#0
	JMP	SEY03		;IF SO, PUT AGAINST LEFT

SEY02:	ADC	ENEMYY,X
	BCC	SEY03		

	LDA	ENEMYSTAT,X
	BMI	SEY03		;BIT H80 MEANS ASLEEP.  NO REMOVAL ON Y AXIS.
	LDA	ENEMYFLGS,X
	AND	#2		;NO REMOVE IF SCROLLS TO SIDE?
	BNE	SEY05		;IF SO, PUT AGAINST SCREEN BOTTOM
SEY04: 	LDY	#0		;RETURN Z, HE WENT OFF SCREEN
	RTS

SEY05:	LDA	#247		;IF SO, PUT AGAINST BOTTOM
SEY03:	LDY	#-1		;RETURN NZ, WE HAVE A LOCATION
	RTS

;NON-SCROLLER OR NO VALUE TO SCROLL.  RETURN THE CURRENT Y.

SEY10: 	LDA	ENEMYY,X
	LDY	#-1		;RETURN NZ
	RTS
	', )

;THIS ROUTINE WILL RETURN AN AMOUNT IN X IN PIXELS THAT IT IS OK TO SCROLL
;RIGHT WITHIN THE CURRENT BACKGROUND.  IT ALSO CHECKS FOR HITTING A RIGHT
;SCROLL LIMIT.  IF THE AMOUNT IS OVER 255, 255 IS RETURNED.

GET_RIGHT:
	LDA	STARTCOL
	CLC
	ADC	#31
	STA	TESTCOL
	LDA	STARTCOL+1
	ADC	#0
	STA	TESTCOL+1
	JSR	SEEKCMD2
	CMP	#H'F4		;CONDITIONAL RIGHT LIMIT?
	BNE	GR9
      	JSR	MUSTKILL	;SEE IF ANY MUST KILL IF CONDITIONAL STOP SCRL
	BNE	GR8
	JMP	GR10
GR9:	CMP	#H'F2		;RIGHT LIMIT COMMAND?
	BNE	GR10		;IF NOT, ITS OK TO SCROLL	
GR8:	LDX	#0
	RTS	

GR10:	LDA	RIGHTLIMIT
	SEC
	SBC	XBACK
	TAX			;ASSUME LOW BYTE IS AMOUNT LEFT
	LDA	RIGHTLIMIT+1
	SBC	XBACK+1		;MAKE AMOUNT WE CAN STILL SCROLL, 2 BYTES
	BEQ	GR20
	LDX	#255		;IF HIGH BYTES NON-ZERO, SET MAX AS SCROLLABLE
GR20:	RTS

;THIS ROUTINE WILL RETURN AN AMOUNT IN X IN PIXELS THAT IT IS OK TO SCROLL
;DOWN WITHIN THE CURRENT BACKGROUND.  
;IF THE AMOUNT IS OVER 255, 255 IS RETURNED.

IFDEF( `BLOCKMODE', `
GET_BOT:
	LDA	BOTLIMIT
	SEC
	SBC	YBACK
	TAX			;ASSUME LOW BYTE IS AMOUNT LEFT
	LDA	BOTLIMIT+1
	SBC	YBACK+1		;MAKE AMOUNT WE CAN STILL SCROLL, 2 BYTES
	BEQ	GBR20
	LDX	#255		;IF HIGH BYTES NON-ZERO, SET MAX AS SCROLLABLE
GBR20:	RTS
	', )

;THIS ROUTINE WILL TAKE THE DATA SET UP BY THE SHOWSCORE ROUTINE AND
;CONVERT THE APPROPRIATE SCORE INTO DATA IN NUMBUF.  IT SETS STATLEN
;TO THE LENGTH OF THAT DATA AND IT SUPPRESSES LEADING ZEROS.

CONVSCORE:
	LDY	STATDATA	;GET INDEX TO USE
	LDA	SCOREL,Y
	STA	SUBSVAR3
	LDA	SCOREH,Y
	STA	SUBSVAR4	;NOW WE HAVE THE SCORE TO USE 

;CALL HERE TO TAKE THE 1 WORD MAX NUMBER IN SUBSVAR3 AND 4 AND
;CONVERT INTO BASE 10 WITH RESULT IN NUMBUF AND LENGTH IN 
;STATLEN.  5 WILL BE LENGTH ALWAYS.   IT DOES LEADING ZERO SUPPRESSION.
;IT USES BASENUM (FROM KUNGTAB) TO MAKE THE RESULT INTO ASCII NUMBERS
;FROM THE VIDEO CHARACTER SET.  ON RETURN:
;
;THE NUMERIC DATA IS IN NUMBUF, LEADING ZEROS SUPPRESSED
;STATDATA POINTS TO THE DATA IN THE BUFFER (NOT NECESSARILY AT THE START)
;STATLEN HAS THE LENGTH OF THE DATA.

CONVWORD:
	LDA	#5
	STA	STATLEN		;SET MAX LENGTH POSSIBLE
	JMP	CSO0

CONVBYTE:			;CALL HERE TO DISPLAY 3 DIGITS MAX
	LDA	#3
	STA	STATLEN

CSO0:	LDA	#NUMBUF & H'FF
	STA	STATDATA
	LDA	#NUMBUF >> 8
	STA	STATDATA+1	;SET POINTER TO THE DATA
	LDA	#0		;SET PLACE TO WRITE TO IN VIDEO BUFFER
	STA	NUMBUF		;AND ZERO TOP DIGIT
CSO5:	SEC
	LDA	SUBSVAR3
	SBC	#H'10
	STA	SUBSVAR5
	LDA	SUBSVAR4
	SBC	#H'27		;SUBTRACT 10,000 FROM THE SCORE
	BCC	CSO10
	STA	SUBSVAR4
	LDA	SUBSVAR5
	STA	SUBSVAR3	;PUT IT BACK IF IT WORKED
	INC	NUMBUF		;INCREMENT THE 10,000s
	JMP	CSO5
CSO10:	LDX	SUBSVAR3
	LDY	SUBSVAR4	;GET THE RESULTING NUMBER
	LDA	#100
	JSR	DIVIDE		;MAKE A 0-55 100s
	STX	SUBSVAR3
	STY	SUBSVAR4	;REMAINDER UNDER 100 IN HERE
	LDX	SUBSVAR3	
	LDY	#0
	LDA	#10
	JSR	DIVIDE		;MAKE NUMBER OF 1000s
	STX	NUMBUF+1	;SAVE 1000s
	STY	NUMBUF+2	;SAVE 100s
	LDX	SUBSVAR4
	LDY	#0
	LDA	#10
	JSR	DIVIDE		;MAKE 10s AND 1s
	STX	NUMBUF+3
	STY	NUMBUF+4	;NOW WE HAVE ALL DIGITS
	LDX	#0		;MAKE A SUPPRESSION FLAG
	LDY	#0		;MAKE AN INDEX
CSO20:	LDA	NUMBUF,Y	;GET A DIGIT
	BNE	CSO30
	CPX	#0		;FOUND ONE YET?
	BNE	CSO30
	CPY	#4		;BUT IS IT THE LAST DIGIT?
	BEQ	CSO30
	LDA	#H'41		;ROGER CHANGED THIS 
	JMP	CSO32	
CSO30:	INX			;SET FLAG OF FOUND NON-ZERO DIGIT
	CLC
	ADC	#BASENUM	;CORRECT THE DIGIT
CSO32:	STA	NUMBUF,Y
	INY
	CPY	#5		;DID ALL DIGITS?
	BNE	CSO20

	LDA	STATLEN		;SEE IF WORD OR BYTE
	CMP	#5
	BEQ	CSO40
      	LDA	STATDATA
	CLC
	ADC	#2
	STA	STATDATA
	LDA	STATDATA+1
	ADC	#0
	STA	STATDATA+1	;IF JUST 3 DIGITS, MOVE POINTER ALONG
CSO40:	RTS	

	
;***********************JOYSTICK ROUTINES.************************
;******* THEY ALSO HAPPEN INSIDE THE VERTICAL RETRACE INTERRUPT *****

A1:				;A BUTTON CHANGE ROUTINES.  A IS JUMP.
	LDA	#0		;A+START IS CONTINUE.
	JMP	A10	;SET FOR JOYSTICK 0

A2:	LDA	#1
A10:	STA	JOYINDX
	JSR	NOTPAUSED	;MAKE SURE NOT PAUSED OR IN PROCESS OF CHANGE.

;A MEANS JUMP

A250: 	LDX	JOYINDX		;GET THE JOYSTICK INDEX
	LDA	JOYENEMY,X	;SEE WHAT ENTITY TO EFFECT
	CMP	#-1
	BEQ	A253		;SKIP IF NO ENEMY ATTACHED TO THIS JOYSTICK
	TAY
	LDA	#JUMPING
	AND	ENEMYINTS,Y
	BNE	A253
	LDA	#EJUMP
	STA	ENEMYREQ,Y
A253:	RTS

;THIS SUBROUTINE WILL TWICE POP THE STACK AND RETURN IF WORLD_REQUEST OR
;BPAUSE ARE TRUE.  THIS STOPS US FROM DOING SOMETHING WHILE  PAUSED OR
;IN PROCESS OF REBOOTING.

NOTPAUSED:
	LDA	WORLD_REQUEST	;MAKE SURE NO REQUEST IN PROGRESS
	ORA	BPAUSE		;AND MAKE SURE NOT PAUSED.
	BEQ	NCH10
	PLA
	PLA			;THROW OUT A RETURN ADDRESS
NCH10:	RTS

;IF A+B+UP ARE ALL PRESSED (BUT NO OTHERS) THEN WE ENABLE 
;THE SELECT WORLD MODE.   IF JUST B, WE CALL ATTACK.

B1:	LDA	#0	;B BUTTON CHANGE ROUTINES
	JMP	B210
B2:	LDA	#1

B210:	STA	JOYINDX		;SET INDEX ACCORDING TO JOYSTICK

	JSR	NOTPAUSED	;MAKE SURE NOT PAUSED OR IN PROCESS OF CHANGE.

	LDA	J1FLAGS
	CMP	#B'11001000	;A+B+UP?
	BNE	B110
	LDA	J2FLAGS
	CMP	#B'00001000	;B MUST BE UP TOO
	BNE	B110

	JSR	NOTBOOT		;MAKE SURE NOT BOOT WORLD
	LDA	#-1
	STA	ENABLE_SELECT	;IF SO, SET ENABLE SELECT WORLD MODE
B105:	RTS

;ITS ATTACK.

B110:	LDA	J1FLAGS
	ORA	J2FLAGS
	AND	#H'30		;MAKE SURE START OR SELECT ARE NOT DOWN
	BNE	B111

 	LDX	JOYINDX		;GET THE JOYSTICK INDEX
	LDA	JOYENEMY,X	;SEE WHAT ENTITY TO EFFECT
	CMP	#-1
	BEQ	B111		;SKIP IF NO ENEMY ATTACHED TO THIS JOYSTICK
	TAY
	LDA	#ATTACKING
	AND	ENEMYINTS,Y
	BNE	B111	
	LDA	#EATTACK
	STA	ENEMYREQ,Y
B111:	RTS

SEL1:			;SEL BUTTON CHANGE ROUTINES
 	LDA	#0	;SET INDEX
	JMP	SEL10
SEL2:	LDA	#1	;SEL+B BRINGS NEXT WORLD IF ENABLED.
SEL10:	STA	JOYINDX

	JSR	NOTPAUSED	;MAKE SURE NOT PAUSED OR IN PROCESS OF CHANGE.

	LDA	ENABLE_SELECT
	BEQ	SEL30

	JSR	NOTBOOT		;MAKE SURE NOT BOOT WORLD
	LDA	J1FLAGS		;BUT B MUST BE DOWN TOO WITH THE SELECT
	CMP	#B'01100000	;B+SELECT?
	BNE	SEL30

;ITS SELECT WORLD MODE.  GET THE NEXT WORLD.

SEL3:	LDA	CURWORLD
	TAY
	INY
	CPY	#MAX_WORLD
	BCC	SEL7
	LDY	#1
SEL7:	STY	WORLD_REQUEST	;SET REQUEST FOR THIS NEW WORLD
	LDA	#-1
	STA	SILENCEIT
	STA	CHEATMODE	;FLAG ITS A CHEAT MODE ENTERED WORLD
SEL20:	RTS

;SELECT WAS PRESSED WITHOUT B OR SELECT MODE IS NOT ENABLED.  SEE IF
;WE ARE GENERATING AN INTERRUPT.

SEL30: 	LDX	JOYINDX		;GET THE JOYSTICK INDEX
	LDA	JOYENEMY,X	;SEE WHAT ENTITY TO EFFECT
	BMI	SEL20
	TAY

	LDA	#SELECTING
	AND	ENEMYINTS,Y
	BNE	SEL20		;MAKE SURE NOT DISABLED

	LDA	SELKEY,X	;SEE IF WE HAVE AN INTERRUPT FOR SELECT
	CMP	#-1
	BEQ	SEL20	
	STA	ENEMYREQ,Y	;IF SO, REQUEST IT
	RTS

;START BUTTON ROUTINE.  IF THE GAME IS PLAYING, WE PAUSE.  

STRT1:		
STRT2:	LDA	WORLD_REQUEST	;MAKE SURE NO REQUEST IN PROGRESS
	BNE	SEL20
	LDA	CURWORLD	;AND MAKE SURE NOT BOOT WORLD
	BEQ	SEL20

	LDA	PAUSEFLG	;AND MAKE SURE PAUSE IS ENABLED
	BEQ	SEL20

;WE NEED TO PAUSE OR UNPAUSE.

	LDA	#0	;ASSUME UNPAUSE
	LDX	BPAUSE	;SEE IF WE ARE ALREADY PAUSING
	BNE	STR10
	LDA	#0
	STA	H'4015	;IF PAUSE, RESET SOUNDS
	LDA	REG4015
	STA	H'4015
	LDA	#-1
STR10:	STA	BPAUSE
	RTS

DOWN1:	LDY	#0	;DOWN BUTTON CHANGE ROUTINES
	JMP	DON10
DOWN2:	LDY	#1
DON10:	LDA	#6		;POINT TO DOWN MOMENTUMS
	LDX	#2		;USE FLAG TO SIGNAL DOWN 
	JMP	UP210

LEFT1:	LDY	#0		;LEFT BUTTON CHANGE ROUTINES
	JMP	LEF10
LEFT2:	LDY	#1
LEF10:	LDA	JOYENEMY,Y	;GET ENEMY ATTACKED TO IT
	BMI	LEF15
      	TAX			;IF ENEMY, NEED TO SET LEFT BIT
	LDA	ENEMYJSTAT,X
	ORA	#H'10
	STA	ENEMYJSTAT,X	;CAUSE WE'RE UNDER INTS WE MIGHT LOOSE THIS
				;BUT ITS NOT FATAL.
LEF15:	LDA	#0		;POINT TO THE LEFT MOMENTUMS IN DEFMOMS
	LDX	#0
	JMP	UP210

RIGHT1:	LDY	#0		;RIGHT BUTTON CHANGE ROUTINES
	JMP	RIT5
RIGHT2:	LDY	#1
RIT5: 	LDA	JOYENEMY,Y	;GET ENEMY ATTACKED TO IT
	BMI	RIT10
      	TAX			;IF ENEMY, NEED TO SET LEFT BIT
	LDA	ENEMYJSTAT,X
	AND	#H'EF
	STA	ENEMYJSTAT,X	;CAUSE WE'RE UNDER INTS WE MIGHT LOOSE THIS
				;BUT ITS NOT FATAL.
RIT10:	LDA	#2		;POINT TO THE RIGHT MOMENTUMS IN DEFMOMS
	LDX	#0
	JMP	UP210

UP1:	LDY	#0		;UP BUTTON CHANGE ROUTINES
	JMP	UPY10
UP2:  	LDY	#1
UPY10:	LDA	#4		;SET UP FOR SHARED CODE. POINT TO UP MOMS.
	LDX	#1		;FLAG TO SIGNAL UP

UP210:	STA	MOMINDX		;SAVE MOMENTUM INDEX
	STY	JOYINDX		;SAVE JOYSTICK INDEX
	STX	NEWCOL		;SAVE FLAG OF NEED NEW COLUMN TEST

	JSR	NOTPAUSED	;MAKE SURE NOT PAUSED OR IN PROCESS OF CHANGE.
	JSR	NOTBOOT		;MAKE SURE NOT BOOT WORLD
	JSR	NOTINST		;MAKE SURE NOT INSTRUCTIONS WORLD

;UPDATE X MOMENTUM

	LDY	MOMINDX		;GET MOMENTUM INDEX
	LDX	JOYINDX		;GET JOYSTICK INDEX
	LDA	JOYX,X		;GET X JOYSTICK MOMENTUM
	CLC
	ADC	DEFMOMS,Y 	;GET X MOMENTUM VALUE TO USE
	BVS	UP211		;DON'T UPDATE IF SIGNED OVERFLOW
	STA	JOYX,X

;NOW UPDATE Y MOMENTUM.  

UP211:	LDA	JOYY,X
	CLC
	ADC	DEFMOMS+1,Y
	BVS	UP212
	STA	JOYY,X		;UPDATE ACCORDING TO MOMENTUM TABLE

;NOW SEE IF AN ENTITY IS ATTACKED TO IT AND WE NEED TO MAKE HIM TEST
;A COLUMN AGAIN.

UP212:	LDA	NEWCOL		;SEE IF NEW COLUMN FLAG SET CAUSE UP OR DOWN
	BEQ	UP220
      	LDA	JOYENEMY,X	;GET ENEMY ATTACKED TO IT
	BMI	UP220
	TAX
	LDA	#-1
	STA	ENEMYLROW,X	;SET LAST ROW AS 255 TO FORCE TEST

	LDA	NEWCOL
	CMP	#2		;SEE IF DOWN KEY
	BNE	UP220
	LDA	#DUCKING
	AND	ENEMYINTS,X	;MAKE SURE ITS ENABLED
	BNE	UP220
	LDA	#EDUCK		;IF DOWN ON SOLID, REQUEST DUCK MODE
	STA	ENEMYREQ,X	
UP220:	RTS

;THIS ROUTINE MAKES A DING SOUND USING A SLOT THAT IS NOT USED FOR
;ANYTHING ELSE.

MAKEDING:				
	LDA	#DINGSLOT
	JSR	SILENCE
	LDX	#PNOISE & H'FF
	LDY	#PNOISE >> 8
	LDA	#DINGSLOT
	JSR	PLAY
	RTS

;THIS ROUTINE WILL POP A RETURN ADDRESS AND RETURN IF WE ARE IN THE BOOT
;WORLD (WORLD 0).  IT CAN BE USED TO SKIP A SUB IF ITS THE BOOT WORLD.

NOTBOOT:
	LDA	CURWORLD
	BEQ	NTBT10
	RTS

;THIS ROUTINE WILL POP A RETURN ADDRESS AND RETURN IF WE ARE IN AN INSTRUCTIONS
;WORLD.  IT CAN BE USED TO SKIP A SUB IF ITS NOT A REAL WORLD.

NOTINST:
	LDA	CURWORLD
	BPL	NTBT15
NTBT10:	PLA
	PLA
NTBT15:	RTS

	.END

